[{"/home/sourabh/Downloads/react/visualization/src/index.js":"1","/home/sourabh/Downloads/react/visualization/src/App.js":"2","/home/sourabh/Downloads/react/visualization/src/visualizers/PathfindingVisualizer.jsx":"3","/home/sourabh/Downloads/react/visualization/src/algorithms/dijkstra.js":"4","/home/sourabh/Downloads/react/visualization/src/models/Node/Node.jsx":"5","/home/sourabh/Downloads/react/visualization/src/algorithms/DFS.js":"6","/home/sourabh/Downloads/react/visualization/src/algorithms/BFS.js":"7"},{"size":168,"mtime":1616949317524,"results":"8","hashOfConfig":"9"},{"size":268,"mtime":1616867199773,"results":"10","hashOfConfig":"9"},{"size":9069,"mtime":1617004767514,"results":"11","hashOfConfig":"9"},{"size":3225,"mtime":1616997622714,"results":"12","hashOfConfig":"9"},{"size":743,"mtime":1617002358463,"results":"13","hashOfConfig":"9"},{"size":3350,"mtime":1616998009366,"results":"14","hashOfConfig":"9"},{"size":3348,"mtime":1616997659459,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"15hazi4",{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"23","messages":"24","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"18"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"28","messages":"29","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30","usedDeprecatedRules":"18"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"18"},"/home/sourabh/Downloads/react/visualization/src/index.js",[],["34","35"],"/home/sourabh/Downloads/react/visualization/src/App.js",[],"/home/sourabh/Downloads/react/visualization/src/visualizers/PathfindingVisualizer.jsx",["36","37","38","39","40","41"],"/home/sourabh/Downloads/react/visualization/src/algorithms/dijkstra.js",["42","43"],"export default function dijkstra(grid,startnode,endnode){\r\n  startnode.distance=0;\r\n  const visited = new Map();\r\n  const visitedinorder =[];\r\n  const visitList = [];\r\n  visitList.push(startnode);\r\n  const graph=creategraph(grid);\r\n  while(visitList.length !== 0) {\r\n      const node = visitList.shift();\r\n      if(node && !visited.has(node)) {\r\n          if (node.isWall) continue;\r\n          visitedinorder.push(node);\r\n          visited.set(node);\r\n          console.log(node.row);\r\n          console.log(node.col);\r\n          if(node==endnode){\r\n              return visitedinorder;\r\n          }\r\n          graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n          updateUnvisitedNeighbors(visitList,node,graph);\r\n          sortnodebydistance(visitList);\r\n      }\r\n  }\r\n  return visitedinorder;\r\n}\r\n\r\nfunction creategraph(grid){\r\n  const graph=new Graph(1000);\r\n  for (let row = 0; row < 20; row++) {\r\n      for (let col = 0; col < 50; col++) {\r\n        graph.addVertex(grid[row][col]);\r\n      }\r\n  }\r\n  for (let row = 0; row < 20; row++) {\r\n      for (let col = 0; col < 50; col++) {\r\n          if((col+1<50)){\r\n              graph.addEdge(grid[row][col],grid[row][col+1]);\r\n          }\r\n          if((row+1)<20){\r\n              graph.addEdge(grid[row][col],grid[row+1][col]);\r\n          }\r\n          if((col-1)>=0){\r\n              graph.addEdge(grid[row][col],grid[row][col-1]);\r\n          }\r\n          if((row-1)>=0){\r\n              graph.addEdge(grid[row][col],grid[row-1][col]);\r\n          }         \r\n             \r\n      }\r\n    }\r\n  return graph;\r\n}\r\n\r\nclass Graph { \r\n  constructor(noOfVertices) { \r\n      this.noOfVertices = noOfVertices; \r\n      this.AdjList = new Map(); \r\n  }\r\n  addVertex(v) { \r\n  this.AdjList.set(v, []); \r\n  } \r\n  addEdge(v, w) { \r\n  this.AdjList.get(v).push(w);\r\n  }\r\n  getAdjacents(node) {\r\n      return this.AdjList.get(node);\r\n  }\r\n  \r\n  isAdjacent(node,neighbor) {\r\n      var temp=0;\r\n      this.AdjList.get(node).forEach(adj => {\r\n          if(adj === neighbor){\r\n              temp++;\r\n          }\r\n      })\r\n      if(temp==0){\r\n          return false;\r\n      }else{\r\n          return true;\r\n      }\r\n  }\r\n} \r\n\r\nfunction sortnodebydistance(unvisitednodes){\r\n  unvisitednodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList,node,graph) {\r\n  for (const neighbor of visitList) {\r\n      if((neighbor.previousNode !== null && neighbor.distance <= node.distance)  || !graph.isAdjacent(node,neighbor) ){\r\n          continue;\r\n      }else if(graph.isAdjacent(node,neighbor)){\r\n          neighbor.distance = node.distance + 1;\r\n          neighbor.previousNode = node;\r\n      }\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderDijkstra(finishNode,startNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    console.log(currentNode.row);\r\n    console.log(currentNode.col);\r\n    currentNode = currentNode.previousNode;\r\n    if(currentNode===startNode){\r\n        console.log(currentNode.row);\r\n        console.log(currentNode.col);\r\n        break;\r\n    }\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/home/sourabh/Downloads/react/visualization/src/models/Node/Node.jsx",["44"],"/home/sourabh/Downloads/react/visualization/src/algorithms/DFS.js",["45","46"],"\nexport default function DFS(grid,startNode, finishNode){\n    if(startNode==finishNode || !startNode || !finishNode){\n        return false;\n    }\n    console.log(\"in DFS\");\n    var count=0;\n    startNode.distance=0;\n    const visited=new Map();\n    const visitedinorder=[];\n    const visitList=[];\n    visitList.push(startNode)\n    const graph=creategraph(grid);\n    while(visitList.length!==0)\n    {\n        const node =visitList.pop();\n        if(node && !visited.has(node))\n        {\n            if (node.isWall) continue;\n            visitedinorder.push(node);\n            count++;\n            visited.set(node);\n            console.log(\"visited\");\n            console.log(node.row);\n            console.log(node.col);\n            if(node===finishNode){\n                console.log(\"count\",count);\n                return visitedinorder;\n            }\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\n            updateUnvisitedNeighbors(visitList,node,graph);\n        }\n    }\n    return visitedinorder;\n\n}\n\n\n\nfunction creategraph(grid){\n    const graph=new Graph(1000);\n    for(let row=0;row<15;row++)\n    {\n        for(let col=0;col<40;col++)\n        {\n            graph.addVertex(grid[row][col]);\n        }\n    }\n    for(let row=0;row<15;row++)\n    {\n        for(let col=0;col<40;col++)\n        {\n            if((col+1<40)){\n                graph.addEdge(grid[row][col],grid[row][col+1]);\n            }\n            if((col-1>=0)){\n                graph.addEdge(grid[row][col],grid[row][col-1]);\n            }\n            if((row-1)>=0){\n                graph.addEdge(grid[row][col],grid[row-1][col]);\n            }\n            if((row+1)<15){\n                graph.addEdge(grid[row][col],grid[row+1][col]);\n            }\n        }\n    }\n    return graph;\n}\n\n\nclass Graph{\n  constructor(noOfVertices){\n      this.noOfVertices=noOfVertices;\n      this.Adjlist=new Map();\n  }  \n\n  addVertex(v){\n    this.Adjlist.set(v,[]);\n  }\n\n  addEdge(v,w){\n     this.Adjlist.get(v).push(w);\n  }\n\n  getAdjacents(node){\n      return this.Adjlist.get(node);\n  }\n\n  isAdjacent(node,neighbor) {\n    var temp=0;\n    // this.AdjList.get(node).forEach(adj => {\n    //     if(adj === neighbor){\n    //         temp++;\n    //     }\n    // })\n    this.Adjlist.get(neighbor).forEach( x => {\n        if(x==node){\n            temp++;\n        }\n    })\n    if(temp===0){\n        return false;\n    }else{\n        return true;\n    }\n}\n}\n\nfunction updateUnvisitedNeighbors(visitList,node,graph) {\n    for (const neighbor of visitList) {\n        console.log(neighbor);\n        if(neighbor.previousNode!==null && !graph.isAdjacent(node,neighbor)){\n            continue;\n        }else if(graph.isAdjacent(node,neighbor)){\n            neighbor.previousNode = node;\n        }\n    }\n  }\n\nexport function getNodesInShortestPathOrderDFS(finishNode,startNode) {\n    console.log(\"shortest Path\");\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      console.log(currentNode.row);\n      console.log(currentNode.col);\n      currentNode = currentNode.previousNode;\n      if(currentNode===startNode){\n          console.log(currentNode.row);\n          console.log(currentNode.col);\n          break;\n      }\n    }\n    return nodesInShortestPathOrder;\n  }","/home/sourabh/Downloads/react/visualization/src/algorithms/BFS.js",["47","48"],"\nexport default function BFS(grid,startNode, finishNode){\n    if(startNode==finishNode || !startNode || !finishNode){\n        return false;\n    }\n    console.log(\"in BFS\");\n    var count=0;\n    startNode.distance=0;\n    const visited=new Map();\n    const visitedinorder=[];\n    const visitList=[];\n    visitList.push(startNode)\n    const graph=creategraph(grid);\n    while(visitList.length!==0)\n    {\n        const node =visitList.shift();\n        if(node && !visited.has(node))\n        {\n            if (node.isWall) continue;\n            visitedinorder.push(node);\n            count++;\n            visited.set(node);\n            console.log(\"visited\");\n            console.log(node.row);\n            console.log(node.col);\n            if(node===finishNode){\n                console.log(\"count\",count);\n                return visitedinorder;\n            }\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\n            updateUnvisitedNeighbors(visitList,node,graph);\n        }\n    }\n    return visitedinorder;\n\n}\n\n\n\nfunction creategraph(grid){\n    const graph=new Graph(1000);\n    for(let row=0;row<20;row++)\n    {\n        for(let col=0;col<50;col++)\n        {\n            graph.addVertex(grid[row][col]);\n        }\n    }\n    for(let row=0;row<20;row++)\n    {\n        for(let col=0;col<50;col++)\n        {\n            if((col+1<50)){\n                graph.addEdge(grid[row][col],grid[row][col+1]);\n            }\n            if((col-1>=0)){\n                graph.addEdge(grid[row][col],grid[row][col-1]);\n            }\n            if((row-1)>=0){\n                graph.addEdge(grid[row][col],grid[row-1][col]);\n            }\n            if((row+1)<20){\n                graph.addEdge(grid[row][col],grid[row+1][col]);\n            }\n        }\n    }\n    return graph;\n}\n\n\nclass Graph{\n  constructor(noOfVertices){\n      this.noOfVertices=noOfVertices;\n      this.Adjlist=new Map();\n  }  \n\n  addVertex(v){\n    this.Adjlist.set(v,[]);\n  }\n\n  addEdge(v,w){\n     this.Adjlist.get(v).push(w);\n  }\n\n  getAdjacents(node){\n      return this.Adjlist.get(node);\n  }\n\n  isAdjacent(node,neighbor) {\n    var temp=0;\n    // this.AdjList.get(node).forEach(adj => {\n    //     if(adj === node){\n    //         temp++;\n    //     }\n    // })\n    this.Adjlist.get(neighbor).forEach( x => {\n        if(x==node){\n            temp++;\n        }\n    })\n    if(temp===0){\n        return false;\n    }else{\n        return true;\n    }\n}\n}\n\nfunction updateUnvisitedNeighbors(visitList,node,graph) {\n    console.log(\"neigbour\");\n    for (const neighbor of visitList) {\n        if(!graph.isAdjacent(node,neighbor) || neighbor.previousNode !== null){\n            continue;\n        }else if(graph.isAdjacent(node,neighbor)){\n            neighbor.previousNode = node;\n        }\n    }\n  }\n\nexport function getNodesInShortestPathOrderBFS(finishNode,startNode) {\n    console.log(\"shortest Path\");\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      console.log(currentNode.row);\n      console.log(currentNode.col);\n      currentNode = currentNode.previousNode;\n      if(currentNode===startNode){\n          console.log(currentNode.row);\n          console.log(currentNode.col);\n          break;\n      }\n    }\n    return nodesInShortestPathOrder;\n  }",{"ruleId":"49","replacedBy":"50"},{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","severity":1,"message":"54","line":20,"column":10,"nodeType":"55","messageId":"56","endLine":20,"endColumn":18},{"ruleId":"53","severity":1,"message":"57","line":21,"column":10,"nodeType":"55","messageId":"56","endLine":21,"endColumn":18},{"ruleId":"58","severity":1,"message":"59","line":112,"column":18,"nodeType":"60","messageId":"61","endLine":112,"endColumn":20},{"ruleId":"58","severity":1,"message":"59","line":116,"column":23,"nodeType":"60","messageId":"61","endLine":116,"endColumn":25},{"ruleId":"58","severity":1,"message":"59","line":120,"column":23,"nodeType":"60","messageId":"61","endLine":120,"endColumn":25},{"ruleId":"58","severity":1,"message":"59","line":275,"column":28,"nodeType":"60","messageId":"61","endLine":275,"endColumn":30},{"ruleId":"58","severity":1,"message":"59","line":16,"column":18,"nodeType":"60","messageId":"61","endLine":16,"endColumn":20},{"ruleId":"58","severity":1,"message":"59","line":76,"column":14,"nodeType":"60","messageId":"61","endLine":76,"endColumn":16},{"ruleId":"58","severity":1,"message":"62","line":24,"column":16,"nodeType":"60","messageId":"61","endLine":24,"endColumn":18},{"ruleId":"58","severity":1,"message":"59","line":3,"column":17,"nodeType":"60","messageId":"61","endLine":3,"endColumn":19},{"ruleId":"58","severity":1,"message":"59","line":97,"column":13,"nodeType":"60","messageId":"61","endLine":97,"endColumn":15},{"ruleId":"58","severity":1,"message":"59","line":3,"column":17,"nodeType":"60","messageId":"61","endLine":3,"endColumn":19},{"ruleId":"58","severity":1,"message":"59","line":97,"column":13,"nodeType":"60","messageId":"61","endLine":97,"endColumn":15},"no-native-reassign",["63"],"no-negated-in-lhs",["64"],"no-unused-vars","'isActive' is assigned a value but never used.","Identifier","unusedVar","'isPaused' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","no-global-assign","no-unsafe-negation"]