[{"/home/sourabh/Downloads/react/tmp/Visualization/src/index.js":"1","/home/sourabh/Downloads/react/tmp/Visualization/src/App.js":"2","/home/sourabh/Downloads/react/tmp/Visualization/src/visualizers/PathfindingVisualizer.jsx":"3","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/basicWeighted.js":"4","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/Simplestair.js":"5","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/verticaldiv.js":"6","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/recursive.js":"7","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/basicRandom.js":"8","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/horizontaldiv.js":"9","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/Snakemaze.js":"10","/home/sourabh/Downloads/react/tmp/Visualization/src/components/Card.js":"11","/home/sourabh/Downloads/react/tmp/Visualization/src/algorithms/BFS.js":"12","/home/sourabh/Downloads/react/tmp/Visualization/src/algorithms/dijkstra.js":"13","/home/sourabh/Downloads/react/tmp/Visualization/src/algorithms/DFS.js":"14","/home/sourabh/Downloads/react/tmp/Visualization/src/algorithms/Astar.js":"15","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/chanceMazeV.js":"16","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/chanceMazeH.js":"17","/home/sourabh/Downloads/react/tmp/Visualization/src/models/Node/Node.jsx":"18"},{"size":168,"mtime":1618029189295,"results":"19","hashOfConfig":"20"},{"size":268,"mtime":1618759943892,"results":"21","hashOfConfig":"20"},{"size":27484,"mtime":1618892487616,"results":"22","hashOfConfig":"20"},{"size":651,"mtime":1618412414227,"results":"23","hashOfConfig":"20"},{"size":597,"mtime":1618892487612,"results":"24","hashOfConfig":"20"},{"size":1402,"mtime":1618759900035,"results":"25","hashOfConfig":"20"},{"size":3216,"mtime":1618892487612,"results":"26","hashOfConfig":"20"},{"size":1813,"mtime":1618892487612,"results":"27","hashOfConfig":"20"},{"size":1412,"mtime":1618892487612,"results":"28","hashOfConfig":"20"},{"size":1651,"mtime":1618892487612,"results":"29","hashOfConfig":"20"},{"size":603,"mtime":1618892487588,"results":"30","hashOfConfig":"20"},{"size":3524,"mtime":1618412414227,"results":"31","hashOfConfig":"20"},{"size":3527,"mtime":1618412414227,"results":"32","hashOfConfig":"20"},{"size":3402,"mtime":1618412414227,"results":"33","hashOfConfig":"20"},{"size":3269,"mtime":1618412414223,"results":"34","hashOfConfig":"20"},{"size":2447,"mtime":1618892487612,"results":"35","hashOfConfig":"20"},{"size":2450,"mtime":1618892487612,"results":"36","hashOfConfig":"20"},{"size":743,"mtime":1618029189295,"results":"37","hashOfConfig":"20"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"dytndw",{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":54,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"40"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"40"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"40"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"40"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"40"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68","usedDeprecatedRules":"40"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"40"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74","usedDeprecatedRules":"40"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"40"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80","usedDeprecatedRules":"40"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83","usedDeprecatedRules":"40"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"86","usedDeprecatedRules":"87"},"/home/sourabh/Downloads/react/tmp/Visualization/src/index.js",[],["88","89"],"/home/sourabh/Downloads/react/tmp/Visualization/src/App.js",[],"/home/sourabh/Downloads/react/tmp/Visualization/src/visualizers/PathfindingVisualizer.jsx",["90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143"],"import React, { useEffect, useState, useRef } from 'react';\nimport { Carousel } from 'react-bootstrap';\nimport dijkstra, { getNodesInShortestPathOrderDijkstra } from '../algorithms/dijkstra';\nimport BFS, { getNodesInShortestPathOrderBFS } from '../algorithms/BFS';\nimport DFS, { getNodesInShortestPathOrderDFS } from '../algorithms/DFS';\nimport AStar, { getNodesInShortestPathOrderAStar } from '../algorithms/Astar';\nimport { Nav, Navbar, Button, NavDropdown, Toast } from 'react-bootstrap';\nimport Node from '../models/Node/Node';\nimport './PathfindingVisualizer.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport basicRandom from '../mazeAlgorithms/basicRandom.js';\nimport basicWeighted from '../mazeAlgorithms/basicWeighted.js';\nimport Simplestair from '../mazeAlgorithms/Simplestair.js';\nimport recursive from '../mazeAlgorithms/recursive.js';\nimport verticaldiv from '../mazeAlgorithms/verticaldiv.js';\nimport horizontaldiv from '../mazeAlgorithms/horizontaldiv.js';\nimport Snake from '../mazeAlgorithms/Snakemaze';\nimport chanceMazeH from '../mazeAlgorithms/chanceMazeH';\nimport chanceMazeV from '../mazeAlgorithms/chanceMazeV';\nimport Cards from '../components/Card';\n// import logo1 from '../images/Logo.png';\nimport ReactDOM from 'react-dom';\n\nvar START_NODE_ROW = 10;\nvar START_NODE_COL = 10;\nvar FINISH_NODE_ROW = 8;\nvar FINISH_NODE_COL = 39;\n\nconst NODE_WEIGHT = 10;\n\nconst PathfindingVisualizer = () => {\n  const [grid, setGrid] = useState([]);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [timer, setTimer] = useState(0);\n  const [isActive, setIsActive] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [noOfCellVisited, setNoOfCellVisited] = useState(0);\n  const [totalcost, settotalcost] = useState(0);\n  const [algorithm, setAlgorithm] = useState(\"Choose Algorithm\");\n  const [mazeAlgorithm, setmazeAlgorithm] = useState(\"Choose Maze Algorithm\");\n  const [show, setShow] = useState(false);\n  const [showComp, setShowComp] = useState(false);\n  const [isAddWeight, setIsAddWeight] = useState(false);\n  const [isStartNode, setIsStartNode] = useState(false);\n  const [isEndNode, setIsEndNode] = useState(false);\n  const [compValues, setCompValues] = useState([]);\n  const [algoRunTime, setAlgoRunTime] = useState(0);\n  const [totalNodes, setTotalNodes] = useState(0);\n\n  const [l1, setL1] = useState([]);\n  const [l2, setL2] = useState([]);\n\n  const countRef = useRef(null)\n\n\n  const handleStart = () => {\n    setIsActive(true);\n    setIsPaused(true);\n    countRef.current = setInterval(() => {\n      setTimer((timer) => timer + 1);\n    }, 1000);\n  }\n\n  const handlePause = () => {\n    clearInterval(countRef.current);\n    setIsPaused(false);\n  }\n\n  const handleReset = () => {\n    clearInterval(countRef.current);\n    setIsActive(false);\n    setIsPaused(false);\n    setTimer(0);\n  }\n\n  const formatTime = () => {\n    const getSeconds = `0${(timer % 60)}`.slice(-2)\n    const minutes = `${Math.floor(timer / 60)}`\n    const getMinutes = `0${minutes % 60}`.slice(-2)\n    const getHours = `0${Math.floor(timer / 3600)}`.slice(-2)\n\n    return `${getHours} : ${getMinutes} : ${getSeconds}`\n  }\n\n  useEffect(() => {\n    console.log('component mounted');\n    const grid = getInitialGrid();\n    setGrid(grid);\n  }, [])\n  const movestart = (grid, row, col, isStartNode, isEndNode) => {\n    const newGrid = grid.slice();\n    if (isStartNode) {\n      newGrid[START_NODE_ROW][START_NODE_COL].isStart = false;\n    } else if (isEndNode) {\n      newGrid[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish = false;\n    }\n\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isStart: isStartNode,\n      isFinish: isEndNode,\n      isWall: false,\n      weight: 0,\n    };\n    newGrid[row][col] = newNode;\n    if (isStartNode) {\n      START_NODE_ROW = newNode.row;\n      START_NODE_COL = newNode.col;\n    } else if (isEndNode) {\n      FINISH_NODE_ROW = newNode.row;\n      FINISH_NODE_COL = newNode.col;\n    }\n\n    return newGrid;\n  }\n  const handleMouseDown = (row, col) => {\n    if (row == START_NODE_ROW && col == START_NODE_COL) {\n      setMouseIsPressed(true);\n      setIsStartNode(true);\n      return;\n    } else if (row == FINISH_NODE_ROW && col == FINISH_NODE_COL) {\n      setMouseIsPressed(true);\n      setIsEndNode(true);\n      return;\n    }\n    const newGrid = getNewGridWithWallToggled(grid, row, col, isAddWeight, isStartNode, isEndNode);\n    setGrid(newGrid);\n    setMouseIsPressed(true);\n  }\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseIsPressed) return;\n    var newGrid;\n    if (isStartNode || isEndNode) {\n      newGrid = movestart(grid, row, col, isStartNode, isEndNode);\n      setGrid(newGrid);\n    } else if (!((row == START_NODE_ROW && col == START_NODE_COL) || (row == FINISH_NODE_ROW && col == FINISH_NODE_COL))) {\n      newGrid = getNewGridWithWallToggled(grid, row, col, isAddWeight, isStartNode, isEndNode);\n      setGrid(newGrid);\n    }\n  }\n\n  const handleMouseUp = (row, col) => {\n    setMouseIsPressed(false);\n    setIsStartNode(false);\n    setIsEndNode(false);\n  }\n\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\n      }, 10 * i);\n    }\n  }\n\n  const animateShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        if (node.weight === NODE_WEIGHT) {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-weight-in-path';\n        }\n        else {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n        }\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\n      }, 50 * i);\n    }\n    handlePause();\n  }\n\n\n\n  const clearBoard = () => {\n    handleReset();\n    setGrid(getInitialGrid());\n    setNoOfCellVisited(0);\n    settotalcost(0);\n    clearGrid();\n    setCompValues([]);\n    setAlgoRunTime(0);\n    // clea();\n    // setAlgorithm(\"Choose Algorithm\");\n    // setmazeAlgorithm(\"Choose Maze Algorithm\");\n    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\n    document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\n  }\n\n  const clearVisualization = (grid) => {\n    handleReset();\n    setGrid(getPartialGrid());\n    setNoOfCellVisited(0);\n    settotalcost(0);\n    clearGrid();\n    setAlgoRunTime(0);\n    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\n    document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\n  }\n\n  const getPartialGrid = () => {\n    for (let row = 0; row < 20; row++) {\n      for (let col = 0; col < 50; col++) {\n        grid[row][col].previousNode = null;\n      }\n    }\n    return grid;\n  }\n\n  const clearGrid = () => {\n    const newGrid = grid;\n    for (const row of newGrid) {\n      for (const node of row) {\n        let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`,).className;\n        if (nodeClassName !== 'node node-start' &&\n          nodeClassName !== 'node node-finish' &&\n          nodeClassName !== 'node node-wall') {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node';\n        }\n      }\n    }\n  }\n\n  const visualizeAlgorithm = () => {\n    clearVisualization();\n    handleStart();\n    var start = new Date().getTime();\n    // console.log(\"Start: \", start)\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    let visitedNodesInOrder, nodesInShortestPathOrder;\n    if (algorithm == \"Dijkstra\") {\n      visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(finishNode, startNode);\n      var start2 = new Date().getTime();\n      setAlgoRunTime(start2 - start);\n      setShowComp(true);\n    }\n    else if (algorithm == \"BFS\") {\n      visitedNodesInOrder = BFS(grid, startNode, finishNode);\n      nodesInShortestPathOrder = getNodesInShortestPathOrderBFS(finishNode, startNode);\n      var start2 = new Date().getTime();\n      setAlgoRunTime(start2 - start);\n      setShowComp(true);\n    }\n    else if (algorithm == \"DFS\") {\n      visitedNodesInOrder = DFS(grid, startNode, finishNode);\n      nodesInShortestPathOrder = getNodesInShortestPathOrderDFS(finishNode, startNode);\n      var start2 = new Date().getTime();\n      setAlgoRunTime(start2 - start);\n      setShowComp(true);\n    } else if (algorithm == \"AStar\") {\n      // var start = new Date().getTime();\n      // console.log(\"Start: \", start)\n      visitedNodesInOrder = AStar(grid, startNode, finishNode);\n      // console.log(visitedNodesInOrder.length);\n      nodesInShortestPathOrder = getNodesInShortestPathOrderAStar(finishNode, startNode);\n      // console.log(nodesInShortestPathOrder.length);\n      var start2 = new Date().getTime();\n      setAlgoRunTime(start2 - start);\n      setShowComp(true);\n    }\n    else {\n      setShow(true);\n      handlePause();\n      return;\n    }\n    // console.log(visitedNodesInOrder.length);\n    // console.log(nodesInShortestPathOrder.length);\n    setTotalNodes(visitedNodesInOrder.length);\n    setL1(visitedNodesInOrder);\n    setL2(nodesInShortestPathOrder);\n\n    settotalcost(finishNode.distance);\n    animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    setNoOfCellVisited(nodesInShortestPathOrder.length);\n  }\n\n  const demoMazeAlgorithm = () => {\n    if (mazeAlgorithm === \"Choose Maze Algorithm\") return;\n    clearBoard();\n    console.log(mazeAlgorithm);\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    if (mazeAlgorithm == \"Basic Random Maze\") {\n      var griddef = basicRandom(grid, startNode, finishNode);\n      for (var i = 0; i < griddef.length; i++) {\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\n          'node node-wall';\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col, isAddWeight);\n        setGrid(newGrid);\n      }\n    }\n    else if (mazeAlgorithm == \"Basic Weight Maze\") {\n      var griddef = basicWeighted(grid, startNode, finishNode);\n      for (var i = 0; i < griddef.length; i++) {\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\n          'node node-weight';\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col, isAddWeight);\n        setGrid(newGrid);\n      }\n    }\n    else if (mazeAlgorithm == \"Snake Maze\") {\n      // recursive(grid,0,grid.length-1,0,grid.length-1,startNode,finishNode);\n      // Snake(grid, startNode, finishNode);\n      var griddef = Snake(grid, startNode, finishNode);\n      for (var i = 0; i < griddef.length; i++) {\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\n          'node node-weight';\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\n        setGrid(newGrid);\n      }\n    }\n    else if (mazeAlgorithm == \"Simple Stair Pattern\") {\n      var griddef = Simplestair(grid, startNode, finishNode);\n      for (var i = 0; i < griddef.length; i++) {\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\n          'node node-weight';\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\n        setGrid(newGrid);\n      }\n    }\n    else if (mazeAlgorithm == \"Recursive Division\") {\n      var griddef = recursive(grid, startNode, finishNode);\n      for (let i = 0; i < 20; i++) {\n        for (let j = 0; j < 50; j++) {\n          if (i == 0 || i == 19 || j == 0 || j == 49) {\n            document.getElementById(`node-${i}-${j}`).className = 'node node-wall';\n            const newGrid = getNewGridWithWallToggled(grid, i, j, isAddWeight, isStartNode, isEndNode);\n            setGrid(newGrid);\n          }\n        }\n      }\n      for (let i = 0; i < griddef.length; i++) {\n        if (document.getElementById(`node-${griddef[i][0] + 2}-${griddef[i][1] + 2}`).className != 'node node-wall') {\n          document.getElementById(`node-${griddef[i][0] + 2}-${griddef[i][1] + 2}`).className = 'node node-wall';\n          const newGrid = getNewGridWithWallToggled(grid, griddef[i][0] + 2, griddef[i][1] + 2, isAddWeight, isStartNode, isEndNode);\n          setGrid(newGrid);\n        }\n      }\n    } else if (mazeAlgorithm == \"Vertical Division\") {\n      var griddef = verticaldiv(grid, startNode, finishNode);\n      for (var i = 0; i < griddef.length; i++) {\n        document.getElementById(`node-${griddef[i][0]}-${griddef[i][1]}`).className = 'node node-wall';\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i][0], griddef[i][1], isAddWeight, isStartNode, isEndNode);\n        setGrid(newGrid);\n      }\n    }\n    else if (mazeAlgorithm == \"Horizontal Division\") {\n      var griddef = horizontaldiv(grid, startNode, finishNode);\n      for (var i = 0; i < griddef.length; i++) {\n        document.getElementById(`node-${griddef[i][0]}-${griddef[i][1]}`).className = 'node node-wall';\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i][0], griddef[i][1], isAddWeight, isStartNode, isEndNode);\n        setGrid(newGrid);\n      }\n    }\n\n    else if (mazeAlgorithm == \"Chance Maze Horizontal\") {\n      var griddef = chanceMazeH(grid, 0, grid.length - 1, 0, grid[0].length - 1, startNode, finishNode);\n      for (var i = 0; i < griddef.length; i++) {\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\n          'node node-weight';\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\n        setGrid(newGrid);\n      }\n    }\n    else if (mazeAlgorithm == \"Chance Maze Vertical\") {\n      var griddef = chanceMazeV(grid, 0, grid.length - 1, 0, grid[0].length - 1, startNode, finishNode);\n      for (var i = 0; i < griddef.length; i++) {\n        // setTimeout(()=>{\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\n          'node node-wall';\n        // },1000);\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\n        setGrid(newGrid);\n      }\n    }\n  }\n\n  const compareVisualization = () => {\n    var maze1 = \"\";\n    if (mazeAlgorithm == \"Choose Maze Algorithm\") {\n      maze1 = \"Not selected\";\n    }\n    else {\n      maze1 = mazeAlgorithm;\n    }\n    const startEndVertices = [START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL]\n    const listOfValues = [startEndVertices, algorithm, totalcost, noOfCellVisited, algoRunTime, maze1, totalNodes, l1, l2];\n    setCompValues([...compValues, listOfValues]);\n    console.log(\"PathVisualizer:\", compValues);\n  }\n\n  const deleteComparison = (index) => {\n    const newList = Object.assign([], compValues);\n    newList.splice(index, 1);\n    setCompValues(newList);\n    // console(newList);\n    // console.log(compValues.splice(index,1));\n  }\n\n  const showFinalStateOfAlgo = (index) => {\n    START_NODE_ROW = compValues[index][0][0];\n    START_NODE_COL = compValues[index][0][1];\n    FINISH_NODE_ROW = compValues[index][0][2];\n    FINISH_NODE_COL = compValues[index][0][3];\n    const newGrid = grid;\n    for (const row of newGrid) {\n      for (const node of row) {\n        let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`,).className;\n        if (nodeClassName !== 'node node-wall') {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n        }\n      }\n    }\n    for (let i = 0; i <= compValues[index][7].length; i++) {\n      if (i === compValues[index][7].length) {\n        for (let i = 0; i < compValues[index][8].length; i++) {\n          const node = compValues[index][8][i];\n          if (node.weight === NODE_WEIGHT) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-weight-in-path';\n          }\n          else {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n          }\n          document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\n          document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\n        }\n        return;\n      }\n      const node = compValues[index][7][i];\n      document.getElementById(`node-${node.row}-${node.col}`).className =\n        'node node-visited';\n      document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\n      document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\n    }\n  }\n\n  const compareAll = () => {\n    const getRandomColor = () => {\n      var letters = '0123456789ABCDEF';\n      var color = '#';\n      for (var i = 0; i < 6; i++) {\n        color += letters[Math.floor(Math.random() * 16)];\n      }\n      return color;\n    }\n\n    const showOnlyOneAlgoFinalPath = (index, color) => {\n      for (let i = 0; i < compValues[index][8].length; i++) {\n        const node = compValues[index][8][i];\n        document.getElementById(`node-${node.row}-${node.col}`).style = `background-color: ${color};`;\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\n      }\n    }\n\n    let listOfColors = [];\n    for (let index = 0; index < compValues.length; index++) {\n      const colorOfShortestPath = getRandomColor();\n      listOfColors.push(colorOfShortestPath);\n      showOnlyOneAlgoFinalPath(index, colorOfShortestPath);\n    }\n    const parentElement = document.getElementById('indication');\n    let l = [];\n    for (let i = 0; i < listOfColors.length; i++) {\n      const x = <div onClick={() => showOnlyOneAlgoFinalPath(i, listOfColors[i])} style={{ width: '25px', height: '25px', backgroundColor: `${listOfColors[i]}`, padding: '3px' }}>{i + 1}</div>;\n      l.push(x);\n    }\n    ReactDOM.render(l, parentElement);\n  }\n\n\n  const addWeights = () => {\n    setIsAddWeight(!isAddWeight);\n  }\n  useEffect(() => {\n    demoMazeAlgorithm();\n  }, [mazeAlgorithm]);\n\n  return (\n    <>\n      <Navbar bg=\"light\" variant=\"light\">\n        <div className=\"container\">\n          <Navbar.Brand href=\"#home\" style={{ color: '#00BACF' }}>AlgoComp</Navbar.Brand>\n          {/* <Navbar.Brand href=\"#home\"><img src={logo1} alt=\"Logo\" height=\"90\" width=\"90\"/></Navbar.Brand> */}\n          <Nav className=\"mr-auto\">\n            <NavDropdown title={algorithm} id=\"basic-nav-dropdown\">\n              <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"Dijkstra\")}>Dijkstra</NavDropdown.Item>\n              <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"BFS\")}>BFS</NavDropdown.Item>\n              <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"DFS\")}>DFS</NavDropdown.Item>\n              <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"AStar\")}>AStar</NavDropdown.Item>\n            </NavDropdown>\n            <NavDropdown title={mazeAlgorithm} id=\"basic-nav-dropdown\">\n              <NavDropdown.Item href=\"\" onClick={() => {\n                setmazeAlgorithm(\"Basic Random Maze\");\n              }}>Basic Random Maze</NavDropdown.Item>\n              <NavDropdown.Item href=\"\" onClick={() => {\n                setmazeAlgorithm(\"Basic Weight Maze\");\n              }}>Basic Weight Maze</NavDropdown.Item>\n              {/* <NavDropdown.Item href=\"\" onClick={() => {\n                setmazeAlgorithm(\"Simple Stair Pattern\");\n              }}>Simple Stair Pattern</NavDropdown.Item>\n              <NavDropdown.Item href=\"\" onClick={() => {\n                setmazeAlgorithm(\"Snake Maze\");\n              }}>Snake Maze</NavDropdown.Item> */}\n              <NavDropdown.Item href=\"\" onClick={() => {\n                setmazeAlgorithm(\"Vertical Division\");\n              }}>Vertical Division</NavDropdown.Item>\n              <NavDropdown.Item href=\"\" onClick={() => {\n                setmazeAlgorithm(\"Horizontal Division\");\n              }}>Horizontal Division</NavDropdown.Item>\n              <NavDropdown.Item href=\"\" onClick={() => {\n                setmazeAlgorithm(\"Recursive Division\");\n              }}>Recursive Division</NavDropdown.Item>\n              {/* <NavDropdown.Item href=\"\" onClick={() => {\n                setmazeAlgorithm(\"Chance Maze Horizontal\");\n              }}>Chance Maze Horizontal</NavDropdown.Item>\n              <NavDropdown.Item href=\"\" onClick={() => {\n                setmazeAlgorithm(\"Chance Maze Vertical\");\n              }}>Chance Maze Vertical</NavDropdown.Item> */}\n            </NavDropdown>\n          </Nav>\n          <div>\n            <Toast onClose={() => setShow(false)} show={show} delay={3000} autohide\n              style={{\n                position: 'absolute',\n                top: 0,\n                right: \"50%\",\n              }}>\n              <Toast.Header>\n                <strong className=\"mr-auto\">First Choose Algorithm</strong>\n              </Toast.Header>\n            </Toast>\n            <Toast onClose={() => clearVisualization()} show={totalcost == Infinity} delay={3000}\n              style={{\n                position: 'absolute',\n                top: 0,\n                right: \"50%\",\n              }}>\n              <Toast.Header>\n                <strong className=\"mr-auto\">No Path Found</strong>\n              </Toast.Header>\n            </Toast>\n          </div>\n          <div className=\"m\">\n            <span className=\"pBtn\">\n              <Button variant={isAddWeight ? \"danger\" : \"success\"} size=\"sm\" onClick={() => addWeights()}>\n                {isAddWeight ? \"Adding Weights\" : \"Add Weights\"}\n              </Button>\n            </span>\n            <span className=\"pBtn\">\n              <Button variant=\"secondary\" size=\"sm\" onClick={() => clearBoard()}>Clear Board</Button>\n            </span>\n            <span className=\"pBtn\">\n              <Button variant=\"secondary\" size=\"sm\" onClick={(grid) => clearVisualization(grid)}>Clear Visualization</Button>\n            </span>\n            <Button variant=\"primary\" onClick={() => visualizeAlgorithm()}>Start</Button>\n\n            {/* <span className=\"pBtn\" style={{ marginLeft: '10px' }}>\n              {showComp ?\n                <Button variant=\"primary\" onClick={() => compareVisualization()}>Compare</Button>\n                : <span></span>\n              }\n            </span>\n            <span className=\"pBtn\">\n              {showComp ?\n                <Button variant=\"danger\" onClick={() => setCompValues([])}>Clear Comparison</Button>\n                : <span></span>\n              }\n            </span> */}\n            {/* <Button variant=\"danger\" onClick={() => deleteComparison(compValues.length - 1)}> {console.log(compValues.length - 1)} Clear1 Comparison</Button> */}\n          </div>\n        </div>\n      </Navbar>\n      <span className=\"pText\">{algorithm} Runtime</span>\n      <span className=\"timeBox\">{algoRunTime} ms</span>\n      <span className=\"pText\">Timer</span>\n      <span className=\"timeBox\">{formatTime()}</span>\n      <span className=\"pText\">No. of Cells Visited</span>\n      <span className=\"timeBox\">{noOfCellVisited}</span>\n      <span className=\"pText\">Total Cost</span>\n      <span className=\"timeBox\">{totalcost}</span>\n      <span className=\"pBtn\" style={{ marginLeft: '10px' }}>\n        {showComp ?\n          <Button variant=\"info\" size=\"sm\" onClick={() => compareVisualization()}>Add to Compare</Button>\n          : <span></span>\n        }\n      </span>\n      <span className=\"pBtn\">\n        {showComp ?\n          <Button variant=\"danger\" size=\"sm\" onClick={() => setCompValues([])}>Clear Comparison</Button>\n          : <span></span>\n        }\n      </span>\n      <span className=\"pBtn\">\n        {showComp ?\n          <Button variant=\"success\" size=\"sm\" onClick={() => compareAll()}>Compare All</Button>\n          : <span></span>\n        }\n      </span>\n      <div className=\"Flexbox1\">\n\n        {compValues.length != 0 ? (compValues.map((vis, index) => <div>\n          <div onClick={() => showFinalStateOfAlgo(index)}>\n            <Cards key={index} algo={vis[1]} tc={vis[2]} cells={vis[3]} time1={vis[4]} maze1={vis[5]} total1={vis[6]} >\n            </Cards>\n          </div>\n          <Button variant=\"outline-danger\" onClick={() => deleteComparison(index)}>\n            Remove\n          </Button>\n        </div>)) : console.log('else')}\n\n      </div>\n      <div className=\"Flexbox1\" style={{ margin: 'auto', width: '50%' }} id=\"indication\"></div>\n\n      <div className=\"grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node, nodeIdx) => {\n                const { row, col, isFinish, isStart, isWall, weight } = node;\n                return (\n                  <Node\n                    key={nodeIdx}\n                    col={col}\n                    isFinish={isFinish}\n                    isStart={isStart}\n                    isWall={isWall}\n                    mouseIsPressed={mouseIsPressed}\n                    weight={weight}\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) =>\n                      handleMouseEnter(row, col)\n                    }\n                    onMouseUp={() => handleMouseUp()}\n                    row={row}></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </>\n  );\n}\n\n\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    weight: 0,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col, isAddWeight, isStartNode, isEndNode) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: (isAddWeight || isStartNode || isEndNode) ? false : !node.isWall,\n    weight: node.weight == 0 && isAddWeight ? NODE_WEIGHT : 0,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\nexport default PathfindingVisualizer;\n","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/basicWeighted.js",["144","145","146","147"],"function basicWeighted(grid, startNode, finishNode) {\n     var grid1 = []\n     for (var i = 0; i < 20; i += 3) {\n          for (var j = 0; j < 50; j += 3) {\n               var x = Math.floor((Math.random() * 10) + 1);\n               var col = Math.abs(i - x);\n               var row = Math.abs(j - x);\n               if (col == startNode.col && row == startNode.row) {\n                    continue;\n               }\n               else if (col == finishNode.col && row == finishNode.row) {\n                    continue;\n               }\n               grid1.push(grid[col][row]);\n          }\n     }\n     return grid1;\n}\n\n\nexport default basicWeighted;","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/Simplestair.js",["148","149","150","151"],"function Simplestair(grid, startNode, finishNode) {\n  var grid1 = [];\n  let x = grid.length;\n  let y = 0;\n  while (x < 2 * (grid.length) - 1 && y < grid.length - 4) {\n    if (grid[y][x] == startNode || grid[y][x] == finishNode) {\n      continue;\n    }\n    else {\n      grid1.push(grid[y][x]);\n    }\n    x++;\n    y++;\n  };\n  x = grid.length - 1;\n  y = 0;\n  while (x >= 0 && y < grid.length - 1) {\n    if (grid[y][x] == startNode || grid[y][x] == finishNode) {\n      continue;\n    }\n    else {\n      grid1.push(grid[y][x]);\n    }\n    x--;\n    y++;\n  };\n  return grid1;\n}\n\nexport default Simplestair;","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/verticaldiv.js",[],"/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/recursive.js",[],"/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/basicRandom.js",["152","153","154","155","156","157"],"function basicRandom(grid, startNode, finishNode) {\n     var grid1 = []\n     // let cIdY=grid.length[0]-10;\n     // for(let c=0 ;c<10;c++)\n     // {\n     //      let cIdXone= Math.floor(grid.length/2)-c;\n     //      let cIdXtwo = Math.floor(grid.length/2)+c;\n     //      // let cIdone = cIdY-cIdXone;\n     //      // let cIdtwo = cIdY-cIdXtwo;\n     //      console.log(cIdXone);\n     //      console.log(cIdXtwo);\n     //      // console.log((cIdY,cIdtwo));\n     //      if(cIdy>=20 || CIdXone>=50 || cIdXtwo>=50){\n     //           continue;\n     //      }\n     //      else{\n     //           grid1.push(grid[cIdY][cIdXone]);\n     //           grid1.push(grid[cIdY][cIdXtwo]);\n     //      }\n     //      // console.log(cIdone);\n     //      // console.log(cIdtwo);\n     // }\n     for (var i = 0; i < 20; i += 3) {\n          for (var j = 0; j < 50; j += 3) {\n               var x = Math.floor((Math.random() * 10) + 1);\n               var col = Math.abs(i - x);\n               var row = Math.abs(j - x);\n               if (col == startNode.col && row == startNode.row) {\n                    continue;\n               }\n               else if (col == finishNode.col && row == finishNode.row) {\n                    continue;\n               }\n               if (grid1.length > 1) {\n                    var count = 0;\n                    for (var k = 0; k < grid1.length; k++) {\n                         if (grid1[k] == grid[col][row]) {\n                              count = 1;\n                         }\n                    }\n                    if (count == 0) {\n                         grid1.push(grid[col][row]);\n                    }\n               }\n               else {\n                    grid1.push(grid[col][row]);\n               }\n          }\n     }\n     return grid1;\n}\n\n\nexport default basicRandom;","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/horizontaldiv.js",[],"/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/Snakemaze.js",["158","159","160","161","162","163","164","165","166","167","168","169","170","171"],"function Snake(grid, startNode, finishNode) {\n    let grid1 = []\n    let nrequired = []\n    for (let k = 1; k < 10; k++) {\n        for (let j = 1; j < 15; j++) {\n            let x = Math.floor((Math.random() * 50) + 1);\n            nrequired.push(grid[j][x]);\n        }\n    }\n    for (var i = 1; i < 20; i += 2) {\n        for (var j = 0; j < 50; j++) {\n            if (grid[i][j] == startNode && grid[i][j] == finishNode) {\n                continue;\n            }\n            else {\n                if (grid[i][j] == startNode || grid[i][j] == finishNode) {\n                    continue;\n                }\n                else {\n                    let count = 1;\n                    for (let z = 0; z < nrequired.length; z++) {\n                        if (grid[i][j] == nrequired[z]) {\n                            count = 0;\n                        }\n                    }\n                    if (count == 1) {\n                        grid1.push(grid[i][j]);\n                    }\n                }\n            }\n        }\n    }\n    for (var i = 2; i < 20; i += 2) {\n        for (var j = 10; j < 30; j += 2) {\n            if (grid[i][j] == startNode || grid[i][j] == finishNode) {\n                continue;\n            }\n            else {\n                grid1.push(grid[i][j - i + 10]);\n            }\n        }\n    }\n    for (var i = 1; i < 20; i += 2) {\n        for (var j = 50; j < 50; j += 2) {\n            if (grid[i][j] == startNode || grid[i][j] == finishNode) {\n                continue;\n            }\n            else {\n                grid1.push(grid[i][j - i - 1]);\n            }\n        }\n    }\n    return grid1;\n}\n\nexport default Snake;","/home/sourabh/Downloads/react/tmp/Visualization/src/components/Card.js",[],"/home/sourabh/Downloads/react/tmp/Visualization/src/algorithms/BFS.js",["172","173","174"],"export default function BFS(grid, startNode, finishNode) {\n    if (startNode == finishNode || !startNode || !finishNode) {\n        return false;\n    }\n    // console.log(\"in BFS\");\n    var count = 0;\n    startNode.distance = 0;\n    const visited = new Map();\n    const visitedinorder = [];\n    const visitList = [];\n    visitList.push(startNode)\n    const graph = creategraph(grid);\n    while (visitList.length !== 0) {\n        const node = visitList.shift();\n        if (node && !visited.has(node)) {\n            if (node.isWall) continue;\n            visitedinorder.push(node);\n            count++;\n            visited.set(node);\n            // console.log(\"visited\");\n            // console.log(node.row);\n            // console.log(node.col);\n            if (node === finishNode) {\n                // console.log(\"count\",count);\n                return visitedinorder;\n            }\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\n            updateUnvisitedNeighbors(visitList, node, graph);\n        }\n    }\n    return visitedinorder;\n\n}\n\n\n\nfunction creategraph(grid) {\n    const graph = new Graph(1000);\n    for (let row = 0; row < 20; row++) {\n        for (let col = 0; col < 50; col++) {\n            graph.addVertex(grid[row][col]);\n        }\n    }\n    for (let row = 0; row < 20; row++) {\n        for (let col = 0; col < 50; col++) {\n            if ((col + 1 < 50)) {\n                graph.addEdge(grid[row][col], grid[row][col + 1]);\n            }\n            if ((col - 1 >= 0)) {\n                graph.addEdge(grid[row][col], grid[row][col - 1]);\n            }\n            if ((row - 1) >= 0) {\n                graph.addEdge(grid[row][col], grid[row - 1][col]);\n            }\n            if ((row + 1) < 20) {\n                graph.addEdge(grid[row][col], grid[row + 1][col]);\n            }\n        }\n    }\n    return graph;\n}\n\n\nclass Graph {\n    constructor(noOfVertices) {\n        this.noOfVertices = noOfVertices;\n        this.Adjlist = new Map();\n    }\n\n    addVertex(v) {\n        this.Adjlist.set(v, []);\n    }\n\n    addEdge(v, w) {\n        this.Adjlist.get(v).push(w);\n    }\n\n    getAdjacents(node) {\n        return this.Adjlist.get(node);\n    }\n\n    isAdjacent(node, neighbor) {\n        var temp = 0;\n        this.Adjlist.get(neighbor).forEach(x => {\n            if (x == node) {\n                temp++;\n            }\n        })\n        if (temp === 0) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n\nfunction updateUnvisitedNeighbors(visitList, node, graph) {\n    // console.log(\"neigbour\");\n    for (const neighbor of visitList) {\n        if (!graph.isAdjacent(node, neighbor) || neighbor.previousNode !== null) {\n            continue;\n        } else if (graph.isAdjacent(node, neighbor)) {\n            neighbor.distance = node.distance + neighbor.weight + 1;\n            neighbor.previousNode = node;\n        }\n    }\n}\n\nexport function getNodesInShortestPathOrderBFS(finishNode, startNode) {\n    // console.log(\"shortest Path\");\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        //   console.log(currentNode.row);\n        //   console.log(currentNode.col);\n        currentNode = currentNode.previousNode;\n        if (currentNode === startNode) {\n            //   console.log(currentNode.row);\n            //   console.log(currentNode.col);\n            break;\n        }\n    }\n    return nodesInShortestPathOrder;\n}\n","/home/sourabh/Downloads/react/tmp/Visualization/src/algorithms/dijkstra.js",["175","176"],"export default function dijkstra(grid, startnode, endnode) {\r\n    startnode.distance = 0;\r\n    const visited = new Map();\r\n    const visitedinorder = [];\r\n    const visitList = [];\r\n    visitList.push(startnode);\r\n    const graph = creategraph(grid);\r\n    while (visitList.length !== 0) {\r\n        const node = visitList.shift();\r\n        if (node && !visited.has(node)) {\r\n            if (node.isWall) continue;\r\n            visitedinorder.push(node);\r\n            visited.set(node);\r\n            //   console.log(node.row);\r\n            //   console.log(node.col);\r\n            if (node == endnode) {\r\n                return visitedinorder;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList, node, graph);\r\n            sortnodebydistance(visitList);\r\n        }\r\n    }\r\n    return visitedinorder;\r\n}\r\n\r\nfunction creategraph(grid) {\r\n    const graph = new Graph(1000);\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            if ((col + 1 < 50)) {\r\n                graph.addEdge(grid[row][col], grid[row][col + 1]);\r\n            }\r\n            if ((row + 1) < 20) {\r\n                graph.addEdge(grid[row][col], grid[row + 1][col]);\r\n            }\r\n            if ((col - 1) >= 0) {\r\n                graph.addEdge(grid[row][col], grid[row][col - 1]);\r\n            }\r\n            if ((row - 1) >= 0) {\r\n                graph.addEdge(grid[row][col], grid[row - 1][col]);\r\n            }\r\n\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n\r\nclass Graph {\r\n    constructor(noOfVertices) {\r\n        this.noOfVertices = noOfVertices;\r\n        this.AdjList = new Map();\r\n    }\r\n    addVertex(v) {\r\n        this.AdjList.set(v, []);\r\n    }\r\n    addEdge(v, w) {\r\n        this.AdjList.get(v).push(w);\r\n    }\r\n    getAdjacents(node) {\r\n        return this.AdjList.get(node);\r\n    }\r\n\r\n    isAdjacent(node, neighbor) {\r\n        var temp = 0;\r\n        this.AdjList.get(node).forEach(adj => {\r\n            if (adj === neighbor) {\r\n                temp++;\r\n            }\r\n        })\r\n        if (temp == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\nfunction sortnodebydistance(unvisitednodes) {\r\n    unvisitednodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList, node, graph) {\r\n    for (const neighbor of visitList) {\r\n        if ((neighbor.previousNode !== null && neighbor.distance <= node.distance) || !graph.isAdjacent(node, neighbor)) {\r\n            continue;\r\n        } else if (graph.isAdjacent(node, neighbor)) {\r\n            neighbor.distance = node.distance + neighbor.weight + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderDijkstra(finishNode, startNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        // console.log(currentNode.row);\r\n        // console.log(currentNode.col);\r\n        currentNode = currentNode.previousNode;\r\n        if (currentNode === startNode) {\r\n            // console.log(currentNode.row);\r\n            // console.log(currentNode.col);\r\n            break;\r\n        }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","/home/sourabh/Downloads/react/tmp/Visualization/src/algorithms/DFS.js",["177","178"],"export default function DFS(grid, startNode, finishNode) {\n    if (startNode == finishNode || !startNode || !finishNode) {\n        return false;\n    }\n    console.log(\"in DFS\");\n    var count = 0;\n    startNode.distance = 0;\n    const visited = new Map();\n    const visitedinorder = [];\n    const visitList = [];\n    visitList.push(startNode)\n    const graph = creategraph(grid);\n    while (visitList.length !== 0) {\n        const node = visitList.pop();\n        if (node && !visited.has(node)) {\n            if (node.isWall) continue;\n            visitedinorder.push(node);\n            count++;\n            visited.set(node);\n            // console.log(\"visited\");\n            // console.log(node.row);\n            // console.log(node.col);\n            if (node === finishNode) {\n                console.log(\"count\", count);\n                return visitedinorder;\n            }\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\n            updateUnvisitedNeighbors(visitList, node, graph, visited);\n        }\n    }\n    return visitedinorder;\n\n}\n\n\n\nfunction creategraph(grid) {\n    const graph = new Graph(1000);\n    for (let row = 0; row < 20; row++) {\n        for (let col = 0; col < 50; col++) {\n            graph.addVertex(grid[row][col]);\n        }\n    }\n    for (let row = 0; row < 20; row++) {\n        for (let col = 0; col < 50; col++) {\n            if ((row + 1) < 20) {\n                graph.addEdge(grid[row][col], grid[row + 1][col]);\n            }\n            if ((col - 1 >= 0)) {\n                graph.addEdge(grid[row][col], grid[row][col - 1]);\n            }\n            if ((col + 1 < 50)) {\n                graph.addEdge(grid[row][col], grid[row][col + 1]);\n            }\n            if ((row - 1) >= 0) {\n                graph.addEdge(grid[row][col], grid[row - 1][col]);\n            }\n        }\n    }\n    return graph;\n}\n\n\nclass Graph {\n    constructor(noOfVertices) {\n        this.noOfVertices = noOfVertices;\n        this.Adjlist = new Map();\n    }\n\n    addVertex(v) {\n        this.Adjlist.set(v, []);\n    }\n\n    addEdge(v, w) {\n        this.Adjlist.get(v).push(w);\n    }\n\n    getAdjacents(node) {\n        return this.Adjlist.get(node);\n    }\n\n    isAdjacent(node, neighbor) {\n        var temp = 0;\n        this.Adjlist.get(neighbor).forEach(x => {\n            if (x == node) {\n                temp++;\n            }\n        })\n        if (temp === 0) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n\nfunction updateUnvisitedNeighbors(visitList, node, graph, visited) {\n    // console.log(\"neigbour\");\n    for (const neighbor of visitList) {\n        if (graph.isAdjacent(node, neighbor) && !visited.has(neighbor)) {\n            neighbor.distance = node.distance + neighbor.weight + 1;\n            neighbor.previousNode = node;\n        }\n    }\n}\n\nexport function getNodesInShortestPathOrderDFS(finishNode, startNode) {\n    // console.log(\"shortest Path\");\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        //   console.log(currentNode);\n        currentNode = currentNode.previousNode;\n        if (currentNode === startNode) {\n            //   console.log(currentNode.row);\n            //   console.log(currentNode.col);\n            break;\n        }\n    }\n    return nodesInShortestPathOrder;\n}\n","/home/sourabh/Downloads/react/tmp/Visualization/src/algorithms/Astar.js",["179","180"],"export default function AStar(grid, startnode, endnode) {\n  startnode.distance = 0;\n  const visited = new Map();\n  const visitedinorder = [];\n  const visitList = [];\n  visitList.push(startnode);\n  const graph = creategraph(grid);\n  while (visitList.length !== 0) {\n    const node = visitList.shift();\n    if (node && !visited.has(node)) {\n      if (node.isWall) continue;\n      visitedinorder.push(node);\n      visited.set(node);\n      // console.log(node.row);\n      // console.log(node.col);\n      if (node == endnode) {\n        return visitedinorder;\n      }\n      graph.getAdjacents(node).forEach(adj => visitList.push(adj));\n      updateUnvisitedNeighbors(visitList, node, graph);\n      sortnodebydistance(visitList, endnode);\n    }\n  }\n  return visitedinorder;\n}\n\nfunction creategraph(grid) {\n  const graph = new Graph(1000);\n  for (let row = 0; row < 20; row++) {\n    for (let col = 0; col < 50; col++) {\n      graph.addVertex(grid[row][col]);\n    }\n  }\n  for (let row = 0; row < 20; row++) {\n    for (let col = 0; col < 50; col++) {\n      if ((col + 1 < 50)) {\n        graph.addEdge(grid[row][col], grid[row][col + 1]);\n      }\n      if ((row + 1) < 20) {\n        graph.addEdge(grid[row][col], grid[row + 1][col]);\n      }\n      if ((col - 1) >= 0) {\n        graph.addEdge(grid[row][col], grid[row][col - 1]);\n      }\n      if ((row - 1) >= 0) {\n        graph.addEdge(grid[row][col], grid[row - 1][col]);\n      }\n\n    }\n  }\n  return graph;\n}\n\nclass Graph {\n  constructor(noOfVertices) {\n    this.noOfVertices = noOfVertices;\n    this.AdjList = new Map();\n  }\n  addVertex(v) {\n    this.AdjList.set(v, []);\n  }\n  addEdge(v, w) {\n    this.AdjList.get(v).push(w);\n  }\n  getAdjacents(node) {\n    return this.AdjList.get(node);\n  }\n\n  isAdjacent(node, neighbor) {\n    var temp = 0;\n    this.AdjList.get(node).forEach(adj => {\n      if (adj === neighbor) {\n        temp++;\n      }\n    })\n    if (temp == 0) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nfunction sortnodebydistance(unvisitednodes, finishNode) {\n  unvisitednodes.sort((nodeA, nodeB) => (nodeA.distance + manhattendistance(nodeA, finishNode)) - (nodeB.distance + manhattendistance(nodeB, finishNode)));\n}\n\nfunction updateUnvisitedNeighbors(visitList, node, graph) {\n  for (const neighbor of visitList) {\n    if ((neighbor.previousNode !== null && neighbor.distance <= node.distance) || !graph.isAdjacent(node, neighbor)) {\n      continue;\n    } else if (graph.isAdjacent(node, neighbor)) {\n      neighbor.distance = node.distance + neighbor.weight + 1;\n      neighbor.previousNode = node;\n    }\n  }\n}\n\nexport function getNodesInShortestPathOrderAStar(finishNode, startNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    //   console.log(currentNode.row);\n    //   console.log(currentNode.col);\n    currentNode = currentNode.previousNode;\n    if (currentNode === startNode) {\n      //   console.log(currentNode.row);\n      //   console.log(currentNode.col);\n      break;\n    }\n  }\n  return nodesInShortestPathOrder;\n}\n\nfunction manhattendistance(node, finishnode) {\n  var hn = (Math.abs(node.row - finishnode.row) + Math.abs(node.col - finishnode.col));\n  return hn;\n}\n","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/chanceMazeV.js",["181","182","183","184","185","186","187","188","189","190","191","192","193","194","195","196","197"],"function recure(grid, rowStart, rowEnd, colStart, colEnd, grid1, startNode, finishNode) {\n  if (rowEnd >= (grid.length) - 1 || colEnd >= grid.length[0] - 1 || rowStart < 0 || colStart < 0) {\n    return;\n  }\n  var x = colStart;\n  var y = colEnd;\n  for (var m = colStart; m < colEnd; m += 3) {\n    let possibleRows = [];\n    for (let number = rowStart; number <= rowEnd; number += 1) {\n      possibleRows.push(number);\n    }\n    let possibleCols = []\n    for (let number = colStart; number <= colEnd; number += 1) {\n      possibleCols.push(number);\n    }\n    while (possibleCols.length != 1 && possibleRows.length != 1) {\n      var randomRowIndex1 = Math.ceil(Math.random() * possibleRows.length);\n      var randomRowIndex2 = Math.ceil(Math.random() * possibleRows.length);\n      var randomColIndex = Math.ceil(Math.random() * possibleCols.length);\n      let currentRow1 = possibleRows[randomRowIndex1];\n      let currentRow2 = possibleRows[randomRowIndex2];\n      let colRandom = possibleCols[randomColIndex];\n      if (currentRow1 == undefined || colRandom == undefined || currentRow2 == undefined) {\n        possibleRows.splice(randomRowIndex1, 1);\n        possibleCols.splice(randomColIndex, 1);\n        continue\n      }\n      else {\n        for (let k = currentRow1; k < currentRow2; k += 2) {\n          var ans = 0;\n          for (let j = 0; j < grid1.length; j++) {\n            if (grid[k][colRandom] == grid1[j]) {\n              ans = 1;\n            }\n          }\n          if (ans == 0) {\n            if (grid[k][colRandom] != startNode && grid[k][colRandom] != finishNode) {\n              grid1.push(grid[k][colRandom]);\n            }\n          }\n        }\n      }\n      possibleRows.splice(randomRowIndex1, 1);\n      possibleCols.splice(randomColIndex, 1);\n    }\n  }\n  return grid1;\n}\n\nfunction chanceMazeV(grid, rowStart, rowEnd, colStart, colEnd, startNode, finishNode) {\n  let grid1 = [];\n  for (let i = 0; i < 20; i++) {\n    for (let j = 0; j < 50; j++) {\n      if (i == 0 || i == grid.length - 1 || j == 0 || j == grid[0].length - 1) {\n        if (grid[i][j] == startNode || grid[i][j] == finishNode) {\n          continue;\n        }\n        else {\n          grid1.push(grid[i][j]);\n        }\n      }\n    }\n  }\n  rowStart = 1;\n  rowEnd = grid.length - 2;\n  colStart = 1;\n  colEnd = grid[0].length - 2;\n  var x = recure(grid, rowStart, rowEnd, colStart, colEnd, grid1, startNode, finishNode);\n  return x;\n}\n\nexport default chanceMazeV;","/home/sourabh/Downloads/react/tmp/Visualization/src/mazeAlgorithms/chanceMazeH.js",["198","199","200","201","202","203","204","205","206","207","208","209","210","211","212","213","214"],"function recure(grid, rowStart, rowEnd, colStart, colEnd, grid1, startNode, finishNode) {\n  if (rowEnd >= (grid.length) - 1 || colEnd >= grid.length[0] - 1 || rowStart < 0 || colStart < 0) {\n    return;\n  }\n  var x = colStart;\n  var y = colEnd;\n  for (var m = colStart; m < colEnd; m += 6) {\n    let possibleRows = [];\n    for (let number = rowStart; number <= rowEnd; number += 1) {\n      possibleRows.push(number);\n    }\n    let possibleCols = []\n    for (let number = colStart; number <= colEnd; number += 1) {\n      possibleCols.push(number);\n    }\n    while (possibleCols.length != 1 && possibleRows.length != 1) {\n      var randomRowIndex = Math.ceil(Math.random() * possibleRows.length);\n      var randomColIndex1 = Math.ceil(Math.random() * possibleCols.length);\n      var randomColIndex2 = Math.ceil(Math.random() * possibleCols.length);\n      let currentRow = possibleRows[randomRowIndex];\n      let colRandom1 = possibleCols[randomColIndex1];\n      let colRandom2 = possibleCols[randomColIndex2];\n      if (currentRow == undefined || colRandom1 == undefined || colRandom2 == undefined) {\n        possibleRows.splice(randomRowIndex, 1);\n        possibleCols.splice(randomColIndex1, 1);\n        continue\n      }\n      else {\n        for (let k = colRandom1; k < colRandom2; k += 2) {\n          var ans = 0;\n          for (let j = 0; j < grid1.length; j += 1) {\n            if (grid[currentRow][k] == grid1[j]) {\n              ans = 1;\n            }\n          }\n          if (ans == 0) {\n            if (grid[currentRow][k] != startNode && grid[currentRow][k] != finishNode) {\n              grid1.push(grid[currentRow][k]);\n            }\n          }\n        }\n      }\n      possibleRows.splice(randomRowIndex, 1);\n      possibleCols.splice(randomColIndex1, 1);\n    }\n  }\n  return grid1;\n}\n\nfunction chanceMazeH(grid, rowStart, rowEnd, colStart, colEnd, startNode, finishNode) {\n  let grid1 = [];\n  for (let i = 0; i < 20; i++) {\n    for (let j = 0; j < 50; j++) {\n      if (i == 0 || i == grid.length - 1 || j == 0 || j == grid[0].length - 1) {\n        if (grid[i][j] == startNode || grid[i][j] == finishNode) {\n          continue;\n        }\n        else {\n          grid1.push(grid[i][j]);\n        }\n      }\n    }\n  }\n  rowStart = 1;\n  rowEnd = grid.length - 2;\n  colStart = 1;\n  colEnd = grid[0].length - 2;\n  var x = recure(grid, rowStart, rowEnd, colStart, colEnd, grid1, startNode, finishNode);\n  return x;\n}\n\nexport default chanceMazeH;","/home/sourabh/Downloads/react/tmp/Visualization/src/models/Node/Node.jsx",["215"],"import React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n      weight = 0,\n    } = this.props;\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : weight != 0\n      ? 'node-weight'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}\n",["216","217"],{"ruleId":"218","replacedBy":"219"},{"ruleId":"220","replacedBy":"221"},{"ruleId":"222","severity":1,"message":"223","line":2,"column":10,"nodeType":"224","messageId":"225","endLine":2,"endColumn":18},{"ruleId":"222","severity":1,"message":"226","line":35,"column":10,"nodeType":"224","messageId":"225","endLine":35,"endColumn":18},{"ruleId":"222","severity":1,"message":"227","line":36,"column":10,"nodeType":"224","messageId":"225","endLine":36,"endColumn":18},{"ruleId":"228","severity":1,"message":"229","line":118,"column":13,"nodeType":"230","messageId":"231","endLine":118,"endColumn":15},{"ruleId":"228","severity":1,"message":"229","line":118,"column":38,"nodeType":"230","messageId":"231","endLine":118,"endColumn":40},{"ruleId":"228","severity":1,"message":"229","line":122,"column":20,"nodeType":"230","messageId":"231","endLine":122,"endColumn":22},{"ruleId":"228","severity":1,"message":"229","line":122,"column":46,"nodeType":"230","messageId":"231","endLine":122,"endColumn":48},{"ruleId":"228","severity":1,"message":"229","line":138,"column":23,"nodeType":"230","messageId":"231","endLine":138,"endColumn":25},{"ruleId":"228","severity":1,"message":"229","line":138,"column":48,"nodeType":"230","messageId":"231","endLine":138,"endColumn":50},{"ruleId":"228","severity":1,"message":"229","line":138,"column":75,"nodeType":"230","messageId":"231","endLine":138,"endColumn":77},{"ruleId":"228","severity":1,"message":"229","line":138,"column":101,"nodeType":"230","messageId":"231","endLine":138,"endColumn":103},{"ruleId":"232","severity":1,"message":"233","line":158,"column":18,"nodeType":"234","messageId":"235","endLine":164,"endColumn":8},{"ruleId":"232","severity":1,"message":"233","line":170,"column":18,"nodeType":"234","messageId":"235","endLine":180,"endColumn":8},{"ruleId":"228","severity":1,"message":"229","line":245,"column":19,"nodeType":"230","messageId":"231","endLine":245,"endColumn":21},{"ruleId":"228","severity":1,"message":"229","line":252,"column":24,"nodeType":"230","messageId":"231","endLine":252,"endColumn":26},{"ruleId":"236","severity":1,"message":"237","line":255,"column":11,"nodeType":"224","messageId":"238","endLine":255,"endColumn":17},{"ruleId":"228","severity":1,"message":"229","line":259,"column":24,"nodeType":"230","messageId":"231","endLine":259,"endColumn":26},{"ruleId":"236","severity":1,"message":"237","line":262,"column":11,"nodeType":"224","messageId":"238","endLine":262,"endColumn":17},{"ruleId":"228","severity":1,"message":"229","line":265,"column":26,"nodeType":"230","messageId":"231","endLine":265,"endColumn":28},{"ruleId":"236","severity":1,"message":"237","line":272,"column":11,"nodeType":"224","messageId":"238","endLine":272,"endColumn":17},{"ruleId":"228","severity":1,"message":"229","line":298,"column":23,"nodeType":"230","messageId":"231","endLine":298,"endColumn":25},{"ruleId":"228","severity":1,"message":"229","line":307,"column":28,"nodeType":"230","messageId":"231","endLine":307,"endColumn":30},{"ruleId":"236","severity":1,"message":"239","line":308,"column":11,"nodeType":"224","messageId":"238","endLine":308,"endColumn":18},{"ruleId":"236","severity":1,"message":"240","line":309,"column":16,"nodeType":"224","messageId":"238","endLine":309,"endColumn":17},{"ruleId":"228","severity":1,"message":"229","line":316,"column":28,"nodeType":"230","messageId":"231","endLine":316,"endColumn":30},{"ruleId":"236","severity":1,"message":"239","line":319,"column":11,"nodeType":"224","messageId":"238","endLine":319,"endColumn":18},{"ruleId":"236","severity":1,"message":"240","line":320,"column":16,"nodeType":"224","messageId":"238","endLine":320,"endColumn":17},{"ruleId":"228","severity":1,"message":"229","line":327,"column":28,"nodeType":"230","messageId":"231","endLine":327,"endColumn":30},{"ruleId":"236","severity":1,"message":"239","line":328,"column":11,"nodeType":"224","messageId":"238","endLine":328,"endColumn":18},{"ruleId":"236","severity":1,"message":"240","line":329,"column":16,"nodeType":"224","messageId":"238","endLine":329,"endColumn":17},{"ruleId":"228","severity":1,"message":"229","line":336,"column":28,"nodeType":"230","messageId":"231","endLine":336,"endColumn":30},{"ruleId":"236","severity":1,"message":"239","line":337,"column":11,"nodeType":"224","messageId":"238","endLine":337,"endColumn":18},{"ruleId":"228","severity":1,"message":"229","line":340,"column":17,"nodeType":"230","messageId":"231","endLine":340,"endColumn":19},{"ruleId":"228","severity":1,"message":"229","line":340,"column":27,"nodeType":"230","messageId":"231","endLine":340,"endColumn":29},{"ruleId":"228","severity":1,"message":"229","line":340,"column":38,"nodeType":"230","messageId":"231","endLine":340,"endColumn":40},{"ruleId":"228","severity":1,"message":"229","line":340,"column":48,"nodeType":"230","messageId":"231","endLine":340,"endColumn":50},{"ruleId":"228","severity":1,"message":"241","line":348,"column":97,"nodeType":"230","messageId":"231","endLine":348,"endColumn":99},{"ruleId":"228","severity":1,"message":"229","line":354,"column":30,"nodeType":"230","messageId":"231","endLine":354,"endColumn":32},{"ruleId":"236","severity":1,"message":"239","line":355,"column":11,"nodeType":"224","messageId":"238","endLine":355,"endColumn":18},{"ruleId":"236","severity":1,"message":"240","line":356,"column":16,"nodeType":"224","messageId":"238","endLine":356,"endColumn":17},{"ruleId":"228","severity":1,"message":"229","line":362,"column":28,"nodeType":"230","messageId":"231","endLine":362,"endColumn":30},{"ruleId":"236","severity":1,"message":"239","line":363,"column":11,"nodeType":"224","messageId":"238","endLine":363,"endColumn":18},{"ruleId":"236","severity":1,"message":"240","line":364,"column":16,"nodeType":"224","messageId":"238","endLine":364,"endColumn":17},{"ruleId":"228","severity":1,"message":"229","line":371,"column":28,"nodeType":"230","messageId":"231","endLine":371,"endColumn":30},{"ruleId":"236","severity":1,"message":"239","line":372,"column":11,"nodeType":"224","messageId":"238","endLine":372,"endColumn":18},{"ruleId":"236","severity":1,"message":"240","line":373,"column":16,"nodeType":"224","messageId":"238","endLine":373,"endColumn":17},{"ruleId":"228","severity":1,"message":"229","line":380,"column":28,"nodeType":"230","messageId":"231","endLine":380,"endColumn":30},{"ruleId":"236","severity":1,"message":"239","line":381,"column":11,"nodeType":"224","messageId":"238","endLine":381,"endColumn":18},{"ruleId":"236","severity":1,"message":"240","line":382,"column":16,"nodeType":"224","messageId":"238","endLine":382,"endColumn":17},{"ruleId":"228","severity":1,"message":"229","line":395,"column":23,"nodeType":"230","messageId":"231","endLine":395,"endColumn":25},{"ruleId":"242","severity":1,"message":"243","line":492,"column":6,"nodeType":"244","endLine":492,"endColumn":21,"suggestions":"245"},{"ruleId":"228","severity":1,"message":"229","line":548,"column":73,"nodeType":"230","messageId":"231","endLine":548,"endColumn":75},{"ruleId":"228","severity":1,"message":"241","line":617,"column":28,"nodeType":"230","messageId":"231","endLine":617,"endColumn":30},{"ruleId":"228","severity":1,"message":"229","line":695,"column":25,"nodeType":"230","messageId":"231","endLine":695,"endColumn":27},{"ruleId":"228","severity":1,"message":"229","line":8,"column":24,"nodeType":"230","messageId":"231","endLine":8,"endColumn":26},{"ruleId":"228","severity":1,"message":"229","line":8,"column":48,"nodeType":"230","messageId":"231","endLine":8,"endColumn":50},{"ruleId":"228","severity":1,"message":"229","line":11,"column":29,"nodeType":"230","messageId":"231","endLine":11,"endColumn":31},{"ruleId":"228","severity":1,"message":"229","line":11,"column":54,"nodeType":"230","messageId":"231","endLine":11,"endColumn":56},{"ruleId":"228","severity":1,"message":"229","line":6,"column":20,"nodeType":"230","messageId":"231","endLine":6,"endColumn":22},{"ruleId":"228","severity":1,"message":"229","line":6,"column":47,"nodeType":"230","messageId":"231","endLine":6,"endColumn":49},{"ruleId":"228","severity":1,"message":"229","line":18,"column":20,"nodeType":"230","messageId":"231","endLine":18,"endColumn":22},{"ruleId":"228","severity":1,"message":"229","line":18,"column":47,"nodeType":"230","messageId":"231","endLine":18,"endColumn":49},{"ruleId":"228","severity":1,"message":"229","line":28,"column":24,"nodeType":"230","messageId":"231","endLine":28,"endColumn":26},{"ruleId":"228","severity":1,"message":"229","line":28,"column":48,"nodeType":"230","messageId":"231","endLine":28,"endColumn":50},{"ruleId":"228","severity":1,"message":"229","line":31,"column":29,"nodeType":"230","messageId":"231","endLine":31,"endColumn":31},{"ruleId":"228","severity":1,"message":"229","line":31,"column":54,"nodeType":"230","messageId":"231","endLine":31,"endColumn":56},{"ruleId":"228","severity":1,"message":"229","line":37,"column":39,"nodeType":"230","messageId":"231","endLine":37,"endColumn":41},{"ruleId":"228","severity":1,"message":"229","line":41,"column":31,"nodeType":"230","messageId":"231","endLine":41,"endColumn":33},{"ruleId":"228","severity":1,"message":"229","line":12,"column":28,"nodeType":"230","messageId":"231","endLine":12,"endColumn":30},{"ruleId":"228","severity":1,"message":"229","line":12,"column":55,"nodeType":"230","messageId":"231","endLine":12,"endColumn":57},{"ruleId":"228","severity":1,"message":"229","line":16,"column":32,"nodeType":"230","messageId":"231","endLine":16,"endColumn":34},{"ruleId":"228","severity":1,"message":"229","line":16,"column":59,"nodeType":"230","messageId":"231","endLine":16,"endColumn":61},{"ruleId":"228","severity":1,"message":"229","line":22,"column":40,"nodeType":"230","messageId":"231","endLine":22,"endColumn":42},{"ruleId":"228","severity":1,"message":"229","line":26,"column":31,"nodeType":"230","messageId":"231","endLine":26,"endColumn":33},{"ruleId":"236","severity":1,"message":"240","line":33,"column":14,"nodeType":"224","messageId":"238","endLine":33,"endColumn":15},{"ruleId":"236","severity":1,"message":"246","line":34,"column":18,"nodeType":"224","messageId":"238","endLine":34,"endColumn":19},{"ruleId":"228","severity":1,"message":"229","line":35,"column":28,"nodeType":"230","messageId":"231","endLine":35,"endColumn":30},{"ruleId":"228","severity":1,"message":"229","line":35,"column":55,"nodeType":"230","messageId":"231","endLine":35,"endColumn":57},{"ruleId":"236","severity":1,"message":"240","line":43,"column":14,"nodeType":"224","messageId":"238","endLine":43,"endColumn":15},{"ruleId":"236","severity":1,"message":"246","line":44,"column":18,"nodeType":"224","messageId":"238","endLine":44,"endColumn":19},{"ruleId":"228","severity":1,"message":"229","line":45,"column":28,"nodeType":"230","messageId":"231","endLine":45,"endColumn":30},{"ruleId":"228","severity":1,"message":"229","line":45,"column":55,"nodeType":"230","messageId":"231","endLine":45,"endColumn":57},{"ruleId":"228","severity":1,"message":"229","line":2,"column":19,"nodeType":"230","messageId":"231","endLine":2,"endColumn":21},{"ruleId":"222","severity":1,"message":"247","line":18,"column":13,"nodeType":"224","messageId":"225","endLine":18,"endColumn":18},{"ruleId":"228","severity":1,"message":"229","line":85,"column":19,"nodeType":"230","messageId":"231","endLine":85,"endColumn":21},{"ruleId":"228","severity":1,"message":"229","line":16,"column":22,"nodeType":"230","messageId":"231","endLine":16,"endColumn":24},{"ruleId":"228","severity":1,"message":"229","line":76,"column":18,"nodeType":"230","messageId":"231","endLine":76,"endColumn":20},{"ruleId":"228","severity":1,"message":"229","line":2,"column":19,"nodeType":"230","messageId":"231","endLine":2,"endColumn":21},{"ruleId":"228","severity":1,"message":"229","line":85,"column":19,"nodeType":"230","messageId":"231","endLine":85,"endColumn":21},{"ruleId":"228","severity":1,"message":"229","line":16,"column":16,"nodeType":"230","messageId":"231","endLine":16,"endColumn":18},{"ruleId":"228","severity":1,"message":"229","line":76,"column":14,"nodeType":"230","messageId":"231","endLine":76,"endColumn":16},{"ruleId":"222","severity":1,"message":"248","line":5,"column":7,"nodeType":"224","messageId":"225","endLine":5,"endColumn":8},{"ruleId":"222","severity":1,"message":"249","line":6,"column":7,"nodeType":"224","messageId":"225","endLine":6,"endColumn":8},{"ruleId":"228","severity":1,"message":"241","line":16,"column":32,"nodeType":"230","messageId":"231","endLine":16,"endColumn":34},{"ruleId":"228","severity":1,"message":"241","line":16,"column":60,"nodeType":"230","messageId":"231","endLine":16,"endColumn":62},{"ruleId":"228","severity":1,"message":"229","line":23,"column":23,"nodeType":"230","messageId":"231","endLine":23,"endColumn":25},{"ruleId":"228","severity":1,"message":"229","line":23,"column":49,"nodeType":"230","messageId":"231","endLine":23,"endColumn":51},{"ruleId":"228","severity":1,"message":"229","line":23,"column":77,"nodeType":"230","messageId":"231","endLine":23,"endColumn":79},{"ruleId":"228","severity":1,"message":"229","line":32,"column":36,"nodeType":"230","messageId":"231","endLine":32,"endColumn":38},{"ruleId":"228","severity":1,"message":"229","line":36,"column":19,"nodeType":"230","messageId":"231","endLine":36,"endColumn":21},{"ruleId":"228","severity":1,"message":"241","line":37,"column":36,"nodeType":"230","messageId":"231","endLine":37,"endColumn":38},{"ruleId":"228","severity":1,"message":"241","line":37,"column":71,"nodeType":"230","messageId":"231","endLine":37,"endColumn":73},{"ruleId":"228","severity":1,"message":"229","line":54,"column":13,"nodeType":"230","messageId":"231","endLine":54,"endColumn":15},{"ruleId":"228","severity":1,"message":"229","line":54,"column":23,"nodeType":"230","messageId":"231","endLine":54,"endColumn":25},{"ruleId":"228","severity":1,"message":"229","line":54,"column":47,"nodeType":"230","messageId":"231","endLine":54,"endColumn":49},{"ruleId":"228","severity":1,"message":"229","line":54,"column":57,"nodeType":"230","messageId":"231","endLine":54,"endColumn":59},{"ruleId":"228","severity":1,"message":"229","line":55,"column":24,"nodeType":"230","messageId":"231","endLine":55,"endColumn":26},{"ruleId":"228","severity":1,"message":"229","line":55,"column":51,"nodeType":"230","messageId":"231","endLine":55,"endColumn":53},{"ruleId":"222","severity":1,"message":"248","line":5,"column":7,"nodeType":"224","messageId":"225","endLine":5,"endColumn":8},{"ruleId":"222","severity":1,"message":"249","line":6,"column":7,"nodeType":"224","messageId":"225","endLine":6,"endColumn":8},{"ruleId":"228","severity":1,"message":"241","line":16,"column":32,"nodeType":"230","messageId":"231","endLine":16,"endColumn":34},{"ruleId":"228","severity":1,"message":"241","line":16,"column":60,"nodeType":"230","messageId":"231","endLine":16,"endColumn":62},{"ruleId":"228","severity":1,"message":"229","line":23,"column":22,"nodeType":"230","messageId":"231","endLine":23,"endColumn":24},{"ruleId":"228","severity":1,"message":"229","line":23,"column":49,"nodeType":"230","messageId":"231","endLine":23,"endColumn":51},{"ruleId":"228","severity":1,"message":"229","line":23,"column":76,"nodeType":"230","messageId":"231","endLine":23,"endColumn":78},{"ruleId":"228","severity":1,"message":"229","line":32,"column":37,"nodeType":"230","messageId":"231","endLine":32,"endColumn":39},{"ruleId":"228","severity":1,"message":"229","line":36,"column":19,"nodeType":"230","messageId":"231","endLine":36,"endColumn":21},{"ruleId":"228","severity":1,"message":"241","line":37,"column":37,"nodeType":"230","messageId":"231","endLine":37,"endColumn":39},{"ruleId":"228","severity":1,"message":"241","line":37,"column":73,"nodeType":"230","messageId":"231","endLine":37,"endColumn":75},{"ruleId":"228","severity":1,"message":"229","line":54,"column":13,"nodeType":"230","messageId":"231","endLine":54,"endColumn":15},{"ruleId":"228","severity":1,"message":"229","line":54,"column":23,"nodeType":"230","messageId":"231","endLine":54,"endColumn":25},{"ruleId":"228","severity":1,"message":"229","line":54,"column":47,"nodeType":"230","messageId":"231","endLine":54,"endColumn":49},{"ruleId":"228","severity":1,"message":"229","line":54,"column":57,"nodeType":"230","messageId":"231","endLine":54,"endColumn":59},{"ruleId":"228","severity":1,"message":"229","line":55,"column":24,"nodeType":"230","messageId":"231","endLine":55,"endColumn":26},{"ruleId":"228","severity":1,"message":"229","line":55,"column":51,"nodeType":"230","messageId":"231","endLine":55,"endColumn":53},{"ruleId":"228","severity":1,"message":"241","line":24,"column":16,"nodeType":"230","messageId":"231","endLine":24,"endColumn":18},{"ruleId":"218","replacedBy":"250"},{"ruleId":"220","replacedBy":"251"},"no-native-reassign",["252"],"no-negated-in-lhs",["253"],"no-unused-vars","'Carousel' is defined but never used.","Identifier","unusedVar","'isActive' is assigned a value but never used.","'isPaused' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'START_NODE_ROW', 'START_NODE_COL', 'FINISH_NODE_ROW', 'FINISH_NODE_COL'.","ArrowFunctionExpression","unsafeRefs","no-redeclare","'start2' is already defined.","redeclared","'griddef' is already defined.","'i' is already defined.","Expected '!==' and instead saw '!='.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'demoMazeAlgorithm'. Either include it or remove the dependency array.","ArrayExpression",["254"],"'j' is already defined.","'count' is assigned a value but never used.","'x' is assigned a value but never used.","'y' is assigned a value but never used.",["252"],["253"],"no-global-assign","no-unsafe-negation",{"desc":"255","fix":"256"},"Update the dependencies array to be: [demoMazeAlgorithm, mazeAlgorithm]",{"range":"257","text":"258"},[19174,19189],"[demoMazeAlgorithm, mazeAlgorithm]"]