[{"C:\\React Projects\\new\\Visualization\\src\\index.js":"1","C:\\React Projects\\new\\Visualization\\src\\App.js":"2","C:\\React Projects\\new\\Visualization\\src\\visualizers\\PathfindingVisualizer.jsx":"3","C:\\React Projects\\new\\Visualization\\src\\mazeAlgorithms\\Simplestair.js":"4","C:\\React Projects\\new\\Visualization\\src\\mazeAlgorithms\\basicWeighted.js":"5","C:\\React Projects\\new\\Visualization\\src\\mazeAlgorithms\\basicRandom.js":"6","C:\\React Projects\\new\\Visualization\\src\\algorithms\\dijkstra.js":"7","C:\\React Projects\\new\\Visualization\\src\\algorithms\\DFS.js":"8","C:\\React Projects\\new\\Visualization\\src\\algorithms\\BFS.js":"9","C:\\React Projects\\new\\Visualization\\src\\models\\Node\\Node.jsx":"10","C:\\React Projects\\new\\Visualization\\src\\algorithms\\Astar.js":"11"},{"size":174,"mtime":1617428000044,"results":"12","hashOfConfig":"13"},{"size":281,"mtime":1617428000036,"results":"14","hashOfConfig":"13"},{"size":15683,"mtime":1617944187232,"results":"15","hashOfConfig":"13"},{"size":592,"mtime":1617428000044,"results":"16","hashOfConfig":"13"},{"size":662,"mtime":1617428000044,"results":"17","hashOfConfig":"13"},{"size":1406,"mtime":1617428000044,"results":"18","hashOfConfig":"13"},{"size":3243,"mtime":1617428000036,"results":"19","hashOfConfig":"13"},{"size":3309,"mtime":1617948321954,"results":"20","hashOfConfig":"13"},{"size":3428,"mtime":1617428000036,"results":"21","hashOfConfig":"13"},{"size":780,"mtime":1617428000052,"results":"22","hashOfConfig":"13"},{"size":3732,"mtime":1617430366501,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"h3v5v8",{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"31","messages":"32","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"26"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"26"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"26"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"26"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"45","messages":"46","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"26"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"26"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"26"},"C:\\React Projects\\new\\Visualization\\src\\index.js",[],["54","55"],"C:\\React Projects\\new\\Visualization\\src\\App.js",[],"C:\\React Projects\\new\\Visualization\\src\\visualizers\\PathfindingVisualizer.jsx",["56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73"],"C:\\React Projects\\new\\Visualization\\src\\mazeAlgorithms\\Simplestair.js",["74","75","76","77"],"function Simplestair(grid,startNode, finishNode)\r\n{\r\nvar grid1=[];\r\n  let  x=grid.length;\r\n  let y=0;\r\n  while(x<2*(grid.length)-1 && y<grid.length-4){\r\n    if(grid[y][x]==startNode || grid[y][x]==finishNode){\r\n        continue;\r\n    }\r\n    else{\r\n        grid1.push(grid[y][x]);\r\n    }\r\n    x++;\r\n    y++;\r\n    };\r\n    x=grid.length-1;\r\n    y=0;\r\n  while(x>=0 && y<grid.length){\r\n    if(grid[y][x]==startNode || grid[y][x]==finishNode){\r\n        continue;\r\n    }\r\n    else{\r\n        grid1.push(grid[y][x]);\r\n    }\r\n    x--;\r\n    y++;\r\n  };\r\n  return grid1;\r\n}\r\n\r\nexport default Simplestair; ","C:\\React Projects\\new\\Visualization\\src\\mazeAlgorithms\\basicWeighted.js",["78","79","80","81"],"function basicWeighted(grid,startNode, finishNode){\r\n    var grid1=[]\r\n    for(var i=0 ; i<20;i+=3)\r\n    {\r\n         for (var j=0 ;j<50;j+=3)\r\n         {\r\n              var x=Math.floor((Math.random() * 10) + 1);\r\n              var col=Math.abs(i-x);\r\n              var row=Math.abs(j-x);\r\n              if(col==startNode.col && row==startNode.row)\r\n              {\r\n                   continue;\r\n              }\r\n              else if(col==finishNode.col && row==finishNode.row)\r\n              {\r\n                   continue;\r\n              }\r\n              grid1.push(grid[col][row]);\r\n         }\r\n    }\r\n    return grid1;\r\n}\r\n\r\n\r\nexport default basicWeighted;","C:\\React Projects\\new\\Visualization\\src\\mazeAlgorithms\\basicRandom.js",["82","83","84","85"],"function basicRandom(grid,startNode, finishNode){\r\n     var grid1=[]\r\n     // let cIdY=grid.length[0]-10;\r\n     // for(let c=0 ;c<10;c++)\r\n     // {\r\n     //      let cIdXone= Math.floor(grid.length/2)-c;\r\n     //      let cIdXtwo = Math.floor(grid.length/2)+c;\r\n     //      // let cIdone = cIdY-cIdXone;\r\n     //      // let cIdtwo = cIdY-cIdXtwo;\r\n     //      console.log(cIdXone);\r\n     //      console.log(cIdXtwo);\r\n     //      // console.log((cIdY,cIdtwo));\r\n     //      if(cIdy>=20 || CIdXone>=50 || cIdXtwo>=50){\r\n     //           continue;\r\n     //      }\r\n     //      else{\r\n     //           grid1.push(grid[cIdY][cIdXone]);\r\n     //           grid1.push(grid[cIdY][cIdXtwo]);\r\n     //      }\r\n     //      // console.log(cIdone);\r\n     //      // console.log(cIdtwo);\r\n     // }\r\n     for(var i=0 ; i<20;i+=3)\r\n     {\r\n          for (var j=0 ;j<50;j+=3)\r\n          {\r\n               var x=Math.floor((Math.random() * 10) + 1);\r\n               var col=Math.abs(i-x);\r\n               var row=Math.abs(j-x);\r\n               if(col==startNode.col && row==startNode.row)\r\n               {\r\n                    continue;\r\n               }\r\n               else if(col==finishNode.col && row==finishNode.row)\r\n               {\r\n                    continue;\r\n               }\r\n               grid1.push(grid[col][row]);\r\n          }\r\n     }\r\n     return grid1;\r\n}\r\n\r\n\r\nexport default basicRandom;","C:\\React Projects\\new\\Visualization\\src\\algorithms\\dijkstra.js",["86","87"],"export default function dijkstra(grid,startnode,endnode){\r\n  startnode.distance=0;\r\n  const visited = new Map();\r\n  const visitedinorder =[];\r\n  const visitList = [];\r\n  visitList.push(startnode);\r\n  const graph=creategraph(grid);\r\n  while(visitList.length !== 0) {\r\n      const node = visitList.shift();\r\n      if(node && !visited.has(node)) {\r\n          if (node.isWall) continue;\r\n          visitedinorder.push(node);\r\n          visited.set(node);\r\n          console.log(node.row);\r\n          console.log(node.col);\r\n          if(node==endnode){\r\n              return visitedinorder;\r\n          }\r\n          graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n          updateUnvisitedNeighbors(visitList,node,graph);\r\n          sortnodebydistance(visitList);\r\n      }\r\n  }\r\n  return visitedinorder;\r\n}\r\n\r\nfunction creategraph(grid){\r\n  const graph=new Graph(1000);\r\n  for (let row = 0; row < 20; row++) {\r\n      for (let col = 0; col < 50; col++) {\r\n        graph.addVertex(grid[row][col]);\r\n      }\r\n  }\r\n  for (let row = 0; row < 20; row++) {\r\n      for (let col = 0; col < 50; col++) {\r\n          if((col+1<50)){\r\n              graph.addEdge(grid[row][col],grid[row][col+1]);\r\n          }\r\n          if((row+1)<20){\r\n              graph.addEdge(grid[row][col],grid[row+1][col]);\r\n          }\r\n          if((col-1)>=0){\r\n              graph.addEdge(grid[row][col],grid[row][col-1]);\r\n          }\r\n          if((row-1)>=0){\r\n              graph.addEdge(grid[row][col],grid[row-1][col]);\r\n          }         \r\n             \r\n      }\r\n    }\r\n  return graph;\r\n}\r\n\r\nclass Graph { \r\n  constructor(noOfVertices) { \r\n      this.noOfVertices = noOfVertices; \r\n      this.AdjList = new Map(); \r\n  }\r\n  addVertex(v) { \r\n  this.AdjList.set(v, []); \r\n  } \r\n  addEdge(v, w) { \r\n  this.AdjList.get(v).push(w);\r\n  }\r\n  getAdjacents(node) {\r\n      return this.AdjList.get(node);\r\n  }\r\n  \r\n  isAdjacent(node,neighbor) {\r\n      var temp=0;\r\n      this.AdjList.get(node).forEach(adj => {\r\n          if(adj === neighbor){\r\n              temp++;\r\n          }\r\n      })\r\n      if(temp==0){\r\n          return false;\r\n      }else{\r\n          return true;\r\n      }\r\n  }\r\n} \r\n\r\nfunction sortnodebydistance(unvisitednodes){\r\n  unvisitednodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList,node,graph) {\r\n  for (const neighbor of visitList) {\r\n      if((neighbor.previousNode !== null && neighbor.distance <= node.distance)  || !graph.isAdjacent(node,neighbor) ){\r\n          continue;\r\n      }else if(graph.isAdjacent(node,neighbor)){\r\n          neighbor.distance = node.distance + neighbor.weight + 1;\r\n          neighbor.previousNode = node;\r\n      }\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderDijkstra(finishNode,startNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    console.log(currentNode.row);\r\n    console.log(currentNode.col);\r\n    currentNode = currentNode.previousNode;\r\n    if(currentNode===startNode){\r\n        console.log(currentNode.row);\r\n        console.log(currentNode.col);\r\n        break;\r\n    }\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","C:\\React Projects\\new\\Visualization\\src\\algorithms\\DFS.js",["88","89"],"C:\\React Projects\\new\\Visualization\\src\\algorithms\\BFS.js",["90","91"],"\r\nexport default function BFS(grid,startNode, finishNode){\r\n    if(startNode==finishNode || !startNode || !finishNode){\r\n        return false;\r\n    }\r\n    console.log(\"in BFS\");\r\n    var count=0;\r\n    startNode.distance=0;\r\n    const visited=new Map();\r\n    const visitedinorder=[];\r\n    const visitList=[];\r\n    visitList.push(startNode)\r\n    const graph=creategraph(grid);\r\n    while(visitList.length!==0)\r\n    {\r\n        const node =visitList.shift();\r\n        if(node && !visited.has(node))\r\n        {\r\n            if (node.isWall) continue;\r\n            visitedinorder.push(node);\r\n            count++;\r\n            visited.set(node);\r\n            console.log(\"visited\");\r\n            console.log(node.row);\r\n            console.log(node.col);\r\n            if(node===finishNode){\r\n                console.log(\"count\",count);\r\n                return visitedinorder;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList,node,graph);\r\n        }\r\n    }\r\n    return visitedinorder;\r\n\r\n}\r\n\r\n\r\n\r\nfunction creategraph(grid){\r\n    const graph=new Graph(1000);\r\n    for(let row=0;row<20;row++)\r\n    {\r\n        for(let col=0;col<50;col++)\r\n        {\r\n            graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for(let row=0;row<20;row++)\r\n    {\r\n        for(let col=0;col<50;col++)\r\n        {\r\n            if((col+1<50)){\r\n                graph.addEdge(grid[row][col],grid[row][col+1]);\r\n            }\r\n            if((col-1>=0)){\r\n                graph.addEdge(grid[row][col],grid[row][col-1]);\r\n            }\r\n            if((row-1)>=0){\r\n                graph.addEdge(grid[row][col],grid[row-1][col]);\r\n            }\r\n            if((row+1)<20){\r\n                graph.addEdge(grid[row][col],grid[row+1][col]);\r\n            }\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n\r\n\r\nclass Graph{\r\n  constructor(noOfVertices){\r\n      this.noOfVertices=noOfVertices;\r\n      this.Adjlist=new Map();\r\n  }  \r\n\r\n  addVertex(v){\r\n    this.Adjlist.set(v,[]);\r\n  }\r\n\r\n  addEdge(v,w){\r\n     this.Adjlist.get(v).push(w);\r\n  }\r\n\r\n  getAdjacents(node){\r\n      return this.Adjlist.get(node);\r\n  }\r\n\r\n  isAdjacent(node,neighbor) {\r\n    var temp=0;\r\n    this.Adjlist.get(neighbor).forEach( x => {\r\n        if(x==node){\r\n            temp++;\r\n        }\r\n    })\r\n    if(temp===0){\r\n        return false;\r\n    }else{\r\n        return true;\r\n    }\r\n}\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList,node,graph) {\r\n    console.log(\"neigbour\");\r\n    for (const neighbor of visitList) {\r\n        if(!graph.isAdjacent(node,neighbor) || neighbor.previousNode !== null){\r\n            continue;\r\n        }else if(graph.isAdjacent(node,neighbor)){\r\n            neighbor.distance = node.distance + neighbor.weight + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n  }\r\n\r\nexport function getNodesInShortestPathOrderBFS(finishNode,startNode) {\r\n    console.log(\"shortest Path\");\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      console.log(currentNode.row);\r\n      console.log(currentNode.col);\r\n      currentNode = currentNode.previousNode;\r\n      if(currentNode===startNode){\r\n          console.log(currentNode.row);\r\n          console.log(currentNode.col);\r\n          break;\r\n      }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n","C:\\React Projects\\new\\Visualization\\src\\models\\Node\\Node.jsx",["92"],"import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n      weight = 0,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : weight != 0\r\n      ? 'node-weight'\r\n      : '';\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></div>\r\n    );\r\n  }\r\n}\r\n","C:\\React Projects\\new\\Visualization\\src\\algorithms\\Astar.js",["93","94"],"export default function AStar(grid,startnode,endnode){\r\n    startnode.distance=0;\r\n    const visited = new Map();\r\n    const visitedinorder =[];\r\n    const visitList = [];\r\n    visitList.push(startnode);\r\n    const graph=creategraph(grid);\r\n    while(visitList.length !== 0) {\r\n        const node = visitList.shift();\r\n        if(node && !visited.has(node)) {\r\n            if (node.isWall) continue;\r\n            visitedinorder.push(node);\r\n            visited.set(node);\r\n            console.log(node.row);\r\n            console.log(node.col);\r\n            if(node==endnode){\r\n                return visitedinorder;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList,node,graph);\r\n            sortnodebydistance(visitList,endnode);\r\n        }\r\n    }\r\n    return visitedinorder;\r\n  }\r\n  \r\n  function creategraph(grid){\r\n    const graph=new Graph(1000);\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n          graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            if((col+1<50)){\r\n                graph.addEdge(grid[row][col],grid[row][col+1]);\r\n            }\r\n            if((row+1)<20){\r\n                graph.addEdge(grid[row][col],grid[row+1][col]);\r\n            }\r\n            if((col-1)>=0){\r\n                graph.addEdge(grid[row][col],grid[row][col-1]);\r\n            }\r\n            if((row-1)>=0){\r\n                graph.addEdge(grid[row][col],grid[row-1][col]);\r\n            }         \r\n               \r\n        }\r\n      }\r\n    return graph;\r\n  }\r\n  \r\n  class Graph { \r\n    constructor(noOfVertices) { \r\n        this.noOfVertices = noOfVertices; \r\n        this.AdjList = new Map(); \r\n    }\r\n    addVertex(v) { \r\n    this.AdjList.set(v, []); \r\n    } \r\n    addEdge(v, w) { \r\n    this.AdjList.get(v).push(w);\r\n    }\r\n    getAdjacents(node) {\r\n        return this.AdjList.get(node);\r\n    }\r\n    \r\n    isAdjacent(node,neighbor) {\r\n        var temp=0;\r\n        this.AdjList.get(node).forEach(adj => {\r\n            if(adj === neighbor){\r\n                temp++;\r\n            }\r\n        })\r\n        if(temp==0){\r\n            return false;\r\n        }else{\r\n            return true;\r\n        }\r\n    }\r\n  } \r\n  \r\n  function sortnodebydistance(unvisitednodes,finishNode){\r\n    unvisitednodes.sort((nodeA, nodeB) => (nodeA.distance + manhattendistance(nodeA,finishNode)) - (nodeB.distance + manhattendistance(nodeB,finishNode)));\r\n  }\r\n  \r\n  function updateUnvisitedNeighbors(visitList,node,graph) {\r\n    for (const neighbor of visitList) {\r\n        if((neighbor.previousNode !== null && neighbor.distance <= node.distance)  || !graph.isAdjacent(node,neighbor) ){\r\n            continue;\r\n        }else if(graph.isAdjacent(node,neighbor)){\r\n            neighbor.distance = node.distance + neighbor.weight + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n  }\r\n  \r\n  export function getNodesInShortestPathOrderAStar(finishNode,startNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      console.log(currentNode.row);\r\n      console.log(currentNode.col);\r\n      currentNode = currentNode.previousNode;\r\n      if(currentNode===startNode){\r\n          console.log(currentNode.row);\r\n          console.log(currentNode.col);\r\n          break;\r\n      }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  function manhattendistance(node,finishnode){\r\n        var hn= (Math.abs(node.row - finishnode.row) +Math.abs(node.col - finishnode.col));\r\n        return hn;\r\n  }\r\n  ",{"ruleId":"95","replacedBy":"96"},{"ruleId":"97","replacedBy":"98"},{"ruleId":"99","severity":1,"message":"100","line":25,"column":10,"nodeType":"101","messageId":"102","endLine":25,"endColumn":18},{"ruleId":"99","severity":1,"message":"103","line":26,"column":10,"nodeType":"101","messageId":"102","endLine":26,"endColumn":18},{"ruleId":"104","severity":1,"message":"105","line":128,"column":18,"nodeType":"106","messageId":"107","endLine":134,"endColumn":8},{"ruleId":"104","severity":1,"message":"105","line":140,"column":18,"nodeType":"106","messageId":"107","endLine":150,"endColumn":8},{"ruleId":"108","severity":1,"message":"109","line":160,"column":18,"nodeType":"110","messageId":"111","endLine":160,"endColumn":20},{"ruleId":"108","severity":1,"message":"109","line":164,"column":23,"nodeType":"110","messageId":"111","endLine":164,"endColumn":25},{"ruleId":"108","severity":1,"message":"109","line":168,"column":23,"nodeType":"110","messageId":"111","endLine":168,"endColumn":25},{"ruleId":"108","severity":1,"message":"109","line":171,"column":24,"nodeType":"110","messageId":"111","endLine":171,"endColumn":26},{"ruleId":"108","severity":1,"message":"109","line":211,"column":21,"nodeType":"110","messageId":"111","endLine":211,"endColumn":23},{"ruleId":"108","severity":1,"message":"109","line":223,"column":26,"nodeType":"110","messageId":"111","endLine":223,"endColumn":28},{"ruleId":"112","severity":1,"message":"113","line":225,"column":13,"nodeType":"101","messageId":"114","endLine":225,"endColumn":20},{"ruleId":"112","severity":1,"message":"115","line":226,"column":17,"nodeType":"101","messageId":"114","endLine":226,"endColumn":18},{"ruleId":"108","severity":1,"message":"109","line":234,"column":26,"nodeType":"110","messageId":"111","endLine":234,"endColumn":28},{"ruleId":"112","severity":1,"message":"113","line":236,"column":13,"nodeType":"101","messageId":"114","endLine":236,"endColumn":20},{"ruleId":"112","severity":1,"message":"115","line":237,"column":17,"nodeType":"101","messageId":"114","endLine":237,"endColumn":18},{"ruleId":"116","severity":1,"message":"117","line":276,"column":5,"nodeType":"118","endLine":276,"endColumn":20,"suggestions":"119"},{"ruleId":"108","severity":1,"message":"109","line":317,"column":69,"nodeType":"110","messageId":"111","endLine":317,"endColumn":71},{"ruleId":"108","severity":1,"message":"109","line":425,"column":28,"nodeType":"110","messageId":"111","endLine":425,"endColumn":30},{"ruleId":"108","severity":1,"message":"109","line":7,"column":18,"nodeType":"110","messageId":"111","endLine":7,"endColumn":20},{"ruleId":"108","severity":1,"message":"109","line":7,"column":43,"nodeType":"110","messageId":"111","endLine":7,"endColumn":45},{"ruleId":"108","severity":1,"message":"109","line":19,"column":18,"nodeType":"110","messageId":"111","endLine":19,"endColumn":20},{"ruleId":"108","severity":1,"message":"109","line":19,"column":43,"nodeType":"110","messageId":"111","endLine":19,"endColumn":45},{"ruleId":"108","severity":1,"message":"109","line":10,"column":21,"nodeType":"110","messageId":"111","endLine":10,"endColumn":23},{"ruleId":"108","severity":1,"message":"109","line":10,"column":43,"nodeType":"110","messageId":"111","endLine":10,"endColumn":45},{"ruleId":"108","severity":1,"message":"109","line":14,"column":26,"nodeType":"110","messageId":"111","endLine":14,"endColumn":28},{"ruleId":"108","severity":1,"message":"109","line":14,"column":49,"nodeType":"110","messageId":"111","endLine":14,"endColumn":51},{"ruleId":"108","severity":1,"message":"109","line":30,"column":22,"nodeType":"110","messageId":"111","endLine":30,"endColumn":24},{"ruleId":"108","severity":1,"message":"109","line":30,"column":44,"nodeType":"110","messageId":"111","endLine":30,"endColumn":46},{"ruleId":"108","severity":1,"message":"109","line":34,"column":27,"nodeType":"110","messageId":"111","endLine":34,"endColumn":29},{"ruleId":"108","severity":1,"message":"109","line":34,"column":50,"nodeType":"110","messageId":"111","endLine":34,"endColumn":52},{"ruleId":"108","severity":1,"message":"109","line":16,"column":18,"nodeType":"110","messageId":"111","endLine":16,"endColumn":20},{"ruleId":"108","severity":1,"message":"109","line":76,"column":14,"nodeType":"110","messageId":"111","endLine":76,"endColumn":16},{"ruleId":"108","severity":1,"message":"109","line":3,"column":17,"nodeType":"110","messageId":"111","endLine":3,"endColumn":19},{"ruleId":"108","severity":1,"message":"109","line":92,"column":13,"nodeType":"110","messageId":"111","endLine":92,"endColumn":15},{"ruleId":"108","severity":1,"message":"109","line":3,"column":17,"nodeType":"110","messageId":"111","endLine":3,"endColumn":19},{"ruleId":"108","severity":1,"message":"109","line":92,"column":13,"nodeType":"110","messageId":"111","endLine":92,"endColumn":15},{"ruleId":"108","severity":1,"message":"120","line":24,"column":16,"nodeType":"110","messageId":"111","endLine":24,"endColumn":18},{"ruleId":"108","severity":1,"message":"109","line":16,"column":20,"nodeType":"110","messageId":"111","endLine":16,"endColumn":22},{"ruleId":"108","severity":1,"message":"109","line":76,"column":16,"nodeType":"110","messageId":"111","endLine":76,"endColumn":18},"no-native-reassign",["121"],"no-negated-in-lhs",["122"],"no-unused-vars","'isActive' is assigned a value but never used.","Identifier","unusedVar","'isPaused' is assigned a value but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'START_NODE_ROW', 'START_NODE_COL', 'FINISH_NODE_ROW', 'FINISH_NODE_COL'.","ArrowFunctionExpression","unsafeRefs","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-redeclare","'griddef' is already defined.","redeclared","'i' is already defined.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'demoMazeAlgorithm'. Either include it or remove the dependency array.","ArrayExpression",["123"],"Expected '!==' and instead saw '!='.","no-global-assign","no-unsafe-negation",{"desc":"124","fix":"125"},"Update the dependencies array to be: [demoMazeAlgorithm, mazeAlgorithm]",{"range":"126","text":"127"},[9880,9895],"[demoMazeAlgorithm, mazeAlgorithm]"]