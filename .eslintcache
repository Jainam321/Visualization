[{"C:\\Users\\kadam\\react\\Visualization\\src\\index.js":"1","C:\\Users\\kadam\\react\\Visualization\\src\\App.js":"2","C:\\Users\\kadam\\react\\Visualization\\src\\visualizers\\PathfindingVisualizer.jsx":"3","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\basicRandom.js":"4","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\recursive.js":"5","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\basicWeighted.js":"6","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\Simplestair.js":"7","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\Snakemaze.js":"8","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\DFS.js":"9","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\BFS.js":"10","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\Astar.js":"11","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\dijkstra.js":"12","C:\\Users\\kadam\\react\\Visualization\\src\\components\\Card.js":"13","C:\\Users\\kadam\\react\\Visualization\\src\\models\\Node\\Node.jsx":"14"},{"size":174,"mtime":1616938834922,"results":"15","hashOfConfig":"16"},{"size":347,"mtime":1618138421458,"results":"17","hashOfConfig":"16"},{"size":19902,"mtime":1618228431791,"results":"18","hashOfConfig":"16"},{"size":1863,"mtime":1618214484539,"results":"19","hashOfConfig":"16"},{"size":3743,"mtime":1618229167699,"results":"20","hashOfConfig":"16"},{"size":671,"mtime":1618209773643,"results":"21","hashOfConfig":"16"},{"size":624,"mtime":1618217110428,"results":"22","hashOfConfig":"16"},{"size":1705,"mtime":1618215783708,"results":"23","hashOfConfig":"16"},{"size":3524,"mtime":1618209773628,"results":"24","hashOfConfig":"16"},{"size":3649,"mtime":1618209773626,"results":"25","hashOfConfig":"16"},{"size":3388,"mtime":1618209773623,"results":"26","hashOfConfig":"16"},{"size":3527,"mtime":1618209773630,"results":"27","hashOfConfig":"16"},{"size":650,"mtime":1618209773632,"results":"28","hashOfConfig":"16"},{"size":780,"mtime":1617007082949,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"triyp6",{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":37,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"32"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"32"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"32"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"32"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"32"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"32"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"32"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"32"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"32"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"32"},"C:\\Users\\kadam\\react\\Visualization\\src\\index.js",[],["70","71"],"C:\\Users\\kadam\\react\\Visualization\\src\\App.js",[],"C:\\Users\\kadam\\react\\Visualization\\src\\visualizers\\PathfindingVisualizer.jsx",["72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108"],"import React, { useEffect, useState, useRef } from 'react';\r\nimport dijkstra, { getNodesInShortestPathOrderDijkstra } from '../algorithms/dijkstra';\r\nimport BFS, { getNodesInShortestPathOrderBFS } from '../algorithms/BFS';\r\nimport DFS, { getNodesInShortestPathOrderDFS } from '../algorithms/DFS';\r\nimport AStar, { getNodesInShortestPathOrderAStar } from '../algorithms/Astar';\r\nimport { Nav, Navbar, Button, NavDropdown, Toast } from 'react-bootstrap';\r\nimport Node from '../models/Node/Node';\r\nimport './PathfindingVisualizer.css';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport basicRandom from '../mazeAlgorithms/basicRandom.js';\r\nimport basicWeighted from '../mazeAlgorithms/basicWeighted.js';\r\nimport Simplestair from '../mazeAlgorithms/Simplestair.js';\r\nimport recursive from '../mazeAlgorithms/recursive.js';\r\nimport Snake from '../mazeAlgorithms/Snakemaze';\r\nimport Cards from '../components/Card';\r\n\r\nvar START_NODE_ROW = 10;\r\nvar START_NODE_COL = 10;\r\nvar FINISH_NODE_ROW = 8;\r\nvar FINISH_NODE_COL = 39;\r\n\r\nconst NODE_WEIGHT = 10;\r\n\r\nconst PathfindingVisualizer = () => {\r\n  const [grid, setGrid] = useState([]);\r\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\r\n  const [timer, setTimer] = useState(0);\r\n  const [isActive, setIsActive] = useState(false);\r\n  const [isPaused, setIsPaused] = useState(false);\r\n  const [noOfCellVisited, setNoOfCellVisited] = useState(0);\r\n  const [totalcost, settotalcost] = useState(0);\r\n  const [algorithm, setAlgorithm] = useState(\"Choose Algorithm\");\r\n  const [mazeAlgorithm, setmazeAlgorithm] = useState(\"Choose Maze Algorithm\");\r\n  const [show, setShow] = useState(false);\r\n  const [showComp, setShowComp] = useState(false);\r\n  const [isAddWeight, setIsAddWeight] = useState(false);\r\n  const [isStartNode, setIsStartNode] = useState(false);\r\n  const [isEndNode, setIsEndNode] = useState(false);\r\n  const [compValues, setCompValues] = useState([]);\r\n  const [algoRunTime, setAlgoRunTime] = useState(0);\r\n  const [totalNodes, setTotalNodes] = useState(0);\r\n\r\n  const countRef = useRef(null)\r\n\r\n\r\n  const handleStart = () => {\r\n    setIsActive(true);\r\n    setIsPaused(true);\r\n    countRef.current = setInterval(() => {\r\n      setTimer((timer) => timer + 1);\r\n    }, 1000);\r\n  }\r\n\r\n  const handlePause = () => {\r\n    clearInterval(countRef.current);\r\n    setIsPaused(false);\r\n  }\r\n\r\n  const handleReset = () => {\r\n    clearInterval(countRef.current);\r\n    setIsActive(false);\r\n    setIsPaused(false);\r\n    setTimer(0);\r\n  }\r\n\r\n  const formatTime = () => {\r\n    const getSeconds = `0${(timer % 60)}`.slice(-2)\r\n    const minutes = `${Math.floor(timer / 60)}`\r\n    const getMinutes = `0${minutes % 60}`.slice(-2)\r\n    const getHours = `0${Math.floor(timer / 3600)}`.slice(-2)\r\n\r\n    return `${getHours} : ${getMinutes} : ${getSeconds}`\r\n  }\r\n\r\n  useEffect(() => {\r\n    console.log('component mounted');\r\n    const grid = getInitialGrid();\r\n    setGrid(grid);\r\n  }, [])\r\n  const movestart = (grid, row, col, isStartNode, isEndNode) => {\r\n    const newGrid = grid.slice();\r\n    if (isStartNode) {\r\n      newGrid[START_NODE_ROW][START_NODE_COL].isStart = false;\r\n    } else if (isEndNode) {\r\n      newGrid[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish = false;\r\n    }\r\n\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isStart: isStartNode,\r\n      isFinish: isEndNode,\r\n      isWall: false,\r\n      weight: 0,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    if (isStartNode) {\r\n      START_NODE_ROW = newNode.row;\r\n      START_NODE_COL = newNode.col;\r\n    } else if (isEndNode) {\r\n      FINISH_NODE_ROW = newNode.row;\r\n      FINISH_NODE_COL = newNode.col;\r\n    }\r\n\r\n    return newGrid;\r\n  }\r\n  const handleMouseDown = (row, col) => {\r\n    if (row == START_NODE_ROW && col == START_NODE_COL) {\r\n      setMouseIsPressed(true);\r\n      setIsStartNode(true);\r\n      return;\r\n    } else if (row == FINISH_NODE_ROW && col == FINISH_NODE_COL) {\r\n      setMouseIsPressed(true);\r\n      setIsEndNode(true);\r\n      return;\r\n    }\r\n    const newGrid = getNewGridWithWallToggled(grid, row, col, isAddWeight, isStartNode, isEndNode);\r\n    setGrid(newGrid);\r\n    setMouseIsPressed(true);\r\n  }\r\n\r\n  const handleMouseEnter = (row, col) => {\r\n    if (!mouseIsPressed) return;\r\n    var newGrid;\r\n    if (isStartNode || isEndNode) {\r\n      newGrid = movestart(grid, row, col, isStartNode, isEndNode);\r\n      setGrid(newGrid);\r\n    } else if (!((row == START_NODE_ROW && col == START_NODE_COL) || (row == FINISH_NODE_ROW && col == FINISH_NODE_COL))) {\r\n      newGrid = getNewGridWithWallToggled(grid, row, col, isAddWeight, isStartNode, isEndNode);\r\n      setGrid(newGrid);\r\n    }\r\n  }\r\n\r\n  const handleMouseUp = (row, col) => {\r\n    setMouseIsPressed(false);\r\n    setIsStartNode(false);\r\n    setIsEndNode(false);\r\n  }\r\n\r\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-visited';\r\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  const animateShortestPath = (nodesInShortestPathOrder) => {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        if (node.weight === NODE_WEIGHT) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-weight-in-path';\r\n        }\r\n        else {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\r\n        }\r\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n      }, 50 * i);\r\n    }\r\n    handlePause();\r\n  }\r\n\r\n  \r\n\r\n  const clearBoard = () => {\r\n    handleReset();\r\n    setGrid(getInitialGrid());\r\n    setNoOfCellVisited(0);\r\n    settotalcost(0);\r\n    clearGrid();\r\n    // setAlgorithm(\"Choose Algorithm\");\r\n    // setmazeAlgorithm(\"Choose Maze Algorithm\");\r\n    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n    document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n  }\r\n\r\n  const clearVisualization = (grid) => {\r\n    handleReset();\r\n    setGrid(getPartialGrid());\r\n    setNoOfCellVisited(0);\r\n    settotalcost(0);\r\n    clearGrid();\r\n    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n    document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n  }\r\n\r\n  const getPartialGrid = () => {\r\n    for (let row = 0; row < 20; row++) {\r\n      for (let col = 0; col < 50; col++) {\r\n        grid[row][col].previousNode = null;\r\n      }\r\n    }\r\n    return grid;\r\n  }\r\n\r\n  const clearGrid = () => {\r\n    const newGrid = grid;\r\n    for (const row of newGrid) {\r\n      for (const node of row) {\r\n        let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`,).className;\r\n        if (nodeClassName !== 'node node-start' &&\r\n          nodeClassName !== 'node node-finish' &&\r\n          nodeClassName !== 'node node-wall') {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node';\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const visualizeAlgorithm = () => {\r\n    clearVisualization();\r\n    handleStart();\r\n    var start = new Date().getTime();\r\n    // console.log(\"Start: \", start)\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let visitedNodesInOrder, nodesInShortestPathOrder;\r\n    if (algorithm == \"Dijkstra\") {\r\n      visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n      nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(finishNode, startNode);\r\n      var start2 = new Date().getTime();\r\n      setAlgoRunTime(start2 - start);\r\n      setShowComp(true);\r\n    }\r\n    else if (algorithm == \"BFS\") {\r\n      visitedNodesInOrder = BFS(grid, startNode, finishNode);\r\n      nodesInShortestPathOrder = getNodesInShortestPathOrderBFS(finishNode, startNode);\r\n      var start2 = new Date().getTime();\r\n      setAlgoRunTime(start2 - start);\r\n      setShowComp(true);\r\n    }\r\n    else if (algorithm == \"DFS\") {\r\n      visitedNodesInOrder = DFS(grid, startNode, finishNode);\r\n      nodesInShortestPathOrder = getNodesInShortestPathOrderDFS(finishNode, startNode);\r\n      var start2 = new Date().getTime();\r\n      setAlgoRunTime(start2 - start);\r\n      setShowComp(true);\r\n    } else if (algorithm == \"AStar\") {\r\n      // var start = new Date().getTime();\r\n      // console.log(\"Start: \", start)\r\n      visitedNodesInOrder = AStar(grid, startNode, finishNode);\r\n      // console.log(visitedNodesInOrder.length);\r\n      nodesInShortestPathOrder = getNodesInShortestPathOrderAStar(finishNode, startNode);\r\n      // console.log(nodesInShortestPathOrder.length);\r\n      var start2 = new Date().getTime();\r\n      setAlgoRunTime(start2 - start);\r\n      setShowComp(true);\r\n    }\r\n    else {\r\n      setShow(true);\r\n      handlePause();\r\n      return;\r\n    }\r\n    console.log(visitedNodesInOrder.length);\r\n    console.log(nodesInShortestPathOrder.length);\r\n    setTotalNodes(visitedNodesInOrder.length);\r\n\r\n\r\n    settotalcost(finishNode.distance);\r\n    animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    setNoOfCellVisited(nodesInShortestPathOrder.length);\r\n  }\r\n\r\n  const demoMazeAlgorithm = () => {\r\n    if (mazeAlgorithm === \"Choose Maze Algorithm\") return;\r\n    clearBoard();\r\n    console.log(mazeAlgorithm);\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    if (mazeAlgorithm == \"Basic Random Maze\") {\r\n      var griddef = basicRandom(grid, startNode, finishNode);\r\n      for (var i = 0; i < griddef.length; i++) {\r\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-wall';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col, isAddWeight);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n    else if (mazeAlgorithm == \"Basic Weight Maze\") {\r\n      var griddef = basicWeighted(grid, startNode, finishNode);\r\n      for (var i = 0; i < griddef.length; i++) {\r\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-weight';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n    else if (mazeAlgorithm == \"Snake Maze\") {\r\n      // recursive(grid,0,grid.length-1,0,grid.length-1,startNode,finishNode);\r\n      Snake(grid, startNode, finishNode);\r\n      var griddef = Snake(grid, startNode, finishNode);\r\n      for (var i = 0; i < griddef.length; i++) {\r\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-weight';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n    else if (mazeAlgorithm == \"Simple Stair Pattern\") {\r\n      var griddef = Simplestair(grid, startNode, finishNode);\r\n      for (var i = 0; i < griddef.length; i++) {\r\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-weight';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n    else if (mazeAlgorithm == \"Recursive Division\") {\r\n      var count2=0;\r\n      let list1=[];\r\n      var orientation=\"horizontal\";\r\n      var griddef= recursive(grid,0,grid.length-1,0,grid.length-1,startNode,finishNode,count2,list1,orientation);\r\n      for(var i=0;i<griddef.length;i++)\r\n      {\r\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n        'node node-weight';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n  }\r\n\r\n  const compareVisualization = () => {\r\n    var maze1 = \"\";\r\n    if (mazeAlgorithm == \"Choose Maze Algorithm\") {\r\n      maze1 = \"No algorithm selected\";\r\n    }\r\n    else {\r\n      maze1 = mazeAlgorithm;\r\n    }\r\n    const listOfValues = [grid, algorithm, totalcost, noOfCellVisited, algoRunTime, maze1, totalNodes];\r\n    setCompValues([...compValues, listOfValues]);\r\n    console.log(compValues);\r\n\r\n  }\r\n\r\n  const addWeights = () => {\r\n    setIsAddWeight(!isAddWeight);\r\n  }\r\n  useEffect(() => {\r\n    demoMazeAlgorithm();\r\n  }, [mazeAlgorithm]);\r\n\r\n  return (\r\n    <>\r\n      <Navbar bg=\"light\" variant=\"light\">\r\n        <div className=\"container\">\r\n          <Navbar.Brand href=\"#home\">Path Visualization</Navbar.Brand>\r\n          <Nav className=\"mr-auto\">\r\n            <NavDropdown title={algorithm} id=\"basic-nav-dropdown\">\r\n              <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"Dijkstra\")}>Dijkstra</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"BFS\")}>BFS</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"DFS\")}>DFS</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"AStar\")}>AStar</NavDropdown.Item>\r\n            </NavDropdown>\r\n            <NavDropdown title={mazeAlgorithm} id=\"basic-nav-dropdown\">\r\n              <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Basic Random Maze\");\r\n              }}>Basic Random Maze</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Basic Weight Maze\");\r\n              }}>Basic Weight Maze</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Simple Stair Pattern\");\r\n              }}>Simple Stair Pattern</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Snake Maze\");\r\n              }}>Snake Maze</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Recursive Division\");\r\n              }}>Recursive Division</NavDropdown.Item>\r\n            </NavDropdown>\r\n          </Nav>\r\n          <div>\r\n\r\n            <Toast onClose={() => setShow(false)} show={show} delay={3000} autohide\r\n              style={{\r\n                position: 'absolute',\r\n                top: 0,\r\n                right: \"50%\",\r\n              }}>\r\n              <Toast.Header>\r\n                <strong className=\"mr-auto\">First Choose Algorithm</strong>\r\n              </Toast.Header>\r\n            </Toast>\r\n            <Toast onClose={() => clearVisualization()} show={totalcost == Infinity} delay={3000}\r\n              style={{\r\n                position: 'absolute',\r\n                top: 0,\r\n                right: \"50%\",\r\n              }}>\r\n              <Toast.Header>\r\n                <strong className=\"mr-auto\">No Path Found</strong>\r\n              </Toast.Header>\r\n            </Toast>\r\n          </div>\r\n          <div className=\"m\">\r\n            <span className=\"pBtn\">\r\n              <Button variant=\"success\" size=\"sm\" onClick={() => addWeights()}>\r\n                {isAddWeight ? \"Adding Weights\" : \"Add Weights\"}\r\n              </Button>\r\n            </span>\r\n            <span className=\"pBtn\">\r\n              <Button variant=\"secondary\" size=\"sm\" onClick={() => clearBoard()}>Clear Board</Button>\r\n            </span>\r\n            <span className=\"pBtn\">\r\n              <Button variant=\"secondary\" size=\"sm\" onClick={(grid) => clearVisualization(grid)}>Clear Visualization</Button>\r\n            </span>\r\n            <Button variant=\"primary\" onClick={() => visualizeAlgorithm()}>Start</Button>\r\n\r\n            <span className=\"pBtn\" style={{ marginLeft: '10px' }}>\r\n              {showComp ?\r\n                <Button variant=\"primary\" onClick={() => compareVisualization()}>Compare</Button>\r\n                : <span></span>\r\n              }\r\n            </span>\r\n            <span className=\"pBtn\">\r\n              {showComp ?\r\n                <Button variant=\"danger\" onClick={() => setCompValues([])}>Clear Comparison</Button>\r\n                : <span></span>\r\n              }\r\n            </span>\r\n          </div>\r\n        </div>\r\n      </Navbar>\r\n      <span className=\"pText\">Timer</span>\r\n      <span className=\"timeBox\">{formatTime()}</span>\r\n      <span className=\"pText\">No. of Cells Visited</span>\r\n      <span className=\"timeBox\">{noOfCellVisited}</span>\r\n      <span className=\"pText\">Total Cost</span>\r\n      <span className=\"timeBox\">{totalcost}</span>\r\n\r\n\r\n\r\n\r\n      <div className=\"Flexbox1\">\r\n\r\n        {/* <ul>{compValues.length != 0 ? (compValues.map((todo, index) =>  <li key={index}>    {todo[1]} {todo[2]} {todo[3]} </li>)) : console.log('else')}</ul> */}\r\n        {/* <ul>{compValues.length != 0 ? (compValues.map((todo, index) =>  <li>    {todo[1]} {todo[2]} {todo[3]} </li>)) : console.log('else')}</ul> */}\r\n\r\n        {compValues.length != 0 ? (compValues.map((todo, index) => <Cards key={index} grid1={todo[0]} algo={todo[1]} tc={todo[2]} cells={todo[3]} time1={todo[4]} maze1={todo[5]} total1={todo[6]}>  </Cards>)) : console.log('else')}\r\n      </div>\r\n\r\n\r\n\r\n      <div className=\"grid\">\r\n        {grid.map((row, rowIdx) => {\r\n          return (\r\n            <div key={rowIdx}>\r\n              {row.map((node, nodeIdx) => {\r\n                const { row, col, isFinish, isStart, isWall, weight } = node;\r\n                return (\r\n                  <Node\r\n                    key={nodeIdx}\r\n                    col={col}\r\n                    isFinish={isFinish}\r\n                    isStart={isStart}\r\n                    isWall={isWall}\r\n                    mouseIsPressed={mouseIsPressed}\r\n                    weight={weight}\r\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\r\n                    onMouseEnter={(row, col) =>\r\n                      handleMouseEnter(row, col)\r\n                    }\r\n                    onMouseUp={() => handleMouseUp()}\r\n                    row={row}></Node>\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\n\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < 20; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 50; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n    weight: 0,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col, isAddWeight, isStartNode, isEndNode) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: (isAddWeight || isStartNode || isEndNode) ? false : !node.isWall,\r\n    weight: node.weight == 0 && isAddWeight ? NODE_WEIGHT : 0,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\nexport default PathfindingVisualizer;\r\n","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\basicRandom.js",["109","110","111","112","113","114"],"function basicRandom(grid, startNode, finishNode) {\r\n     var grid1 = []\r\n     // let cIdY=grid.length[0]-10;\r\n     // for(let c=0 ;c<10;c++)\r\n     // {\r\n     //      let cIdXone= Math.floor(grid.length/2)-c;\r\n     //      let cIdXtwo = Math.floor(grid.length/2)+c;\r\n     //      // let cIdone = cIdY-cIdXone;\r\n     //      // let cIdtwo = cIdY-cIdXtwo;\r\n     //      console.log(cIdXone);\r\n     //      console.log(cIdXtwo);\r\n     //      // console.log((cIdY,cIdtwo));\r\n     //      if(cIdy>=20 || CIdXone>=50 || cIdXtwo>=50){\r\n     //           continue;\r\n     //      }\r\n     //      else{\r\n     //           grid1.push(grid[cIdY][cIdXone]);\r\n     //           grid1.push(grid[cIdY][cIdXtwo]);\r\n     //      }\r\n     //      // console.log(cIdone);\r\n     //      // console.log(cIdtwo);\r\n     // }\r\n     for (var i = 0; i < 20; i += 3) {\r\n          for (var j = 0; j < 50; j += 3) {\r\n               var x = Math.floor((Math.random() * 10) + 1);\r\n               var col = Math.abs(i - x);\r\n               var row = Math.abs(j - x);\r\n               if (col == startNode.col && row == startNode.row) {\r\n                    continue;\r\n               }\r\n               else if (col == finishNode.col && row == finishNode.row) {\r\n                    continue;\r\n               }\r\n               if(grid1.length>1){\r\n               var count=0;\r\n               for(var k=0;k<grid1.length;k++)\r\n               {\r\n                    if(grid[k]==grid[col][row])\r\n                    {\r\n                         count=1;\r\n                    }\r\n               }\r\n               if(count==0)\r\n               {\r\n                    grid1.push(grid[col][row]);\r\n               }\r\n               }\r\n               else\r\n               {\r\n               grid1.push(grid[col][row]);\r\n               }\r\n          }\r\n     }\r\n     return grid1;\r\n}\r\n\r\n\r\nexport default basicRandom;","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\recursive.js",["115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130"],"function recursive(grid, rowStart, rowEnd, colStart, colEnd, startNode, finishNode,count=0,grid2,orientation) {\r\n    let grid1=grid2;\r\n    count+=1;\r\n    if(count==100){\r\n        console.log(\"finish\",count);\r\n        return grid1;\r\n    }\r\n    if (rowEnd >= (grid.length) || colEnd >= grid.length || rowStart < 0 || colStart < 0) {\r\n        return;\r\n    }\r\n    if(orientation==\"horizontal\")\r\n    {\r\n        \r\n        let possibleRows = [];\r\n        for (let number = rowStart; number <= rowEnd; number += 2) {\r\n            possibleRows.push(number);\r\n        }\r\n        let possibleCols = []\r\n        for (let number = colStart; number <= colEnd; number += 2) {\r\n            possibleCols.push(number);\r\n        }\r\n        var randomRowIndex = Math.ceil(Math.random() * possibleRows.length);\r\n        var randomColIndex = Math.ceil(Math.random() * possibleCols.length);\r\n        let currentRow = possibleRows[randomRowIndex];\r\n        let colRandom = possibleCols[randomColIndex];\r\n        if (currentRow != undefined && colRandom != undefined) {\r\n            if((currentRow!=startNode.col && colRandom!=startNode.row) || (currentRow != finishNode.col && colRandom != finishNode.row))\r\n        {\r\n            console.log(\"currentRow\", currentRow);\r\n            console.log(\"colRandom\", colRandom);\r\n            grid1.push(grid[currentRow][currentRow]);\r\n        }\r\n        }\r\n        if (currentRow - 2 - rowStart > colEnd - colStart) {\r\n            recursive(grid, rowStart, currentRow - 2, colStart, colEnd, startNode, finishNode,count,grid1,orientation);\r\n          } else {\r\n            recursive(grid, rowStart, currentRow - 2, colStart, colEnd, startNode, finishNode,count,grid1,\"horizontal\");\r\n          }\r\n          if (rowEnd - (currentRow + 2) > colEnd - colStart) {\r\n            recursive(grid, currentRow + 2, rowEnd, colStart, colEnd, startNode, finishNode,count,grid1,orientation);\r\n          } else {\r\n            recursive(grid, currentRow + 2, rowEnd, colStart, colEnd, startNode, finishNode,count,grid1,\"vertical\");\r\n          }\r\n    }\r\n    else{\r\n        let possibleRows = [];\r\n        for (let number = rowStart; number <= rowEnd; number += 2) {\r\n            possibleRows.push(number);\r\n        }\r\n        let possibleCols = []\r\n        for (let number = colStart; number <= colEnd; number += 2) {\r\n            possibleCols.push(number);\r\n        }\r\n        var randomRowIndex = Math.ceil(Math.random() * possibleRows.length);\r\n        var randomColIndex = Math.ceil(Math.random() * possibleCols.length);\r\n        let rowRandom = possibleRows[randomRowIndex];\r\n        let currentCol = possibleCols[randomColIndex];\r\n        if (rowRandom!= undefined && currentCol != undefined) {\r\n            if((rowRandom!=startNode.col && currentCol!=startNode.row) || (rowRandom != finishNode.col && currentCol != finishNode.row))\r\n        {\r\n            console.log(\"currentRow\", rowRandom);\r\n            console.log(\"colRandom\", currentCol);\r\n            grid1.push(grid[currentCol][rowRandom]);\r\n        }\r\n        }\r\n        if (rowEnd - rowStart > currentCol - 2 - colStart) {\r\n            recursive(grid, rowStart,rowEnd, colStart, currentCol - 2, startNode, finishNode,count,grid1,\"horizontal\");\r\n          } else {\r\n            recursive(grid, rowStart, rowEnd, colStart, currentCol - 2, startNode, finishNode,count,grid1,\"horizontal\");\r\n          }\r\n          if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\r\n            recursive(grid, rowStart, rowEnd, colStart, currentCol + 2, startNode, finishNode,count,grid1,\"horizontal\");\r\n          } else {\r\n            recursive(grid, rowStart, rowEnd, colStart, currentCol + 2, startNode, finishNode,count,grid1,orientation);\r\n          }\r\n    }\r\n}\r\n\r\nexport default recursive;","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\basicWeighted.js",["131","132","133","134"],"function basicWeighted(grid, startNode, finishNode) {\r\n     var grid1 = []\r\n     for (var i = 0; i < 20; i += 3) {\r\n          for (var j = 0; j < 50; j += 3) {\r\n               var x = Math.floor((Math.random() * 10) + 1);\r\n               var col = Math.abs(i - x);\r\n               var row = Math.abs(j - x);\r\n               if (col == startNode.col && row == startNode.row) {\r\n                    continue;\r\n               }\r\n               else if (col == finishNode.col && row == finishNode.row) {\r\n                    continue;\r\n               }\r\n               grid1.push(grid[col][row]);\r\n          }\r\n     }\r\n     return grid1;\r\n}\r\n\r\n\r\nexport default basicWeighted;","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\Simplestair.js",["135","136","137","138"],"function Simplestair(grid, startNode, finishNode) {\r\n  var grid1 = [];\r\n  let x = grid.length;\r\n  let y = 0;\r\n  while (x < 2 * (grid.length) - 1 && y < grid.length - 4) {\r\n    if (grid[y][x] == startNode || grid[y][x] == finishNode) {\r\n      continue;\r\n    }\r\n    else {\r\n      grid1.push(grid[y][x]);\r\n    }\r\n    x++;\r\n    y++;\r\n  };\r\n  x = grid.length - 1;\r\n  y = 0;\r\n  while (x >= 0 && y < grid.length-1) {\r\n    if (grid[y][x] == startNode || grid[y][x] == finishNode) {\r\n      continue;\r\n    }\r\n    else {\r\n      grid1.push(grid[y][x]);\r\n    }\r\n    x--;\r\n    y++;\r\n  };\r\n  return grid1;\r\n}\r\n\r\nexport default Simplestair;","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\Snakemaze.js",["139","140","141","142","143","144","145","146","147","148","149","150","151","152"],"function Snake(grid, startNode, finishNode) {\r\n    let grid1 = []\r\n    let nrequired = []\r\n    for (let k = 1; k < 10; k++) {\r\n        for (let j = 1; j < 15; j++) {\r\n            let x = Math.floor((Math.random() * 50) + 1);\r\n            nrequired.push(grid[j][x]);\r\n        }\r\n    }\r\n    for (var i = 1; i < 20; i += 2) {\r\n        for (var j = 0; j < 50; j++) {\r\n            if (grid[i][j] == startNode && grid[i][j] == finishNode) {\r\n                continue;\r\n            }\r\n            else {\r\n                if (grid[i][j] == startNode || grid[i][j] == finishNode) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    let count = 1;\r\n                    for (let z = 0; z < nrequired.length; z++) {\r\n                        if (grid[i][j] == nrequired[z]) {\r\n                            count = 0;\r\n                        }\r\n                    }\r\n                    if (count == 1) {\r\n                        grid1.push(grid[i][j]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (var i = 2; i < 20; i += 2) {\r\n        for (var j = 10; j < 30; j += 2) {\r\n            if (grid[i][j] == startNode || grid[i][j] == finishNode) {\r\n                continue;\r\n            }\r\n            else {\r\n                grid1.push(grid[i][j - i + 10]);\r\n            }\r\n        }\r\n    }\r\n    for (var i = 1; i < 20; i += 2) {\r\n        for (var j = 50; j < 50; j += 2) {\r\n            if (grid[i][j] == startNode || grid[i][j] == finishNode) {\r\n                continue;\r\n            }\r\n            else {\r\n                grid1.push(grid[i][j - i -1]);\r\n            }\r\n        }\r\n    }\r\n    return grid1;\r\n}\r\n\r\nexport default Snake;","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\DFS.js",["153","154"],"export default function DFS(grid, startNode, finishNode) {\r\n    if (startNode == finishNode || !startNode || !finishNode) {\r\n        return false;\r\n    }\r\n    console.log(\"in DFS\");\r\n    var count = 0;\r\n    startNode.distance = 0;\r\n    const visited = new Map();\r\n    const visitedinorder = [];\r\n    const visitList = [];\r\n    visitList.push(startNode)\r\n    const graph = creategraph(grid);\r\n    while (visitList.length !== 0) {\r\n        const node = visitList.pop();\r\n        if (node && !visited.has(node)) {\r\n            if (node.isWall) continue;\r\n            visitedinorder.push(node);\r\n            count++;\r\n            visited.set(node);\r\n            // console.log(\"visited\");\r\n            // console.log(node.row);\r\n            // console.log(node.col);\r\n            if (node === finishNode) {\r\n                console.log(\"count\", count);\r\n                return visitedinorder;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList, node, graph, visited);\r\n        }\r\n    }\r\n    return visitedinorder;\r\n\r\n}\r\n\r\n\r\n\r\nfunction creategraph(grid) {\r\n    const graph = new Graph(1000);\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            if ((row + 1) < 20) {\r\n                graph.addEdge(grid[row][col], grid[row + 1][col]);\r\n            }\r\n            if ((col - 1 >= 0)) {\r\n                graph.addEdge(grid[row][col], grid[row][col - 1]);\r\n            }\r\n            if ((col + 1 < 50)) {\r\n                graph.addEdge(grid[row][col], grid[row][col + 1]);\r\n            }\r\n            if ((row - 1) >= 0) {\r\n                graph.addEdge(grid[row][col], grid[row - 1][col]);\r\n            }\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n\r\n\r\nclass Graph {\r\n    constructor(noOfVertices) {\r\n        this.noOfVertices = noOfVertices;\r\n        this.Adjlist = new Map();\r\n    }\r\n\r\n    addVertex(v) {\r\n        this.Adjlist.set(v, []);\r\n    }\r\n\r\n    addEdge(v, w) {\r\n        this.Adjlist.get(v).push(w);\r\n    }\r\n\r\n    getAdjacents(node) {\r\n        return this.Adjlist.get(node);\r\n    }\r\n\r\n    isAdjacent(node, neighbor) {\r\n        var temp = 0;\r\n        this.Adjlist.get(neighbor).forEach(x => {\r\n            if (x == node) {\r\n                temp++;\r\n            }\r\n        })\r\n        if (temp === 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList, node, graph, visited) {\r\n    // console.log(\"neigbour\");\r\n    for (const neighbor of visitList) {\r\n        if (graph.isAdjacent(node, neighbor) && !visited.has(neighbor)) {\r\n            neighbor.distance = node.distance + neighbor.weight + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderDFS(finishNode, startNode) {\r\n    // console.log(\"shortest Path\");\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        //   console.log(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n        if (currentNode === startNode) {\r\n            //   console.log(currentNode.row);\r\n            //   console.log(currentNode.col);\r\n            break;\r\n        }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\BFS.js",["155","156","157"],"export default function BFS(grid, startNode, finishNode) {\r\n    if (startNode == finishNode || !startNode || !finishNode) {\r\n        return false;\r\n    }\r\n    // console.log(\"in BFS\");\r\n    var count = 0;\r\n    startNode.distance = 0;\r\n    const visited = new Map();\r\n    const visitedinorder = [];\r\n    const visitList = [];\r\n    visitList.push(startNode)\r\n    const graph = creategraph(grid);\r\n    while (visitList.length !== 0) {\r\n        const node = visitList.shift();\r\n        if (node && !visited.has(node)) {\r\n            if (node.isWall) continue;\r\n            visitedinorder.push(node);\r\n            count++;\r\n            visited.set(node);\r\n            // console.log(\"visited\");\r\n            // console.log(node.row);\r\n            // console.log(node.col);\r\n            if (node === finishNode) {\r\n                // console.log(\"count\",count);\r\n                return visitedinorder;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList, node, graph);\r\n        }\r\n    }\r\n    return visitedinorder;\r\n\r\n}\r\n\r\n\r\n\r\nfunction creategraph(grid) {\r\n    const graph = new Graph(1000);\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            if ((col + 1 < 50)) {\r\n                graph.addEdge(grid[row][col], grid[row][col + 1]);\r\n            }\r\n            if ((col - 1 >= 0)) {\r\n                graph.addEdge(grid[row][col], grid[row][col - 1]);\r\n            }\r\n            if ((row - 1) >= 0) {\r\n                graph.addEdge(grid[row][col], grid[row - 1][col]);\r\n            }\r\n            if ((row + 1) < 20) {\r\n                graph.addEdge(grid[row][col], grid[row + 1][col]);\r\n            }\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n\r\n\r\nclass Graph {\r\n    constructor(noOfVertices) {\r\n        this.noOfVertices = noOfVertices;\r\n        this.Adjlist = new Map();\r\n    }\r\n\r\n    addVertex(v) {\r\n        this.Adjlist.set(v, []);\r\n    }\r\n\r\n    addEdge(v, w) {\r\n        this.Adjlist.get(v).push(w);\r\n    }\r\n\r\n    getAdjacents(node) {\r\n        return this.Adjlist.get(node);\r\n    }\r\n\r\n    isAdjacent(node, neighbor) {\r\n        var temp = 0;\r\n        this.Adjlist.get(neighbor).forEach(x => {\r\n            if (x == node) {\r\n                temp++;\r\n            }\r\n        })\r\n        if (temp === 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList, node, graph) {\r\n    // console.log(\"neigbour\");\r\n    for (const neighbor of visitList) {\r\n        if (!graph.isAdjacent(node, neighbor) || neighbor.previousNode !== null) {\r\n            continue;\r\n        } else if (graph.isAdjacent(node, neighbor)) {\r\n            neighbor.distance = node.distance + neighbor.weight + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBFS(finishNode, startNode) {\r\n    // console.log(\"shortest Path\");\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        //   console.log(currentNode.row);\r\n        //   console.log(currentNode.col);\r\n        currentNode = currentNode.previousNode;\r\n        if (currentNode === startNode) {\r\n            //   console.log(currentNode.row);\r\n            //   console.log(currentNode.col);\r\n            break;\r\n        }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\Astar.js",["158","159"],"export default function AStar(grid, startnode, endnode) {\r\n  startnode.distance = 0;\r\n  const visited = new Map();\r\n  const visitedinorder = [];\r\n  const visitList = [];\r\n  visitList.push(startnode);\r\n  const graph = creategraph(grid);\r\n  while (visitList.length !== 0) {\r\n    const node = visitList.shift();\r\n    if (node && !visited.has(node)) {\r\n      if (node.isWall) continue;\r\n      visitedinorder.push(node);\r\n      visited.set(node);\r\n      // console.log(node.row);\r\n      // console.log(node.col);\r\n      if (node == endnode) {\r\n        return visitedinorder;\r\n      }\r\n      graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n      updateUnvisitedNeighbors(visitList, node, graph);\r\n      sortnodebydistance(visitList, endnode);\r\n    }\r\n  }\r\n  return visitedinorder;\r\n}\r\n\r\nfunction creategraph(grid) {\r\n  const graph = new Graph(1000);\r\n  for (let row = 0; row < 20; row++) {\r\n    for (let col = 0; col < 50; col++) {\r\n      graph.addVertex(grid[row][col]);\r\n    }\r\n  }\r\n  for (let row = 0; row < 20; row++) {\r\n    for (let col = 0; col < 50; col++) {\r\n      if ((col + 1 < 50)) {\r\n        graph.addEdge(grid[row][col], grid[row][col + 1]);\r\n      }\r\n      if ((row + 1) < 20) {\r\n        graph.addEdge(grid[row][col], grid[row + 1][col]);\r\n      }\r\n      if ((col - 1) >= 0) {\r\n        graph.addEdge(grid[row][col], grid[row][col - 1]);\r\n      }\r\n      if ((row - 1) >= 0) {\r\n        graph.addEdge(grid[row][col], grid[row - 1][col]);\r\n      }\r\n\r\n    }\r\n  }\r\n  return graph;\r\n}\r\n\r\nclass Graph {\r\n  constructor(noOfVertices) {\r\n    this.noOfVertices = noOfVertices;\r\n    this.AdjList = new Map();\r\n  }\r\n  addVertex(v) {\r\n    this.AdjList.set(v, []);\r\n  }\r\n  addEdge(v, w) {\r\n    this.AdjList.get(v).push(w);\r\n  }\r\n  getAdjacents(node) {\r\n    return this.AdjList.get(node);\r\n  }\r\n\r\n  isAdjacent(node, neighbor) {\r\n    var temp = 0;\r\n    this.AdjList.get(node).forEach(adj => {\r\n      if (adj === neighbor) {\r\n        temp++;\r\n      }\r\n    })\r\n    if (temp == 0) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction sortnodebydistance(unvisitednodes, finishNode) {\r\n  unvisitednodes.sort((nodeA, nodeB) => (nodeA.distance + manhattendistance(nodeA, finishNode)) - (nodeB.distance + manhattendistance(nodeB, finishNode)));\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList, node, graph) {\r\n  for (const neighbor of visitList) {\r\n    if ((neighbor.previousNode !== null && neighbor.distance <= node.distance) || !graph.isAdjacent(node, neighbor)) {\r\n      continue;\r\n    } else if (graph.isAdjacent(node, neighbor)) {\r\n      neighbor.distance = node.distance + neighbor.weight + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderAStar(finishNode, startNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    //   console.log(currentNode.row);\r\n    //   console.log(currentNode.col);\r\n    currentNode = currentNode.previousNode;\r\n    if (currentNode === startNode) {\r\n      //   console.log(currentNode.row);\r\n      //   console.log(currentNode.col);\r\n      break;\r\n    }\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\nfunction manhattendistance(node, finishnode) {\r\n  var hn = (Math.abs(node.row - finishnode.row) + Math.abs(node.col - finishnode.col));\r\n  return hn;\r\n}\r\n","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\dijkstra.js",["160","161"],"export default function dijkstra(grid, startnode, endnode) {\r\n    startnode.distance = 0;\r\n    const visited = new Map();\r\n    const visitedinorder = [];\r\n    const visitList = [];\r\n    visitList.push(startnode);\r\n    const graph = creategraph(grid);\r\n    while (visitList.length !== 0) {\r\n        const node = visitList.shift();\r\n        if (node && !visited.has(node)) {\r\n            if (node.isWall) continue;\r\n            visitedinorder.push(node);\r\n            visited.set(node);\r\n            //   console.log(node.row);\r\n            //   console.log(node.col);\r\n            if (node == endnode) {\r\n                return visitedinorder;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList, node, graph);\r\n            sortnodebydistance(visitList);\r\n        }\r\n    }\r\n    return visitedinorder;\r\n}\r\n\r\nfunction creategraph(grid) {\r\n    const graph = new Graph(1000);\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            if ((col + 1 < 50)) {\r\n                graph.addEdge(grid[row][col], grid[row][col + 1]);\r\n            }\r\n            if ((row + 1) < 20) {\r\n                graph.addEdge(grid[row][col], grid[row + 1][col]);\r\n            }\r\n            if ((col - 1) >= 0) {\r\n                graph.addEdge(grid[row][col], grid[row][col - 1]);\r\n            }\r\n            if ((row - 1) >= 0) {\r\n                graph.addEdge(grid[row][col], grid[row - 1][col]);\r\n            }\r\n\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n\r\nclass Graph {\r\n    constructor(noOfVertices) {\r\n        this.noOfVertices = noOfVertices;\r\n        this.AdjList = new Map();\r\n    }\r\n    addVertex(v) {\r\n        this.AdjList.set(v, []);\r\n    }\r\n    addEdge(v, w) {\r\n        this.AdjList.get(v).push(w);\r\n    }\r\n    getAdjacents(node) {\r\n        return this.AdjList.get(node);\r\n    }\r\n\r\n    isAdjacent(node, neighbor) {\r\n        var temp = 0;\r\n        this.AdjList.get(node).forEach(adj => {\r\n            if (adj === neighbor) {\r\n                temp++;\r\n            }\r\n        })\r\n        if (temp == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\nfunction sortnodebydistance(unvisitednodes) {\r\n    unvisitednodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList, node, graph) {\r\n    for (const neighbor of visitList) {\r\n        if ((neighbor.previousNode !== null && neighbor.distance <= node.distance) || !graph.isAdjacent(node, neighbor)) {\r\n            continue;\r\n        } else if (graph.isAdjacent(node, neighbor)) {\r\n            neighbor.distance = node.distance + neighbor.weight + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderDijkstra(finishNode, startNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        // console.log(currentNode.row);\r\n        // console.log(currentNode.col);\r\n        currentNode = currentNode.previousNode;\r\n        if (currentNode === startNode) {\r\n            // console.log(currentNode.row);\r\n            // console.log(currentNode.col);\r\n            break;\r\n        }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","C:\\Users\\kadam\\react\\Visualization\\src\\components\\Card.js",[],"C:\\Users\\kadam\\react\\Visualization\\src\\models\\Node\\Node.jsx",["162"],"import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n      weight = 0,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : weight != 0\r\n      ? 'node-weight'\r\n      : '';\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></div>\r\n    );\r\n  }\r\n}\r\n",{"ruleId":"163","replacedBy":"164"},{"ruleId":"165","replacedBy":"166"},{"ruleId":"167","severity":1,"message":"168","line":28,"column":10,"nodeType":"169","messageId":"170","endLine":28,"endColumn":18},{"ruleId":"167","severity":1,"message":"171","line":29,"column":10,"nodeType":"169","messageId":"170","endLine":29,"endColumn":18},{"ruleId":"172","severity":1,"message":"173","line":108,"column":13,"nodeType":"174","messageId":"175","endLine":108,"endColumn":15},{"ruleId":"172","severity":1,"message":"173","line":108,"column":38,"nodeType":"174","messageId":"175","endLine":108,"endColumn":40},{"ruleId":"172","severity":1,"message":"173","line":112,"column":20,"nodeType":"174","messageId":"175","endLine":112,"endColumn":22},{"ruleId":"172","severity":1,"message":"173","line":112,"column":46,"nodeType":"174","messageId":"175","endLine":112,"endColumn":48},{"ruleId":"172","severity":1,"message":"173","line":128,"column":23,"nodeType":"174","messageId":"175","endLine":128,"endColumn":25},{"ruleId":"172","severity":1,"message":"173","line":128,"column":48,"nodeType":"174","messageId":"175","endLine":128,"endColumn":50},{"ruleId":"172","severity":1,"message":"173","line":128,"column":75,"nodeType":"174","messageId":"175","endLine":128,"endColumn":77},{"ruleId":"172","severity":1,"message":"173","line":128,"column":101,"nodeType":"174","messageId":"175","endLine":128,"endColumn":103},{"ruleId":"176","severity":1,"message":"177","line":148,"column":18,"nodeType":"178","messageId":"179","endLine":154,"endColumn":8},{"ruleId":"176","severity":1,"message":"177","line":160,"column":18,"nodeType":"178","messageId":"179","endLine":170,"endColumn":8},{"ruleId":"172","severity":1,"message":"173","line":231,"column":19,"nodeType":"174","messageId":"175","endLine":231,"endColumn":21},{"ruleId":"172","severity":1,"message":"173","line":238,"column":24,"nodeType":"174","messageId":"175","endLine":238,"endColumn":26},{"ruleId":"180","severity":1,"message":"181","line":241,"column":11,"nodeType":"169","messageId":"182","endLine":241,"endColumn":17},{"ruleId":"172","severity":1,"message":"173","line":245,"column":24,"nodeType":"174","messageId":"175","endLine":245,"endColumn":26},{"ruleId":"180","severity":1,"message":"181","line":248,"column":11,"nodeType":"169","messageId":"182","endLine":248,"endColumn":17},{"ruleId":"172","severity":1,"message":"173","line":251,"column":26,"nodeType":"174","messageId":"175","endLine":251,"endColumn":28},{"ruleId":"180","severity":1,"message":"181","line":258,"column":11,"nodeType":"169","messageId":"182","endLine":258,"endColumn":17},{"ruleId":"172","severity":1,"message":"173","line":283,"column":23,"nodeType":"174","messageId":"175","endLine":283,"endColumn":25},{"ruleId":"172","severity":1,"message":"173","line":292,"column":28,"nodeType":"174","messageId":"175","endLine":292,"endColumn":30},{"ruleId":"180","severity":1,"message":"183","line":293,"column":11,"nodeType":"169","messageId":"182","endLine":293,"endColumn":18},{"ruleId":"180","severity":1,"message":"184","line":294,"column":16,"nodeType":"169","messageId":"182","endLine":294,"endColumn":17},{"ruleId":"172","severity":1,"message":"173","line":301,"column":28,"nodeType":"174","messageId":"175","endLine":301,"endColumn":30},{"ruleId":"180","severity":1,"message":"183","line":304,"column":11,"nodeType":"169","messageId":"182","endLine":304,"endColumn":18},{"ruleId":"180","severity":1,"message":"184","line":305,"column":16,"nodeType":"169","messageId":"182","endLine":305,"endColumn":17},{"ruleId":"172","severity":1,"message":"173","line":312,"column":28,"nodeType":"174","messageId":"175","endLine":312,"endColumn":30},{"ruleId":"180","severity":1,"message":"183","line":313,"column":11,"nodeType":"169","messageId":"182","endLine":313,"endColumn":18},{"ruleId":"180","severity":1,"message":"184","line":314,"column":16,"nodeType":"169","messageId":"182","endLine":314,"endColumn":17},{"ruleId":"172","severity":1,"message":"173","line":321,"column":28,"nodeType":"174","messageId":"175","endLine":321,"endColumn":30},{"ruleId":"180","severity":1,"message":"183","line":325,"column":11,"nodeType":"169","messageId":"182","endLine":325,"endColumn":18},{"ruleId":"180","severity":1,"message":"184","line":326,"column":15,"nodeType":"169","messageId":"182","endLine":326,"endColumn":16},{"ruleId":"172","severity":1,"message":"173","line":338,"column":23,"nodeType":"174","messageId":"175","endLine":338,"endColumn":25},{"ruleId":"185","severity":1,"message":"186","line":355,"column":6,"nodeType":"187","endLine":355,"endColumn":21,"suggestions":"188"},{"ruleId":"172","severity":1,"message":"173","line":399,"column":73,"nodeType":"174","messageId":"175","endLine":399,"endColumn":75},{"ruleId":"172","severity":1,"message":"189","line":454,"column":28,"nodeType":"174","messageId":"175","endLine":454,"endColumn":30},{"ruleId":"172","severity":1,"message":"173","line":524,"column":25,"nodeType":"174","messageId":"175","endLine":524,"endColumn":27},{"ruleId":"172","severity":1,"message":"173","line":28,"column":24,"nodeType":"174","messageId":"175","endLine":28,"endColumn":26},{"ruleId":"172","severity":1,"message":"173","line":28,"column":48,"nodeType":"174","messageId":"175","endLine":28,"endColumn":50},{"ruleId":"172","severity":1,"message":"173","line":31,"column":29,"nodeType":"174","messageId":"175","endLine":31,"endColumn":31},{"ruleId":"172","severity":1,"message":"173","line":31,"column":54,"nodeType":"174","messageId":"175","endLine":31,"endColumn":56},{"ruleId":"172","severity":1,"message":"173","line":38,"column":31,"nodeType":"174","messageId":"175","endLine":38,"endColumn":33},{"ruleId":"172","severity":1,"message":"173","line":43,"column":24,"nodeType":"174","messageId":"175","endLine":43,"endColumn":26},{"ruleId":"172","severity":1,"message":"173","line":4,"column":13,"nodeType":"174","messageId":"175","endLine":4,"endColumn":15},{"ruleId":"172","severity":1,"message":"173","line":11,"column":19,"nodeType":"174","messageId":"175","endLine":11,"endColumn":21},{"ruleId":"172","severity":1,"message":"189","line":26,"column":24,"nodeType":"174","messageId":"175","endLine":26,"endColumn":26},{"ruleId":"172","severity":1,"message":"189","line":26,"column":50,"nodeType":"174","messageId":"175","endLine":26,"endColumn":52},{"ruleId":"172","severity":1,"message":"189","line":27,"column":27,"nodeType":"174","messageId":"175","endLine":27,"endColumn":29},{"ruleId":"172","severity":1,"message":"189","line":27,"column":55,"nodeType":"174","messageId":"175","endLine":27,"endColumn":57},{"ruleId":"172","severity":1,"message":"189","line":27,"column":87,"nodeType":"174","messageId":"175","endLine":27,"endColumn":89},{"ruleId":"172","severity":1,"message":"189","line":27,"column":118,"nodeType":"174","messageId":"175","endLine":27,"endColumn":120},{"ruleId":"180","severity":1,"message":"190","line":54,"column":13,"nodeType":"169","messageId":"182","endLine":54,"endColumn":27},{"ruleId":"180","severity":1,"message":"191","line":55,"column":13,"nodeType":"169","messageId":"182","endLine":55,"endColumn":27},{"ruleId":"172","severity":1,"message":"189","line":58,"column":22,"nodeType":"174","messageId":"175","endLine":58,"endColumn":24},{"ruleId":"172","severity":1,"message":"189","line":58,"column":49,"nodeType":"174","messageId":"175","endLine":58,"endColumn":51},{"ruleId":"172","severity":1,"message":"189","line":59,"column":26,"nodeType":"174","messageId":"175","endLine":59,"endColumn":28},{"ruleId":"172","severity":1,"message":"189","line":59,"column":55,"nodeType":"174","messageId":"175","endLine":59,"endColumn":57},{"ruleId":"172","severity":1,"message":"189","line":59,"column":86,"nodeType":"174","messageId":"175","endLine":59,"endColumn":88},{"ruleId":"172","severity":1,"message":"189","line":59,"column":118,"nodeType":"174","messageId":"175","endLine":59,"endColumn":120},{"ruleId":"172","severity":1,"message":"173","line":8,"column":24,"nodeType":"174","messageId":"175","endLine":8,"endColumn":26},{"ruleId":"172","severity":1,"message":"173","line":8,"column":48,"nodeType":"174","messageId":"175","endLine":8,"endColumn":50},{"ruleId":"172","severity":1,"message":"173","line":11,"column":29,"nodeType":"174","messageId":"175","endLine":11,"endColumn":31},{"ruleId":"172","severity":1,"message":"173","line":11,"column":54,"nodeType":"174","messageId":"175","endLine":11,"endColumn":56},{"ruleId":"172","severity":1,"message":"173","line":6,"column":20,"nodeType":"174","messageId":"175","endLine":6,"endColumn":22},{"ruleId":"172","severity":1,"message":"173","line":6,"column":47,"nodeType":"174","messageId":"175","endLine":6,"endColumn":49},{"ruleId":"172","severity":1,"message":"173","line":18,"column":20,"nodeType":"174","messageId":"175","endLine":18,"endColumn":22},{"ruleId":"172","severity":1,"message":"173","line":18,"column":47,"nodeType":"174","messageId":"175","endLine":18,"endColumn":49},{"ruleId":"172","severity":1,"message":"173","line":12,"column":28,"nodeType":"174","messageId":"175","endLine":12,"endColumn":30},{"ruleId":"172","severity":1,"message":"173","line":12,"column":55,"nodeType":"174","messageId":"175","endLine":12,"endColumn":57},{"ruleId":"172","severity":1,"message":"173","line":16,"column":32,"nodeType":"174","messageId":"175","endLine":16,"endColumn":34},{"ruleId":"172","severity":1,"message":"173","line":16,"column":59,"nodeType":"174","messageId":"175","endLine":16,"endColumn":61},{"ruleId":"172","severity":1,"message":"173","line":22,"column":40,"nodeType":"174","messageId":"175","endLine":22,"endColumn":42},{"ruleId":"172","severity":1,"message":"173","line":26,"column":31,"nodeType":"174","messageId":"175","endLine":26,"endColumn":33},{"ruleId":"180","severity":1,"message":"184","line":33,"column":14,"nodeType":"169","messageId":"182","endLine":33,"endColumn":15},{"ruleId":"180","severity":1,"message":"192","line":34,"column":18,"nodeType":"169","messageId":"182","endLine":34,"endColumn":19},{"ruleId":"172","severity":1,"message":"173","line":35,"column":28,"nodeType":"174","messageId":"175","endLine":35,"endColumn":30},{"ruleId":"172","severity":1,"message":"173","line":35,"column":55,"nodeType":"174","messageId":"175","endLine":35,"endColumn":57},{"ruleId":"180","severity":1,"message":"184","line":43,"column":14,"nodeType":"169","messageId":"182","endLine":43,"endColumn":15},{"ruleId":"180","severity":1,"message":"192","line":44,"column":18,"nodeType":"169","messageId":"182","endLine":44,"endColumn":19},{"ruleId":"172","severity":1,"message":"173","line":45,"column":28,"nodeType":"174","messageId":"175","endLine":45,"endColumn":30},{"ruleId":"172","severity":1,"message":"173","line":45,"column":55,"nodeType":"174","messageId":"175","endLine":45,"endColumn":57},{"ruleId":"172","severity":1,"message":"173","line":2,"column":19,"nodeType":"174","messageId":"175","endLine":2,"endColumn":21},{"ruleId":"172","severity":1,"message":"173","line":85,"column":19,"nodeType":"174","messageId":"175","endLine":85,"endColumn":21},{"ruleId":"172","severity":1,"message":"173","line":2,"column":19,"nodeType":"174","messageId":"175","endLine":2,"endColumn":21},{"ruleId":"167","severity":1,"message":"193","line":18,"column":13,"nodeType":"169","messageId":"170","endLine":18,"endColumn":18},{"ruleId":"172","severity":1,"message":"173","line":85,"column":19,"nodeType":"174","messageId":"175","endLine":85,"endColumn":21},{"ruleId":"172","severity":1,"message":"173","line":16,"column":16,"nodeType":"174","messageId":"175","endLine":16,"endColumn":18},{"ruleId":"172","severity":1,"message":"173","line":76,"column":14,"nodeType":"174","messageId":"175","endLine":76,"endColumn":16},{"ruleId":"172","severity":1,"message":"173","line":16,"column":22,"nodeType":"174","messageId":"175","endLine":16,"endColumn":24},{"ruleId":"172","severity":1,"message":"173","line":76,"column":18,"nodeType":"174","messageId":"175","endLine":76,"endColumn":20},{"ruleId":"172","severity":1,"message":"189","line":24,"column":16,"nodeType":"174","messageId":"175","endLine":24,"endColumn":18},"no-native-reassign",["194"],"no-negated-in-lhs",["195"],"no-unused-vars","'isActive' is assigned a value but never used.","Identifier","unusedVar","'isPaused' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'START_NODE_ROW', 'START_NODE_COL', 'FINISH_NODE_ROW', 'FINISH_NODE_COL'.","ArrowFunctionExpression","unsafeRefs","no-redeclare","'start2' is already defined.","redeclared","'griddef' is already defined.","'i' is already defined.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'demoMazeAlgorithm'. Either include it or remove the dependency array.","ArrayExpression",["196"],"Expected '!==' and instead saw '!='.","'randomRowIndex' is already defined.","'randomColIndex' is already defined.","'j' is already defined.","'count' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"197","fix":"198"},"Update the dependencies array to be: [demoMazeAlgorithm, mazeAlgorithm]",{"range":"199","text":"200"},[13192,13207],"[demoMazeAlgorithm, mazeAlgorithm]"]