[{"C:\\Users\\kadam\\react\\Visualization\\src\\index.js":"1","C:\\Users\\kadam\\react\\Visualization\\src\\App.js":"2","C:\\Users\\kadam\\react\\Visualization\\src\\visualizers\\PathfindingVisualizer.jsx":"3","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\basicWeighted.js":"4","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\Simplestair.js":"5","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\basicRandom.js":"6","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\BFS.js":"7","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\DFS.js":"8","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\dijkstra.js":"9","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\Astar.js":"10","C:\\Users\\kadam\\react\\Visualization\\src\\models\\Node\\Node.jsx":"11","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\recursive.js":"12","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\Snakemaze.js":"13"},{"size":174,"mtime":1616938834922,"results":"14","hashOfConfig":"15"},{"size":281,"mtime":1616930096196,"results":"16","hashOfConfig":"15"},{"size":17078,"mtime":1617963059971,"results":"17","hashOfConfig":"15"},{"size":662,"mtime":1617035130523,"results":"18","hashOfConfig":"15"},{"size":592,"mtime":1617034610184,"results":"19","hashOfConfig":"15"},{"size":1406,"mtime":1617035113851,"results":"20","hashOfConfig":"15"},{"size":3428,"mtime":1617179302629,"results":"21","hashOfConfig":"15"},{"size":3309,"mtime":1617962500493,"results":"22","hashOfConfig":"15"},{"size":3243,"mtime":1617179302632,"results":"23","hashOfConfig":"15"},{"size":3732,"mtime":1617603875766,"results":"24","hashOfConfig":"15"},{"size":780,"mtime":1617007082949,"results":"25","hashOfConfig":"15"},{"size":1512,"mtime":1617621269340,"results":"26","hashOfConfig":"15"},{"size":1745,"mtime":1617952414769,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"triyp6",{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":23,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"30"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"30"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"30"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"30"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"30"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"30"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"30"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62","usedDeprecatedRules":"30"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"65","usedDeprecatedRules":"30"},"C:\\Users\\kadam\\react\\Visualization\\src\\index.js",[],["66","67"],"C:\\Users\\kadam\\react\\Visualization\\src\\App.js",[],"C:\\Users\\kadam\\react\\Visualization\\src\\visualizers\\PathfindingVisualizer.jsx",["68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90"],"import React, {useEffect ,useState, useRef} from 'react';\r\nimport dijkstra,{getNodesInShortestPathOrderDijkstra} from '../algorithms/dijkstra';\r\nimport BFS,{getNodesInShortestPathOrderBFS} from '../algorithms/BFS';\r\nimport DFS,{getNodesInShortestPathOrderDFS} from '../algorithms/DFS';\r\nimport AStar,{getNodesInShortestPathOrderAStar} from '../algorithms/Astar';\r\nimport {Nav, Navbar, Button, NavDropdown, Toast} from 'react-bootstrap';\r\nimport Node from '../models/Node/Node';\r\nimport './PathfindingVisualizer.css'; \r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport  basicRandom from '../mazeAlgorithms/basicRandom.js';\r\nimport  basicWeighted from '../mazeAlgorithms/basicWeighted.js';\r\nimport  Simplestair from '../mazeAlgorithms/Simplestair.js';\r\nimport recursive from '../mazeAlgorithms/recursive.js';\r\nimport Snake from '../mazeAlgorithms/Snakemaze';\r\n\r\nvar START_NODE_ROW = 10;\r\nvar START_NODE_COL = 10;\r\nvar FINISH_NODE_ROW = 8;\r\nvar FINISH_NODE_COL = 39;\r\n\r\nconst NODE_WEIGHT =10;\r\n\r\nconst PathfindingVisualizer = () => {\r\n  const [grid, setGrid] = useState([]);\r\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\r\n  const [timer, setTimer] = useState(0);\r\n  const [isActive, setIsActive] = useState(false);\r\n  const [isPaused, setIsPaused] = useState(false);\r\n  const [noOfCellVisited, setNoOfCellVisited] = useState(0);\r\n  const [totalcost, settotalcost] = useState(0);\r\n  const [algorithm, setAlgorithm] = useState(\"Choose Algorithm\");\r\n  const [mazeAlgorithm , setmazeAlgorithm ]=useState(\"Choose Maze Algorithm\");\r\n  const [show, setShow] = useState(false);\r\n  const [isAddWeight, setIsAddWeight] = useState(false);\r\n  const [isStartNode, setIsStartNode] = useState(false);\r\n  const [isEndNode, setIsEndNode] = useState(false);\r\n  const countRef = useRef(null)\r\n\r\n\r\n  const handleStart = () => {\r\n    setIsActive(true);\r\n    setIsPaused(true);\r\n    countRef.current = setInterval(() => {\r\n      setTimer((timer) => timer + 1);\r\n    }, 1000);\r\n  }\r\n\r\n  const handlePause = () => {\r\n    clearInterval(countRef.current);\r\n    setIsPaused(false);\r\n  }\r\n\r\n  const handleReset = () => {\r\n    clearInterval(countRef.current);\r\n    setIsActive(false);\r\n    setIsPaused(false);\r\n    setTimer(0);\r\n  }\r\n\r\n  const formatTime = () => {\r\n    const getSeconds = `0${(timer % 60)}`.slice(-2)\r\n    const minutes = `${Math.floor(timer / 60)}`\r\n    const getMinutes = `0${minutes % 60}`.slice(-2)\r\n    const getHours = `0${Math.floor(timer / 3600)}`.slice(-2)\r\n\r\n    return `${getHours} : ${getMinutes} : ${getSeconds}`\r\n  }\r\n\r\n  useEffect(()=>{\r\n    console.log('component mounted');\r\n    const grid = getInitialGrid();\r\n    setGrid(grid);\r\n  },[])\r\n  const movestart= (grid, row, col,isStartNode,isEndNode) => {\r\n    const newGrid = grid.slice();\r\n    if(isStartNode){\r\n      newGrid[START_NODE_ROW][START_NODE_COL].isStart=false;\r\n    }else if(isEndNode){\r\n      newGrid[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish=false;\r\n    }\r\n    \r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isStart: isStartNode,\r\n        isFinish: isEndNode,\r\n        isWall:false,\r\n        weight:0,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    if(isStartNode){\r\n      START_NODE_ROW = newNode.row;\r\n      START_NODE_COL = newNode.col;\r\n    }else if(isEndNode){\r\n      FINISH_NODE_ROW = newNode.row;\r\n      FINISH_NODE_COL = newNode.col;\r\n    }\r\n    \r\n    return newGrid;\r\n  }\r\n  const handleMouseDown = (row, col) => {\r\n    const newGrid = getNewGridWithWallToggled(grid, row, col, isAddWeight,isStartNode,isEndNode);\r\n    setGrid(newGrid);\r\n    setMouseIsPressed(true);\r\n  }\r\n\r\n  const handleMouseEnter = (row, col) => {\r\n    if (!mouseIsPressed) return;\r\n    var newGrid;\r\n    if(isStartNode || isEndNode){\r\n      newGrid=movestart(grid, row, col,isStartNode,isEndNode);\r\n    }else{\r\n      newGrid = getNewGridWithWallToggled(grid, row, col, isAddWeight,isStartNode,isEndNode);\r\n    }\r\n    setGrid(newGrid);\r\n  }\r\n\r\n  const handleMouseUp = (row,col) => {\r\n    setMouseIsPressed(false);\r\n  }\r\n\r\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-visited';\r\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  const animateShortestPath = (nodesInShortestPathOrder) =>  {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        if(node.weight === NODE_WEIGHT){\r\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-weight-in-path';\r\n        }\r\n        else{\r\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\r\n        }\r\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish'; \r\n      }, 50 * i);\r\n    }\r\n    handlePause();\r\n  }\r\n\r\n  const visualizeAlgorithm = () => {\r\n    handleStart();\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let visitedNodesInOrder, nodesInShortestPathOrder;\r\n    if(algorithm == \"Dijkstra\"){\r\n      visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n      nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(finishNode,startNode);\r\n    }\r\n    else if(algorithm == \"BFS\"){\r\n      visitedNodesInOrder = BFS(grid, startNode, finishNode);\r\n      nodesInShortestPathOrder = getNodesInShortestPathOrderBFS(finishNode,startNode);\r\n    }\r\n    else if(algorithm == \"DFS\"){\r\n      visitedNodesInOrder = DFS(grid, startNode, finishNode);\r\n      nodesInShortestPathOrder = getNodesInShortestPathOrderDFS(finishNode,startNode);\r\n    }else if(algorithm == \"AStar\"){\r\n      visitedNodesInOrder = AStar(grid, startNode, finishNode);\r\n      nodesInShortestPathOrder = getNodesInShortestPathOrderAStar(finishNode,startNode);\r\n    }\r\n    else{\r\n      setShow(true);\r\n      handlePause();\r\n      return;\r\n    }\r\n    settotalcost(finishNode.distance);\r\n    animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    setNoOfCellVisited(nodesInShortestPathOrder.length);\r\n  }\r\n\r\n  const clearBoard = () => {\r\n    handleReset();\r\n    setGrid(getInitialGrid());\r\n    setNoOfCellVisited(0);\r\n    settotalcost(0);\r\n    clearGrid();\r\n    // setAlgorithm(\"Choose Algorithm\");\r\n    // setmazeAlgorithm(\"Choose Maze Algorithm\");\r\n    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n    document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n  }\r\n\r\n  const clearVisualization = () => {\r\n    handleReset();\r\n    setNoOfCellVisited(0);\r\n    settotalcost(0);\r\n    clearGrid();\r\n    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n    document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n  }\r\n\r\n  const demoMazeAlgorithm=()=>{\r\n    if(mazeAlgorithm === \"Choose Maze Algorithm\") return;\r\n    clearBoard();\r\n    clearGrid();\r\n    console.log(mazeAlgorithm);\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    if(mazeAlgorithm==\"Basic Random Maze\")\r\n    {\r\n      var griddef=basicRandom(grid,startNode, finishNode);\r\n      for(var i=0;i<griddef.length;i++)\r\n      {\r\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n        'node node-wall';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col, isAddWeight);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n    else if(mazeAlgorithm==\"Basic Weight Maze\")\r\n    {\r\n        var griddef=basicWeighted(grid,startNode, finishNode);\r\n        for(var i=0;i<griddef.length;i++)\r\n        {\r\n          document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-weight';\r\n          const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\r\n          setGrid(newGrid);\r\n        }\r\n    }\r\n    else if(mazeAlgorithm==\"Snake Maze\")\r\n    {\r\n      // recursive(grid,0,grid.length-1,0,grid.length-1,startNode,finishNode);\r\n      Snake(grid,startNode,finishNode);\r\n        var griddef= Snake(grid,startNode,finishNode);\r\n        for(var i=0;i<griddef.length;i++)\r\n        {\r\n          document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-weight';\r\n          const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\r\n          setGrid(newGrid);\r\n        }\r\n    }\r\n    else if(mazeAlgorithm==\"Simple Stair Pattern\")\r\n    {\r\n        var griddef=Simplestair(grid,startNode, finishNode);\r\n        for(var i=0;i<griddef.length;i++)\r\n        {\r\n          document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-weight';\r\n          const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\r\n          setGrid(newGrid);\r\n        }\r\n    }\r\n    else if(mazeAlgorithm==\"Recursive Division\")\r\n    {\r\n      // recursive(grid,0,grid.length-1,0,grid.length-1,startNode,finishNode);\r\n      // Snake(grid,startNode,finishNode);\r\n        // var griddef= Snake(grid,startNode,finishNode);\r\n        // for(var i=0;i<griddef.length;i++)\r\n        // {\r\n        //   document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n        //   'node node-weight';\r\n        //   const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\r\n        //   setGrid(newGrid);\r\n        // }\r\n    }\r\n  }\r\n\r\n  \r\n\r\n  const clearGrid = () => {\r\n      const newGrid = grid;\r\n      for (const row of newGrid) {\r\n        for (const node of row) {\r\n          let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`,).className;\r\n          if( nodeClassName !== 'node node-start' && \r\n              nodeClassName !== 'node node-finish' && \r\n              nodeClassName !== 'node node-wall') {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node';\r\n          }\r\n        }\r\n      }\r\n  }\r\n\r\n  const addWeights = () => {\r\n    setIsAddWeight(!isAddWeight);\r\n  }\r\n\r\nconst setStartNode =() => {\r\n  setIsStartNode(!isStartNode);\r\n}\r\nconst setEndNode =() => {\r\n  setIsEndNode(!isEndNode);\r\n}\r\n  useEffect(() => {\r\n    demoMazeAlgorithm();\r\n  },[mazeAlgorithm]);\r\n\r\n  return (\r\n    <>\r\n      <Navbar bg=\"light\" variant=\"light\">\r\n        <div className=\"container\">\r\n        <Navbar.Brand href=\"#home\">Path Visualization</Navbar.Brand>\r\n        <Nav className=\"mr-auto\">\r\n          <NavDropdown title={algorithm} id=\"basic-nav-dropdown\">\r\n            <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"Dijkstra\")}>Dijkstra</NavDropdown.Item>\r\n            <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"BFS\")}>BFS</NavDropdown.Item>\r\n            <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"DFS\")}>DFS</NavDropdown.Item>\r\n            <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"AStar\")}>AStar</NavDropdown.Item>\r\n          </NavDropdown>\r\n          <NavDropdown title={mazeAlgorithm} id=\"basic-nav-dropdown\">\r\n            <NavDropdown.Item href=\"\" onClick={() => {\r\n              setmazeAlgorithm(\"Basic Random Maze\");\r\n            }}>Basic Random Maze</NavDropdown.Item>\r\n            <NavDropdown.Item href=\"\" onClick={() => {\r\n              setmazeAlgorithm(\"Basic Weight Maze\");\r\n            }}>Basic Weight Maze</NavDropdown.Item>\r\n            <NavDropdown.Item href=\"\" onClick={() => {\r\n              setmazeAlgorithm(\"Simple Stair Pattern\");\r\n            }}>Simple Stair Pattern</NavDropdown.Item>\r\n            <NavDropdown.Item href=\"\" onClick={() => {\r\n              setmazeAlgorithm(\"Snake Maze\");\r\n            }}>Snake Maze</NavDropdown.Item>\r\n            <NavDropdown.Item href=\"\" onClick={() => {\r\n              setmazeAlgorithm(\"Recursive Division\");\r\n            }}>Recursive Division</NavDropdown.Item>\r\n          </NavDropdown>\r\n        </Nav>\r\n        <div>\r\n\r\n        <Toast onClose={() => setShow(false)} show={show} delay={3000} autohide \r\n          style={{\r\n            position: 'absolute',\r\n            top: 0,\r\n            right: \"50%\",\r\n          }}>\r\n          <Toast.Header>\r\n            <strong className=\"mr-auto\">First Choose Algorithm</strong>\r\n          </Toast.Header>\r\n        </Toast>\r\n        <Toast onClose={() => clearVisualization()} show={totalcost == Infinity} delay={3000} \r\n          style={{\r\n            position: 'absolute',\r\n            top: 0,\r\n            right: \"50%\",\r\n          }}>\r\n          <Toast.Header>\r\n            <strong className=\"mr-auto\">No Path Found</strong>\r\n          </Toast.Header>\r\n        </Toast>\r\n        </div>\r\n        <div className=\"m\">\r\n          <span className=\"pBtn\">\r\n            <Button variant=\"success\" size=\"sm\" onClick={() => setStartNode()}>\r\n              {isStartNode ? \"Setting StartNode\" : \"Set StartNode\"}\r\n            </Button>\r\n          </span>\r\n          <span className=\"pBtn\">\r\n            <Button variant=\"success\" size=\"sm\" onClick={() => setEndNode()}>\r\n              {isEndNode ? \"Setting EndNode\" : \"Set EndNode\"}\r\n            </Button>\r\n          </span>\r\n          <span className=\"pBtn\">\r\n            <Button variant=\"success\" size=\"sm\" onClick={() => addWeights()}>\r\n              {isAddWeight ? \"Adding Weights\" : \"Add Weights\"}\r\n            </Button>\r\n          </span>\r\n          <span className=\"pBtn\">\r\n            <Button variant=\"secondary\" size=\"sm\" onClick={() => clearBoard()}>Clear Board</Button>\r\n          </span>\r\n          <span className=\"pBtn\">\r\n            <Button variant=\"secondary\" size=\"sm\" onClick={() => clearVisualization()}>Clear Visualization</Button>\r\n          </span>\r\n          <Button variant=\"primary\" onClick={() => visualizeAlgorithm()}>Start</Button>\r\n        </div>\r\n        </div>        \r\n      </Navbar>\r\n      <span className=\"pText\">Timer</span>\r\n      <span className=\"timeBox\">{formatTime()}</span>\r\n      <span className=\"pText\">No. of Cells Visited</span>\r\n      <span className=\"timeBox\">{noOfCellVisited}</span>\r\n      <span className=\"pText\">Total Cost</span>\r\n      <span className=\"timeBox\">{totalcost}</span>\r\n      <div className=\"grid\">\r\n        {grid.map((row, rowIdx) => {\r\n          return (\r\n            <div key={rowIdx}>\r\n              {row.map((node, nodeIdx) => {\r\n                const {row, col, isFinish, isStart, isWall, weight} = node;\r\n                return (\r\n                  <Node\r\n                    key={nodeIdx}\r\n                    col={col}\r\n                    isFinish={isFinish}\r\n                    isStart={isStart}\r\n                    isWall={isWall}\r\n                    mouseIsPressed={mouseIsPressed}\r\n                    weight={weight}\r\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\r\n                    onMouseEnter={(row, col) =>\r\n                      handleMouseEnter(row, col)\r\n                    }\r\n                    onMouseUp={() => handleMouseUp()}\r\n                    row={row}></Node>\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\n\r\n\r\nconst getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 20; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < 50; col++) {\r\n        currentRow.push(createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n    return {\r\n        col,\r\n        row,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        previousNode: null,\r\n        weight: 0,\r\n    };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col, isAddWeight,isStartNode,isEndNode) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: (isAddWeight || isStartNode || isEndNode) ? false : !node.isWall,\r\n        weight: node.weight==0 && isAddWeight ? NODE_WEIGHT : 0,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\n  \r\n\r\nexport default PathfindingVisualizer;\r\n","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\basicWeighted.js",["91","92","93","94"],"function basicWeighted(grid,startNode, finishNode){\r\n    var grid1=[]\r\n    for(var i=0 ; i<20;i+=3)\r\n    {\r\n         for (var j=0 ;j<50;j+=3)\r\n         {\r\n              var x=Math.floor((Math.random() * 10) + 1);\r\n              var col=Math.abs(i-x);\r\n              var row=Math.abs(j-x);\r\n              if(col==startNode.col && row==startNode.row)\r\n              {\r\n                   continue;\r\n              }\r\n              else if(col==finishNode.col && row==finishNode.row)\r\n              {\r\n                   continue;\r\n              }\r\n              grid1.push(grid[col][row]);\r\n         }\r\n    }\r\n    return grid1;\r\n}\r\n\r\n\r\nexport default basicWeighted;","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\Simplestair.js",["95","96","97","98"],"function Simplestair(grid,startNode, finishNode)\r\n{\r\nvar grid1=[];\r\n  let  x=grid.length;\r\n  let y=0;\r\n  while(x<2*(grid.length)-1 && y<grid.length-4){\r\n    if(grid[y][x]==startNode || grid[y][x]==finishNode){\r\n        continue;\r\n    }\r\n    else{\r\n        grid1.push(grid[y][x]);\r\n    }\r\n    x++;\r\n    y++;\r\n    };\r\n    x=grid.length-1;\r\n    y=0;\r\n  while(x>=0 && y<grid.length){\r\n    if(grid[y][x]==startNode || grid[y][x]==finishNode){\r\n        continue;\r\n    }\r\n    else{\r\n        grid1.push(grid[y][x]);\r\n    }\r\n    x--;\r\n    y++;\r\n  };\r\n  return grid1;\r\n}\r\n\r\nexport default Simplestair; ","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\basicRandom.js",["99","100","101","102"],"function basicRandom(grid,startNode, finishNode){\r\n     var grid1=[]\r\n     // let cIdY=grid.length[0]-10;\r\n     // for(let c=0 ;c<10;c++)\r\n     // {\r\n     //      let cIdXone= Math.floor(grid.length/2)-c;\r\n     //      let cIdXtwo = Math.floor(grid.length/2)+c;\r\n     //      // let cIdone = cIdY-cIdXone;\r\n     //      // let cIdtwo = cIdY-cIdXtwo;\r\n     //      console.log(cIdXone);\r\n     //      console.log(cIdXtwo);\r\n     //      // console.log((cIdY,cIdtwo));\r\n     //      if(cIdy>=20 || CIdXone>=50 || cIdXtwo>=50){\r\n     //           continue;\r\n     //      }\r\n     //      else{\r\n     //           grid1.push(grid[cIdY][cIdXone]);\r\n     //           grid1.push(grid[cIdY][cIdXtwo]);\r\n     //      }\r\n     //      // console.log(cIdone);\r\n     //      // console.log(cIdtwo);\r\n     // }\r\n     for(var i=0 ; i<20;i+=3)\r\n     {\r\n          for (var j=0 ;j<50;j+=3)\r\n          {\r\n               var x=Math.floor((Math.random() * 10) + 1);\r\n               var col=Math.abs(i-x);\r\n               var row=Math.abs(j-x);\r\n               if(col==startNode.col && row==startNode.row)\r\n               {\r\n                    continue;\r\n               }\r\n               else if(col==finishNode.col && row==finishNode.row)\r\n               {\r\n                    continue;\r\n               }\r\n               grid1.push(grid[col][row]);\r\n          }\r\n     }\r\n     return grid1;\r\n}\r\n\r\n\r\nexport default basicRandom;","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\BFS.js",["103","104"],"\r\nexport default function BFS(grid,startNode, finishNode){\r\n    if(startNode==finishNode || !startNode || !finishNode){\r\n        return false;\r\n    }\r\n    console.log(\"in BFS\");\r\n    var count=0;\r\n    startNode.distance=0;\r\n    const visited=new Map();\r\n    const visitedinorder=[];\r\n    const visitList=[];\r\n    visitList.push(startNode)\r\n    const graph=creategraph(grid);\r\n    while(visitList.length!==0)\r\n    {\r\n        const node =visitList.shift();\r\n        if(node && !visited.has(node))\r\n        {\r\n            if (node.isWall) continue;\r\n            visitedinorder.push(node);\r\n            count++;\r\n            visited.set(node);\r\n            console.log(\"visited\");\r\n            console.log(node.row);\r\n            console.log(node.col);\r\n            if(node===finishNode){\r\n                console.log(\"count\",count);\r\n                return visitedinorder;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList,node,graph);\r\n        }\r\n    }\r\n    return visitedinorder;\r\n\r\n}\r\n\r\n\r\n\r\nfunction creategraph(grid){\r\n    const graph=new Graph(1000);\r\n    for(let row=0;row<20;row++)\r\n    {\r\n        for(let col=0;col<50;col++)\r\n        {\r\n            graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for(let row=0;row<20;row++)\r\n    {\r\n        for(let col=0;col<50;col++)\r\n        {\r\n            if((col+1<50)){\r\n                graph.addEdge(grid[row][col],grid[row][col+1]);\r\n            }\r\n            if((col-1>=0)){\r\n                graph.addEdge(grid[row][col],grid[row][col-1]);\r\n            }\r\n            if((row-1)>=0){\r\n                graph.addEdge(grid[row][col],grid[row-1][col]);\r\n            }\r\n            if((row+1)<20){\r\n                graph.addEdge(grid[row][col],grid[row+1][col]);\r\n            }\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n\r\n\r\nclass Graph{\r\n  constructor(noOfVertices){\r\n      this.noOfVertices=noOfVertices;\r\n      this.Adjlist=new Map();\r\n  }  \r\n\r\n  addVertex(v){\r\n    this.Adjlist.set(v,[]);\r\n  }\r\n\r\n  addEdge(v,w){\r\n     this.Adjlist.get(v).push(w);\r\n  }\r\n\r\n  getAdjacents(node){\r\n      return this.Adjlist.get(node);\r\n  }\r\n\r\n  isAdjacent(node,neighbor) {\r\n    var temp=0;\r\n    this.Adjlist.get(neighbor).forEach( x => {\r\n        if(x==node){\r\n            temp++;\r\n        }\r\n    })\r\n    if(temp===0){\r\n        return false;\r\n    }else{\r\n        return true;\r\n    }\r\n}\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList,node,graph) {\r\n    console.log(\"neigbour\");\r\n    for (const neighbor of visitList) {\r\n        if(!graph.isAdjacent(node,neighbor) || neighbor.previousNode !== null){\r\n            continue;\r\n        }else if(graph.isAdjacent(node,neighbor)){\r\n            neighbor.distance = node.distance + neighbor.weight + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n  }\r\n\r\nexport function getNodesInShortestPathOrderBFS(finishNode,startNode) {\r\n    console.log(\"shortest Path\");\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      console.log(currentNode.row);\r\n      console.log(currentNode.col);\r\n      currentNode = currentNode.previousNode;\r\n      if(currentNode===startNode){\r\n          console.log(currentNode.row);\r\n          console.log(currentNode.col);\r\n          break;\r\n      }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\DFS.js",["105","106"],"\r\nexport default function DFS(grid,startNode, finishNode){\r\n    if(startNode==finishNode || !startNode || !finishNode){\r\n        return false;\r\n    }\r\n    console.log(\"in DFS\");\r\n    var count=0;\r\n    startNode.distance=0;\r\n    const visited=new Map();\r\n    const visitedinorder=[];\r\n    const visitList=[];\r\n    visitList.push(startNode)\r\n    const graph=creategraph(grid);\r\n    while(visitList.length!==0)\r\n    {\r\n        const node =visitList.pop();\r\n        if(node && !visited.has(node))\r\n        {\r\n            if (node.isWall) continue;\r\n            visitedinorder.push(node);\r\n            count++;\r\n            visited.set(node);\r\n            console.log(\"visited\");\r\n            console.log(node.row);\r\n            console.log(node.col);\r\n            if(node===finishNode){\r\n                console.log(\"count\",count);\r\n                return visitedinorder;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList,node,graph);\r\n        }\r\n    }\r\n    return visitedinorder;\r\n\r\n}\r\n\r\n\r\n\r\nfunction creategraph(grid){\r\n    const graph=new Graph(1000);\r\n    for(let row=0;row<20;row++)\r\n    {\r\n        for(let col=0;col<50;col++)\r\n        {\r\n            graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for(let row=0;row<20;row++)\r\n    {\r\n        for(let col=0;col<50;col++)\r\n        {\r\n            if((row+1)<20){\r\n                graph.addEdge(grid[row][col],grid[row+1][col]);\r\n            }\r\n            if((col-1>=0)){\r\n                graph.addEdge(grid[row][col],grid[row][col-1]);\r\n            }\r\n            if((col+1<50)){\r\n                graph.addEdge(grid[row][col],grid[row][col+1]);\r\n            }\r\n            if((row-1)>=0){\r\n                graph.addEdge(grid[row][col],grid[row-1][col]);\r\n            }\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n\r\n\r\nclass Graph{\r\n  constructor(noOfVertices){\r\n      this.noOfVertices=noOfVertices;\r\n      this.Adjlist=new Map();\r\n  }  \r\n\r\n  addVertex(v){\r\n    this.Adjlist.set(v,[]);\r\n  }\r\n\r\n  addEdge(v,w){\r\n     this.Adjlist.get(v).push(w);\r\n  }\r\n\r\n  getAdjacents(node){\r\n      return this.Adjlist.get(node);\r\n  }\r\n\r\n  isAdjacent(node,neighbor) {\r\n    var temp=0;\r\n    this.Adjlist.get(neighbor).forEach( x => {\r\n        if(x==node){\r\n            temp++;\r\n        }\r\n    })\r\n    if(temp===0){\r\n        return false;\r\n    }else{\r\n        return true;\r\n    }\r\n}\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList,node,graph) {\r\n    console.log(\"neigbour\");\r\n    for (const neighbor of visitList) {\r\n        if(graph.isAdjacent(node,neighbor) && neighbor.previousNode === null){\r\n            neighbor.distance = node.distance + neighbor.weight + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n  }\r\n\r\nexport function getNodesInShortestPathOrderDFS(finishNode,startNode) {\r\n    console.log(\"shortest Path\");\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      console.log(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n      if(currentNode===startNode){\r\n          console.log(currentNode.row);\r\n          console.log(currentNode.col);\r\n          break;\r\n      }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\dijkstra.js",["107","108"],"export default function dijkstra(grid,startnode,endnode){\r\n  startnode.distance=0;\r\n  const visited = new Map();\r\n  const visitedinorder =[];\r\n  const visitList = [];\r\n  visitList.push(startnode);\r\n  const graph=creategraph(grid);\r\n  while(visitList.length !== 0) {\r\n      const node = visitList.shift();\r\n      if(node && !visited.has(node)) {\r\n          if (node.isWall) continue;\r\n          visitedinorder.push(node);\r\n          visited.set(node);\r\n          console.log(node.row);\r\n          console.log(node.col);\r\n          if(node==endnode){\r\n              return visitedinorder;\r\n          }\r\n          graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n          updateUnvisitedNeighbors(visitList,node,graph);\r\n          sortnodebydistance(visitList);\r\n      }\r\n  }\r\n  return visitedinorder;\r\n}\r\n\r\nfunction creategraph(grid){\r\n  const graph=new Graph(1000);\r\n  for (let row = 0; row < 20; row++) {\r\n      for (let col = 0; col < 50; col++) {\r\n        graph.addVertex(grid[row][col]);\r\n      }\r\n  }\r\n  for (let row = 0; row < 20; row++) {\r\n      for (let col = 0; col < 50; col++) {\r\n          if((col+1<50)){\r\n              graph.addEdge(grid[row][col],grid[row][col+1]);\r\n          }\r\n          if((row+1)<20){\r\n              graph.addEdge(grid[row][col],grid[row+1][col]);\r\n          }\r\n          if((col-1)>=0){\r\n              graph.addEdge(grid[row][col],grid[row][col-1]);\r\n          }\r\n          if((row-1)>=0){\r\n              graph.addEdge(grid[row][col],grid[row-1][col]);\r\n          }         \r\n             \r\n      }\r\n    }\r\n  return graph;\r\n}\r\n\r\nclass Graph { \r\n  constructor(noOfVertices) { \r\n      this.noOfVertices = noOfVertices; \r\n      this.AdjList = new Map(); \r\n  }\r\n  addVertex(v) { \r\n  this.AdjList.set(v, []); \r\n  } \r\n  addEdge(v, w) { \r\n  this.AdjList.get(v).push(w);\r\n  }\r\n  getAdjacents(node) {\r\n      return this.AdjList.get(node);\r\n  }\r\n  \r\n  isAdjacent(node,neighbor) {\r\n      var temp=0;\r\n      this.AdjList.get(node).forEach(adj => {\r\n          if(adj === neighbor){\r\n              temp++;\r\n          }\r\n      })\r\n      if(temp==0){\r\n          return false;\r\n      }else{\r\n          return true;\r\n      }\r\n  }\r\n} \r\n\r\nfunction sortnodebydistance(unvisitednodes){\r\n  unvisitednodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList,node,graph) {\r\n  for (const neighbor of visitList) {\r\n      if((neighbor.previousNode !== null && neighbor.distance <= node.distance)  || !graph.isAdjacent(node,neighbor) ){\r\n          continue;\r\n      }else if(graph.isAdjacent(node,neighbor)){\r\n          neighbor.distance = node.distance + neighbor.weight + 1;\r\n          neighbor.previousNode = node;\r\n      }\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderDijkstra(finishNode,startNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    console.log(currentNode.row);\r\n    console.log(currentNode.col);\r\n    currentNode = currentNode.previousNode;\r\n    if(currentNode===startNode){\r\n        console.log(currentNode.row);\r\n        console.log(currentNode.col);\r\n        break;\r\n    }\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","C:\\Users\\kadam\\react\\Visualization\\src\\algorithms\\Astar.js",["109","110"],"export default function AStar(grid,startnode,endnode){\r\n    startnode.distance=0;\r\n    const visited = new Map();\r\n    const visitedinorder =[];\r\n    const visitList = [];\r\n    visitList.push(startnode);\r\n    const graph=creategraph(grid);\r\n    while(visitList.length !== 0) {\r\n        const node = visitList.shift();\r\n        if(node && !visited.has(node)) {\r\n            if (node.isWall) continue;\r\n            visitedinorder.push(node);\r\n            visited.set(node);\r\n            console.log(node.row);\r\n            console.log(node.col);\r\n            if(node==endnode){\r\n                return visitedinorder;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList,node,graph);\r\n            sortnodebydistance(visitList,endnode);\r\n        }\r\n    }\r\n    return visitedinorder;\r\n  }\r\n  \r\n  function creategraph(grid){\r\n    const graph=new Graph(1000);\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n          graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            if((col+1<50)){\r\n                graph.addEdge(grid[row][col],grid[row][col+1]);\r\n            }\r\n            if((row+1)<20){\r\n                graph.addEdge(grid[row][col],grid[row+1][col]);\r\n            }\r\n            if((col-1)>=0){\r\n                graph.addEdge(grid[row][col],grid[row][col-1]);\r\n            }\r\n            if((row-1)>=0){\r\n                graph.addEdge(grid[row][col],grid[row-1][col]);\r\n            }         \r\n               \r\n        }\r\n      }\r\n    return graph;\r\n  }\r\n  \r\n  class Graph { \r\n    constructor(noOfVertices) { \r\n        this.noOfVertices = noOfVertices; \r\n        this.AdjList = new Map(); \r\n    }\r\n    addVertex(v) { \r\n    this.AdjList.set(v, []); \r\n    } \r\n    addEdge(v, w) { \r\n    this.AdjList.get(v).push(w);\r\n    }\r\n    getAdjacents(node) {\r\n        return this.AdjList.get(node);\r\n    }\r\n    \r\n    isAdjacent(node,neighbor) {\r\n        var temp=0;\r\n        this.AdjList.get(node).forEach(adj => {\r\n            if(adj === neighbor){\r\n                temp++;\r\n            }\r\n        })\r\n        if(temp==0){\r\n            return false;\r\n        }else{\r\n            return true;\r\n        }\r\n    }\r\n  } \r\n  \r\n  function sortnodebydistance(unvisitednodes,finishNode){\r\n    unvisitednodes.sort((nodeA, nodeB) => (nodeA.distance + manhattendistance(nodeA,finishNode)) - (nodeB.distance + manhattendistance(nodeB,finishNode)));\r\n  }\r\n  \r\n  function updateUnvisitedNeighbors(visitList,node,graph) {\r\n    for (const neighbor of visitList) {\r\n        if((neighbor.previousNode !== null && neighbor.distance <= node.distance)  || !graph.isAdjacent(node,neighbor) ){\r\n            continue;\r\n        }else if(graph.isAdjacent(node,neighbor)){\r\n            neighbor.distance = node.distance + neighbor.weight + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n  }\r\n  \r\n  export function getNodesInShortestPathOrderAStar(finishNode,startNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      console.log(currentNode.row);\r\n      console.log(currentNode.col);\r\n      currentNode = currentNode.previousNode;\r\n      if(currentNode===startNode){\r\n          console.log(currentNode.row);\r\n          console.log(currentNode.col);\r\n          break;\r\n      }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n\r\n  function manhattendistance(node,finishnode){\r\n        var hn= (Math.abs(node.row - finishnode.row) +Math.abs(node.col - finishnode.col));\r\n        return hn;\r\n  }\r\n  ","C:\\Users\\kadam\\react\\Visualization\\src\\models\\Node\\Node.jsx",["111"],"import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n      weight = 0,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : weight != 0\r\n      ? 'node-weight'\r\n      : '';\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></div>\r\n    );\r\n  }\r\n}\r\n","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\recursive.js",["112"],"function recursive(grid,rowStart, rowEnd, colStart, colEnd ,startNode,finishNode){\r\n    if(rowEnd>=(grid.length) || colEnd>=grid.length || rowStart<0 || colStart<0)\r\n    {\r\n        console.log(\"Return with first attempt\");\r\n        return;\r\n    }\r\n    let grid1=[]\r\n    let possibleRows=[];\r\n    for(let number=rowStart;number<=rowEnd;number +=2){\r\n       possibleRows.push(number);\r\n    }\r\n    let possibleCols=[]\r\n    for(let number=colStart;number<=colEnd;number +=2)\r\n    {\r\n       possibleCols.push(number);\r\n    }\r\n    var randomRowIndex = Math.ceil(Math.random()*possibleRows.length);\r\n    var randomColIndex = Math.ceil(Math.random()*possibleCols.length);\r\n    console.log(\"randomRowIndex\",randomRowIndex);\r\n    console.log(\"randomColIndex\",randomColIndex);\r\n    let currentRow = possibleRows[randomRowIndex];\r\n    let colRandom = possibleCols[randomColIndex];\r\n    if(currentRow != null || colRandom != null){\r\n        console.log(\"currentRow\",currentRow);\r\n    console.log(\"colRandom\",colRandom);\r\n    console.log(\"rowStart\",rowStart);\r\n    console.log(\"rowEnd\",rowEnd);\r\n    console.log(\"colStart\",colStart);\r\n    console.log(\"colEnd\",colEnd);\r\n    }\r\n    // if((currentRow!=startNode.col && colRandom!=startNode.row) || (currentRow != finishNode.col && colRandom != finishNode.row))\r\n    // {\r\n    //     grid1.push(grid[colRandom][currentRow]);\r\n    // }\r\n    // console.log(grid1);\r\n    recursive(grid, rowStart, currentRow-2, colStart, colEnd,startNode,finishNode);\r\n}\r\n\r\nexport default recursive;","C:\\Users\\kadam\\react\\Visualization\\src\\mazeAlgorithms\\Snakemaze.js",["113","114","115","116","117","118","119","120","121","122","123","124","125","126"],"function Snake(grid,startNode,finishNode){\r\n    let grid1=[]\r\n    let nrequired=[]\r\n    for(let k=1;k<10;k++)\r\n    {\r\n        for(let j=1;j<20;j++)\r\n        {\r\n        let x = Math.floor((Math.random() * 50) + 1);\r\n        nrequired.push(grid[j][x]);\r\n        }\r\n    }\r\n    for(var i =1 ;i<20;i+=2)\r\n    {\r\n        for(var j=0;j<50;j++)\r\n        {\r\n            if(grid[i][j]==startNode && grid[i][j]==finishNode)\r\n            {\r\n                continue;\r\n            }\r\n            else{\r\n                if(grid[i][j]==startNode || grid[i][j]==finishNode)\r\n                {\r\n                    continue;\r\n                }\r\n                else{\r\n                    let count=1;\r\n                    for(let z=0;z<nrequired.length;z++)\r\n                    {\r\n                    if(grid[i][j]==nrequired[z])\r\n                    {\r\n                        count=0;\r\n                    }\r\n                    }\r\n                    if(count==1){\r\n                        grid1.push(grid[i][j]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for(var i =2 ;i<20;i+=2)\r\n    {\r\n        for(var j=10;j<30;j+=2)\r\n        {\r\n            if(grid[i][j]==startNode || grid[i][j]==finishNode)\r\n                {\r\n                    continue;\r\n                }\r\n            else{\r\n                grid1.push(grid[i][j-i+10]);\r\n            }\r\n        }\r\n    }\r\n    for(var i =1 ;i<19;i+=2)\r\n    {\r\n        for(var j=35;j<50;j+=2)\r\n        {\r\n            if(grid[i][j]==startNode || grid[i][j]==finishNode)\r\n                {\r\n                    continue;\r\n                }\r\n            else{\r\n                grid1.push(grid[i][j-i]);\r\n            }\r\n        }\r\n    }\r\n    return grid1;\r\n}\r\n\r\nexport default Snake;",{"ruleId":"127","replacedBy":"128"},{"ruleId":"129","replacedBy":"130"},{"ruleId":"131","severity":1,"message":"132","line":13,"column":8,"nodeType":"133","messageId":"134","endLine":13,"endColumn":17},{"ruleId":"131","severity":1,"message":"135","line":27,"column":10,"nodeType":"133","messageId":"134","endLine":27,"endColumn":18},{"ruleId":"131","severity":1,"message":"136","line":28,"column":10,"nodeType":"133","messageId":"134","endLine":28,"endColumn":18},{"ruleId":"137","severity":1,"message":"138","line":130,"column":18,"nodeType":"139","messageId":"140","endLine":136,"endColumn":8},{"ruleId":"137","severity":1,"message":"138","line":142,"column":18,"nodeType":"139","messageId":"140","endLine":152,"endColumn":8},{"ruleId":"141","severity":1,"message":"142","line":162,"column":18,"nodeType":"143","messageId":"144","endLine":162,"endColumn":20},{"ruleId":"141","severity":1,"message":"142","line":166,"column":23,"nodeType":"143","messageId":"144","endLine":166,"endColumn":25},{"ruleId":"141","severity":1,"message":"142","line":170,"column":23,"nodeType":"143","messageId":"144","endLine":170,"endColumn":25},{"ruleId":"141","severity":1,"message":"142","line":173,"column":24,"nodeType":"143","messageId":"144","endLine":173,"endColumn":26},{"ruleId":"141","severity":1,"message":"142","line":215,"column":21,"nodeType":"143","messageId":"144","endLine":215,"endColumn":23},{"ruleId":"141","severity":1,"message":"142","line":226,"column":26,"nodeType":"143","messageId":"144","endLine":226,"endColumn":28},{"ruleId":"145","severity":1,"message":"146","line":228,"column":13,"nodeType":"133","messageId":"147","endLine":228,"endColumn":20},{"ruleId":"145","severity":1,"message":"148","line":229,"column":17,"nodeType":"133","messageId":"147","endLine":229,"endColumn":18},{"ruleId":"141","severity":1,"message":"142","line":237,"column":26,"nodeType":"143","messageId":"144","endLine":237,"endColumn":28},{"ruleId":"145","severity":1,"message":"146","line":241,"column":13,"nodeType":"133","messageId":"147","endLine":241,"endColumn":20},{"ruleId":"145","severity":1,"message":"148","line":242,"column":17,"nodeType":"133","messageId":"147","endLine":242,"endColumn":18},{"ruleId":"141","severity":1,"message":"142","line":250,"column":26,"nodeType":"143","messageId":"144","endLine":250,"endColumn":28},{"ruleId":"145","severity":1,"message":"146","line":252,"column":13,"nodeType":"133","messageId":"147","endLine":252,"endColumn":20},{"ruleId":"145","severity":1,"message":"148","line":253,"column":17,"nodeType":"133","messageId":"147","endLine":253,"endColumn":18},{"ruleId":"141","severity":1,"message":"142","line":261,"column":26,"nodeType":"143","messageId":"144","endLine":261,"endColumn":28},{"ruleId":"149","severity":1,"message":"150","line":305,"column":5,"nodeType":"151","endLine":305,"endColumn":20,"suggestions":"152"},{"ruleId":"141","severity":1,"message":"142","line":349,"column":69,"nodeType":"143","messageId":"144","endLine":349,"endColumn":71},{"ruleId":"141","severity":1,"message":"142","line":457,"column":28,"nodeType":"143","messageId":"144","endLine":457,"endColumn":30},{"ruleId":"141","severity":1,"message":"142","line":10,"column":21,"nodeType":"143","messageId":"144","endLine":10,"endColumn":23},{"ruleId":"141","severity":1,"message":"142","line":10,"column":43,"nodeType":"143","messageId":"144","endLine":10,"endColumn":45},{"ruleId":"141","severity":1,"message":"142","line":14,"column":26,"nodeType":"143","messageId":"144","endLine":14,"endColumn":28},{"ruleId":"141","severity":1,"message":"142","line":14,"column":49,"nodeType":"143","messageId":"144","endLine":14,"endColumn":51},{"ruleId":"141","severity":1,"message":"142","line":7,"column":18,"nodeType":"143","messageId":"144","endLine":7,"endColumn":20},{"ruleId":"141","severity":1,"message":"142","line":7,"column":43,"nodeType":"143","messageId":"144","endLine":7,"endColumn":45},{"ruleId":"141","severity":1,"message":"142","line":19,"column":18,"nodeType":"143","messageId":"144","endLine":19,"endColumn":20},{"ruleId":"141","severity":1,"message":"142","line":19,"column":43,"nodeType":"143","messageId":"144","endLine":19,"endColumn":45},{"ruleId":"141","severity":1,"message":"142","line":30,"column":22,"nodeType":"143","messageId":"144","endLine":30,"endColumn":24},{"ruleId":"141","severity":1,"message":"142","line":30,"column":44,"nodeType":"143","messageId":"144","endLine":30,"endColumn":46},{"ruleId":"141","severity":1,"message":"142","line":34,"column":27,"nodeType":"143","messageId":"144","endLine":34,"endColumn":29},{"ruleId":"141","severity":1,"message":"142","line":34,"column":50,"nodeType":"143","messageId":"144","endLine":34,"endColumn":52},{"ruleId":"141","severity":1,"message":"142","line":3,"column":17,"nodeType":"143","messageId":"144","endLine":3,"endColumn":19},{"ruleId":"141","severity":1,"message":"142","line":92,"column":13,"nodeType":"143","messageId":"144","endLine":92,"endColumn":15},{"ruleId":"141","severity":1,"message":"142","line":3,"column":17,"nodeType":"143","messageId":"144","endLine":3,"endColumn":19},{"ruleId":"141","severity":1,"message":"142","line":92,"column":13,"nodeType":"143","messageId":"144","endLine":92,"endColumn":15},{"ruleId":"141","severity":1,"message":"142","line":16,"column":18,"nodeType":"143","messageId":"144","endLine":16,"endColumn":20},{"ruleId":"141","severity":1,"message":"142","line":76,"column":14,"nodeType":"143","messageId":"144","endLine":76,"endColumn":16},{"ruleId":"141","severity":1,"message":"142","line":16,"column":20,"nodeType":"143","messageId":"144","endLine":16,"endColumn":22},{"ruleId":"141","severity":1,"message":"142","line":76,"column":16,"nodeType":"143","messageId":"144","endLine":76,"endColumn":18},{"ruleId":"141","severity":1,"message":"153","line":24,"column":16,"nodeType":"143","messageId":"144","endLine":24,"endColumn":18},{"ruleId":"131","severity":1,"message":"154","line":7,"column":9,"nodeType":"133","messageId":"134","endLine":7,"endColumn":14},{"ruleId":"141","severity":1,"message":"142","line":16,"column":26,"nodeType":"143","messageId":"144","endLine":16,"endColumn":28},{"ruleId":"141","severity":1,"message":"142","line":16,"column":51,"nodeType":"143","messageId":"144","endLine":16,"endColumn":53},{"ruleId":"141","severity":1,"message":"142","line":21,"column":30,"nodeType":"143","messageId":"144","endLine":21,"endColumn":32},{"ruleId":"141","severity":1,"message":"142","line":21,"column":55,"nodeType":"143","messageId":"144","endLine":21,"endColumn":57},{"ruleId":"141","severity":1,"message":"142","line":29,"column":34,"nodeType":"143","messageId":"144","endLine":29,"endColumn":36},{"ruleId":"141","severity":1,"message":"142","line":34,"column":29,"nodeType":"143","messageId":"144","endLine":34,"endColumn":31},{"ruleId":"145","severity":1,"message":"148","line":41,"column":13,"nodeType":"133","messageId":"147","endLine":41,"endColumn":14},{"ruleId":"145","severity":1,"message":"155","line":43,"column":17,"nodeType":"133","messageId":"147","endLine":43,"endColumn":18},{"ruleId":"141","severity":1,"message":"142","line":45,"column":26,"nodeType":"143","messageId":"144","endLine":45,"endColumn":28},{"ruleId":"141","severity":1,"message":"142","line":45,"column":51,"nodeType":"143","messageId":"144","endLine":45,"endColumn":53},{"ruleId":"145","severity":1,"message":"148","line":54,"column":13,"nodeType":"133","messageId":"147","endLine":54,"endColumn":14},{"ruleId":"145","severity":1,"message":"155","line":56,"column":17,"nodeType":"133","messageId":"147","endLine":56,"endColumn":18},{"ruleId":"141","severity":1,"message":"142","line":58,"column":26,"nodeType":"143","messageId":"144","endLine":58,"endColumn":28},{"ruleId":"141","severity":1,"message":"142","line":58,"column":51,"nodeType":"143","messageId":"144","endLine":58,"endColumn":53},"no-native-reassign",["156"],"no-negated-in-lhs",["157"],"no-unused-vars","'recursive' is defined but never used.","Identifier","unusedVar","'isActive' is assigned a value but never used.","'isPaused' is assigned a value but never used.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'START_NODE_ROW', 'START_NODE_COL', 'FINISH_NODE_ROW', 'FINISH_NODE_COL'.","ArrowFunctionExpression","unsafeRefs","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-redeclare","'griddef' is already defined.","redeclared","'i' is already defined.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'demoMazeAlgorithm'. Either include it or remove the dependency array.","ArrayExpression",["158"],"Expected '!==' and instead saw '!='.","'grid1' is assigned a value but never used.","'j' is already defined.","no-global-assign","no-unsafe-negation",{"desc":"159","fix":"160"},"Update the dependencies array to be: [demoMazeAlgorithm, mazeAlgorithm]",{"range":"161","text":"162"},[11126,11141],"[demoMazeAlgorithm, mazeAlgorithm]"]