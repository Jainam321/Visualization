[{"/home/sourabh/Downloads/react/visualization/src/index.js":"1","/home/sourabh/Downloads/react/visualization/src/App.js":"2","/home/sourabh/Downloads/react/visualization/src/visualizers/PathfindingVisualizer.jsx":"3","/home/sourabh/Downloads/react/visualization/src/mazeAlgorithms/Simplestair.js":"4","/home/sourabh/Downloads/react/visualization/src/mazeAlgorithms/basicRandom.js":"5","/home/sourabh/Downloads/react/visualization/src/mazeAlgorithms/basicWeighted.js":"6","/home/sourabh/Downloads/react/visualization/src/algorithms/dijkstra.js":"7","/home/sourabh/Downloads/react/visualization/src/algorithms/DFS.js":"8","/home/sourabh/Downloads/react/visualization/src/algorithms/BFS.js":"9","/home/sourabh/Downloads/react/visualization/src/models/Node/Node.jsx":"10"},{"size":168,"mtime":1616949317524,"results":"11","hashOfConfig":"12"},{"size":268,"mtime":1616867199773,"results":"13","hashOfConfig":"12"},{"size":13280,"mtime":1617289769197,"results":"14","hashOfConfig":"12"},{"size":562,"mtime":1617174070713,"results":"15","hashOfConfig":"12"},{"size":1362,"mtime":1617026430642,"results":"16","hashOfConfig":"12"},{"size":638,"mtime":1617021718473,"results":"17","hashOfConfig":"12"},{"size":3243,"mtime":1617174070705,"results":"18","hashOfConfig":"12"},{"size":3294,"mtime":1617185129475,"results":"19","hashOfConfig":"12"},{"size":3296,"mtime":1617185129475,"results":"20","hashOfConfig":"12"},{"size":743,"mtime":1617002358463,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"15hazi4",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"24"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"32","usedDeprecatedRules":"24"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"24"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"24"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"24"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"24"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"24"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"51"},"/home/sourabh/Downloads/react/visualization/src/index.js",[],["52","53"],"/home/sourabh/Downloads/react/visualization/src/App.js",[],"/home/sourabh/Downloads/react/visualization/src/visualizers/PathfindingVisualizer.jsx",["54","55","56","57","58","59","60","61","62","63","64","65","66","67","68"],"import React, {useEffect ,useState, useRef} from 'react';\nimport dijkstra,{getNodesInShortestPathOrderDijkstra} from '../algorithms/dijkstra';\nimport BFS,{getNodesInShortestPathOrderBFS} from '../algorithms/BFS';\nimport DFS,{getNodesInShortestPathOrderDFS} from '../algorithms/DFS';\nimport {Nav, Navbar, Button, NavDropdown, Toast} from 'react-bootstrap';\nimport Node from '../models/Node/Node';\nimport './PathfindingVisualizer.css'; \nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport  basicRandom from '../mazeAlgorithms/basicRandom.js';\nimport  basicWeighted from '../mazeAlgorithms/basicWeighted.js';\nimport  Simplestair from '../mazeAlgorithms/Simplestair.js';\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 10;\nconst FINISH_NODE_ROW = 8;\nconst FINISH_NODE_COL = 39;\n\nconst NODE_WEIGHT =10;\n\nconst PathfindingVisualizer = () => {\n  const [grid, setGrid] = useState([]);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [timer, setTimer] = useState(0);\n  const [isActive, setIsActive] = useState(false);\n  const [isPaused, setIsPaused] = useState(false);\n  const [noOfCellVisited, setNoOfCellVisited] = useState(0);\n  const [totalcost, settotalcost] = useState(0);\n  const [algorithm, setAlgorithm] = useState(\"Choose Algorithm\");\n  const [mazeAlgorithm , setmazeAlgorithm ]=useState(\"Choose Maze Algorithm\");\n  const [show, setShow] = useState(false);\n  const [isAddWeight, setIsAddWeight] = useState(false);\n  const countRef = useRef(null)\n\n\n  const handleStart = () => {\n    setIsActive(true);\n    setIsPaused(true);\n    countRef.current = setInterval(() => {\n      setTimer((timer) => timer + 1);\n    }, 1000);\n  }\n\n  const handlePause = () => {\n    clearInterval(countRef.current);\n    setIsPaused(false);\n  }\n\n  const handleReset = () => {\n    clearInterval(countRef.current);\n    setIsActive(false);\n    setIsPaused(false);\n    setTimer(0);\n  }\n\n  const formatTime = () => {\n    const getSeconds = `0${(timer % 60)}`.slice(-2)\n    const minutes = `${Math.floor(timer / 60)}`\n    const getMinutes = `0${minutes % 60}`.slice(-2)\n    const getHours = `0${Math.floor(timer / 3600)}`.slice(-2)\n\n    return `${getHours} : ${getMinutes} : ${getSeconds}`\n  }\n\n  useEffect(()=>{\n    console.log('component mounted');\n    const grid = getInitialGrid();\n    setGrid(grid);\n  },[])\n\n  const handleMouseDown = (row, col) => {\n    const newGrid = getNewGridWithWallToggled(grid, row, col, isAddWeight);\n    setGrid(newGrid);\n    setMouseIsPressed(true);\n  }\n\n  const handleMouseEnter = (row, col) => {\n    if (!mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(grid, row, col, isAddWeight);\n    setGrid(newGrid);\n  }\n\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n  }\n\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\n      }, 10 * i);\n    }\n  }\n\n  const animateShortestPath = (nodesInShortestPathOrder) =>  {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        if(node.weight === NODE_WEIGHT){\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-weight-in-path';\n        }\n        else{\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n        }\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish'; \n      }, 50 * i);\n    }\n    handlePause();\n  }\n\n  const visualizeAlgorithm = () => {\n    handleStart();\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    let visitedNodesInOrder, nodesInShortestPathOrder;\n    if(algorithm == \"Dijkstra\"){\n      visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(finishNode,startNode);\n    }\n    else if(algorithm == \"BFS\"){\n      visitedNodesInOrder = BFS(grid, startNode, finishNode);\n      nodesInShortestPathOrder = getNodesInShortestPathOrderBFS(finishNode,startNode);\n    }\n    else if(algorithm == \"DFS\"){\n      visitedNodesInOrder = DFS(grid, startNode, finishNode);\n      nodesInShortestPathOrder = getNodesInShortestPathOrderDFS(finishNode,startNode);\n    }\n    else{\n      setShow(true);\n      handlePause();\n      return;\n    }\n    settotalcost(finishNode.distance);\n    animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    setNoOfCellVisited(nodesInShortestPathOrder.length);\n  }\n\n  const clearBoard = () => {\n    handleReset();\n    setGrid(getInitialGrid());\n    setNoOfCellVisited(0);\n    settotalcost(0);\n    clearGrid();\n    // setAlgorithm(\"Choose Algorithm\");\n    // setmazeAlgorithm(\"Choose Maze Algorithm\");\n    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\n    document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\n  }\n\n  const clearVisualization = () => {\n    handleReset();\n    setNoOfCellVisited(0);\n    settotalcost(0);\n    clearGrid();\n    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\n    document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\n  }\n\n  const demoMazeAlgorithm=()=>{\n    if(mazeAlgorithm === \"Choose Maze Algorithm\") return;\n    clearBoard();\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    if(mazeAlgorithm==\"Basic Random Maze\")\n    {\n      // basicRandom(grid);\n      var griddef=basicRandom(grid,startNode, finishNode);\n      for(var i=0;i<griddef.length;i++)\n      {\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\n        'node node-wall';\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col, isAddWeight);\n        setGrid(newGrid);\n      }\n    }\n    else if(mazeAlgorithm==\"Basic Weight Maze\")\n    {\n        var griddef=basicWeighted(grid,startNode, finishNode);\n        for(var i=0;i<griddef.length;i++)\n        {\n          document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\n          'node node-weight';\n          const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\n          setGrid(newGrid);\n        }\n    }\n    else if(mazeAlgorithm==\"Simple Stair Pattern\")\n    {\n        var griddef=Simplestair(grid,startNode, finishNode);\n        for(var i=0;i<griddef.length;i++)\n        {\n          document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\n          'node node-weight';\n          const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\n          setGrid(newGrid);\n        }\n    }\n  }\n\n  \n\n  const clearGrid = () => {\n      const newGrid = grid;\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`,).className;\n          if( nodeClassName !== 'node node-start' && \n              nodeClassName !== 'node node-finish' && \n              nodeClassName !== 'node node-wall') {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              'node';\n          }\n        }\n      }\n  }\n\n  const addWeights = () => {\n    setIsAddWeight(!isAddWeight);\n  }\n\n  useEffect(() => {\n    demoMazeAlgorithm();\n  },[mazeAlgorithm]);\n\n  return (\n    <>\n      <Navbar bg=\"light\" variant=\"light\">\n        <div className=\"container\">\n        <Navbar.Brand href=\"#home\">Path Visualization</Navbar.Brand>\n        <Nav className=\"mr-auto\">\n          <NavDropdown title={algorithm} id=\"basic-nav-dropdown\">\n            <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"Dijkstra\")}>Dijkstra</NavDropdown.Item>\n            <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"BFS\")}>BFS</NavDropdown.Item>\n            <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"DFS\")}>DFS</NavDropdown.Item>\n          </NavDropdown>\n          <NavDropdown title={mazeAlgorithm} id=\"basic-nav-dropdown\">\n            <NavDropdown.Item href=\"\" onClick={() => {\n              setmazeAlgorithm(\"Basic Random Maze\");\n            }}>Basic Random Maze</NavDropdown.Item>\n            <NavDropdown.Item href=\"\" onClick={() => {\n              setmazeAlgorithm(\"Basic Weight Maze\");\n            }}>Basic Weight Maze</NavDropdown.Item>\n            <NavDropdown.Item href=\"\" onClick={() => {\n              setmazeAlgorithm(\"Simple Stair Pattern\");\n            }}>Simple Stair Pattern</NavDropdown.Item>\n            <NavDropdown.Item href=\"\" onClick={() => {\n              setmazeAlgorithm(\"Recursive Division\");\n            }}>Recursive Division</NavDropdown.Item>\n          </NavDropdown>\n        </Nav>\n        <div>\n\n        <Toast onClose={() => setShow(false)} show={show} delay={3000} autohide \n          style={{\n            position: 'absolute',\n            top: 0,\n            right: \"50%\",\n          }}>\n          <Toast.Header>\n            <strong className=\"mr-auto\">First Choose Algorithm</strong>\n          </Toast.Header>\n        </Toast>\n        <Toast onClose={() => clearVisualization()} show={totalcost == Infinity} delay={3000} \n          style={{\n            position: 'absolute',\n            top: 0,\n            right: \"50%\",\n          }}>\n          <Toast.Header>\n            <strong className=\"mr-auto\">No Path Found</strong>\n          </Toast.Header>\n        </Toast>\n        </div>\n        <div className=\"m\">\n          <span className=\"pBtn\">\n            <Button variant=\"success\" size=\"sm\" onClick={() => addWeights()}>\n              {isAddWeight ? \"Adding Weights\" : \"Add Weights\"}\n            </Button>\n          </span>\n          <span className=\"pBtn\">\n            <Button variant=\"secondary\" size=\"sm\" onClick={() => clearBoard()}>Clear Board</Button>\n          </span>\n          <span className=\"pBtn\">\n            <Button variant=\"secondary\" size=\"sm\" onClick={() => clearVisualization()}>Clear Visualization</Button>\n          </span>\n          <Button variant=\"primary\" onClick={() => visualizeAlgorithm()}>Start</Button>\n        </div>\n        </div>        \n      </Navbar>\n      <span className=\"pText\">Timer</span>\n      <span className=\"timeBox\">{formatTime()}</span>\n      <span className=\"pText\">No. of Cells Visited</span>\n      <span className=\"timeBox\">{noOfCellVisited}</span>\n      <span className=\"pText\">Total Cost</span>\n      <span className=\"timeBox\">{totalcost}</span>\n      <div className=\"grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node, nodeIdx) => {\n                const {row, col, isFinish, isStart, isWall, weight} = node;\n                return (\n                  <Node\n                    key={nodeIdx}\n                    col={col}\n                    isFinish={isFinish}\n                    isStart={isStart}\n                    isWall={isWall}\n                    mouseIsPressed={mouseIsPressed}\n                    weight={weight}\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) =>\n                      handleMouseEnter(row, col)\n                    }\n                    onMouseUp={() => handleMouseUp()}\n                    row={row}></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </>\n  );\n}\n\n\n\nconst getInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row < 20; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 50; col++) {\n        currentRow.push(createNode(col, row));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n};\n\nconst createNode = (col, row) => {\n    return {\n        col,\n        row,\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n        distance: Infinity,\n        isVisited: false,\n        isWall: false,\n        previousNode: null,\n        weight: 0,\n    };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col, isAddWeight) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n        ...node,\n        isWall: isAddWeight ? false : !node.isWall,\n        weight: node.weight==0 && isAddWeight ? NODE_WEIGHT : 0,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n};\n  \n\nexport default PathfindingVisualizer;\n","/home/sourabh/Downloads/react/visualization/src/mazeAlgorithms/Simplestair.js",["69","70","71","72"],"function Simplestair(grid,startNode, finishNode)\n{\nvar grid1=[];\n  let  x=grid.length;\n  let y=0;\n  while(x<2*(grid.length)-1 && y<grid.length-4){\n    if(grid[y][x]==startNode || grid[y][x]==finishNode){\n        continue;\n    }\n    else{\n        grid1.push(grid[y][x]);\n    }\n    x++;\n    y++;\n    };\n    x=grid.length-1;\n    y=0;\n  while(x>=0 && y<grid.length){\n    if(grid[y][x]==startNode || grid[y][x]==finishNode){\n        continue;\n    }\n    else{\n        grid1.push(grid[y][x]);\n    }\n    x--;\n    y++;\n  };\n  return grid1;\n}\n\nexport default Simplestair; ","/home/sourabh/Downloads/react/visualization/src/mazeAlgorithms/basicRandom.js",["73","74","75","76"],"function basicRandom(grid,startNode, finishNode){\n     var grid1=[]\n     // let cIdY=grid.length[0]-10;\n     // for(let c=0 ;c<10;c++)\n     // {\n     //      let cIdXone= Math.floor(grid.length/2)-c;\n     //      let cIdXtwo = Math.floor(grid.length/2)+c;\n     //      // let cIdone = cIdY-cIdXone;\n     //      // let cIdtwo = cIdY-cIdXtwo;\n     //      console.log(cIdXone);\n     //      console.log(cIdXtwo);\n     //      // console.log((cIdY,cIdtwo));\n     //      if(cIdy>=20 || CIdXone>=50 || cIdXtwo>=50){\n     //           continue;\n     //      }\n     //      else{\n     //           grid1.push(grid[cIdY][cIdXone]);\n     //           grid1.push(grid[cIdY][cIdXtwo]);\n     //      }\n     //      // console.log(cIdone);\n     //      // console.log(cIdtwo);\n     // }\n     for(var i=0 ; i<20;i+=3)\n     {\n          for (var j=0 ;j<50;j+=3)\n          {\n               var x=Math.floor((Math.random() * 10) + 1);\n               var col=Math.abs(i-x);\n               var row=Math.abs(j-x);\n               if(col==startNode.col && row==startNode.row)\n               {\n                    continue;\n               }\n               else if(col==finishNode.col && row==finishNode.row)\n               {\n                    continue;\n               }\n               grid1.push(grid[col][row]);\n          }\n     }\n     return grid1;\n}\n\n\nexport default basicRandom;","/home/sourabh/Downloads/react/visualization/src/mazeAlgorithms/basicWeighted.js",["77","78","79","80"],"function basicWeighted(grid,startNode, finishNode){\n    var grid1=[]\n    for(var i=0 ; i<20;i+=3)\n    {\n         for (var j=0 ;j<50;j+=3)\n         {\n              var x=Math.floor((Math.random() * 10) + 1);\n              var col=Math.abs(i-x);\n              var row=Math.abs(j-x);\n              if(col==startNode.col && row==startNode.row)\n              {\n                   continue;\n              }\n              else if(col==finishNode.col && row==finishNode.row)\n              {\n                   continue;\n              }\n              grid1.push(grid[col][row]);\n         }\n    }\n    return grid1;\n}\n\n\nexport default basicWeighted;","/home/sourabh/Downloads/react/visualization/src/algorithms/dijkstra.js",["81","82"],"export default function dijkstra(grid,startnode,endnode){\r\n  startnode.distance=0;\r\n  const visited = new Map();\r\n  const visitedinorder =[];\r\n  const visitList = [];\r\n  visitList.push(startnode);\r\n  const graph=creategraph(grid);\r\n  while(visitList.length !== 0) {\r\n      const node = visitList.shift();\r\n      if(node && !visited.has(node)) {\r\n          if (node.isWall) continue;\r\n          visitedinorder.push(node);\r\n          visited.set(node);\r\n          console.log(node.row);\r\n          console.log(node.col);\r\n          if(node==endnode){\r\n              return visitedinorder;\r\n          }\r\n          graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n          updateUnvisitedNeighbors(visitList,node,graph);\r\n          sortnodebydistance(visitList);\r\n      }\r\n  }\r\n  return visitedinorder;\r\n}\r\n\r\nfunction creategraph(grid){\r\n  const graph=new Graph(1000);\r\n  for (let row = 0; row < 20; row++) {\r\n      for (let col = 0; col < 50; col++) {\r\n        graph.addVertex(grid[row][col]);\r\n      }\r\n  }\r\n  for (let row = 0; row < 20; row++) {\r\n      for (let col = 0; col < 50; col++) {\r\n          if((col+1<50)){\r\n              graph.addEdge(grid[row][col],grid[row][col+1]);\r\n          }\r\n          if((row+1)<20){\r\n              graph.addEdge(grid[row][col],grid[row+1][col]);\r\n          }\r\n          if((col-1)>=0){\r\n              graph.addEdge(grid[row][col],grid[row][col-1]);\r\n          }\r\n          if((row-1)>=0){\r\n              graph.addEdge(grid[row][col],grid[row-1][col]);\r\n          }         \r\n             \r\n      }\r\n    }\r\n  return graph;\r\n}\r\n\r\nclass Graph { \r\n  constructor(noOfVertices) { \r\n      this.noOfVertices = noOfVertices; \r\n      this.AdjList = new Map(); \r\n  }\r\n  addVertex(v) { \r\n  this.AdjList.set(v, []); \r\n  } \r\n  addEdge(v, w) { \r\n  this.AdjList.get(v).push(w);\r\n  }\r\n  getAdjacents(node) {\r\n      return this.AdjList.get(node);\r\n  }\r\n  \r\n  isAdjacent(node,neighbor) {\r\n      var temp=0;\r\n      this.AdjList.get(node).forEach(adj => {\r\n          if(adj === neighbor){\r\n              temp++;\r\n          }\r\n      })\r\n      if(temp==0){\r\n          return false;\r\n      }else{\r\n          return true;\r\n      }\r\n  }\r\n} \r\n\r\nfunction sortnodebydistance(unvisitednodes){\r\n  unvisitednodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList,node,graph) {\r\n  for (const neighbor of visitList) {\r\n      if((neighbor.previousNode !== null && neighbor.distance <= node.distance)  || !graph.isAdjacent(node,neighbor) ){\r\n          continue;\r\n      }else if(graph.isAdjacent(node,neighbor)){\r\n          neighbor.distance = node.distance + neighbor.weight + 1;\r\n          neighbor.previousNode = node;\r\n      }\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderDijkstra(finishNode,startNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    console.log(currentNode.row);\r\n    console.log(currentNode.col);\r\n    currentNode = currentNode.previousNode;\r\n    if(currentNode===startNode){\r\n        console.log(currentNode.row);\r\n        console.log(currentNode.col);\r\n        break;\r\n    }\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/home/sourabh/Downloads/react/visualization/src/algorithms/DFS.js",["83","84"],"\nexport default function DFS(grid,startNode, finishNode){\n    if(startNode==finishNode || !startNode || !finishNode){\n        return false;\n    }\n    console.log(\"in BFS\");\n    var count=0;\n    startNode.distance=0;\n    const visited=new Map();\n    const visitedinorder=[];\n    const visitList=[];\n    visitList.push(startNode)\n    const graph=creategraph(grid);\n    while(visitList.length!==0)\n    {\n        const node =visitList.pop();\n        if(node && !visited.has(node))\n        {\n            if (node.isWall) continue;\n            visitedinorder.push(node);\n            count++;\n            visited.set(node);\n            console.log(\"visited\");\n            console.log(node.row);\n            console.log(node.col);\n            if(node===finishNode){\n                console.log(\"count\",count);\n                return visitedinorder;\n            }\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\n            updateUnvisitedNeighbors(visitList,node,graph);\n        }\n    }\n    return visitedinorder;\n\n}\n\n\n\nfunction creategraph(grid){\n    const graph=new Graph(1000);\n    for(let row=0;row<20;row++)\n    {\n        for(let col=0;col<50;col++)\n        {\n            graph.addVertex(grid[row][col]);\n        }\n    }\n    for(let row=0;row<20;row++)\n    {\n        for(let col=0;col<50;col++)\n        {\n            if((col+1<50)){\n                graph.addEdge(grid[row][col],grid[row][col+1]);\n            }\n            if((col-1>=0)){\n                graph.addEdge(grid[row][col],grid[row][col-1]);\n            }\n            if((row-1)>=0){\n                graph.addEdge(grid[row][col],grid[row-1][col]);\n            }\n            if((row+1)<20){\n                graph.addEdge(grid[row][col],grid[row+1][col]);\n            }\n        }\n    }\n    return graph;\n}\n\n\nclass Graph{\n  constructor(noOfVertices){\n      this.noOfVertices=noOfVertices;\n      this.Adjlist=new Map();\n  }  \n\n  addVertex(v){\n    this.Adjlist.set(v,[]);\n  }\n\n  addEdge(v,w){\n     this.Adjlist.get(v).push(w);\n  }\n\n  getAdjacents(node){\n      return this.Adjlist.get(node);\n  }\n\n  isAdjacent(node,neighbor) {\n    var temp=0;\n    this.Adjlist.get(neighbor).forEach( x => {\n        if(x==node){\n            temp++;\n        }\n    })\n    if(temp===0){\n        return false;\n    }else{\n        return true;\n    }\n}\n}\n\nfunction updateUnvisitedNeighbors(visitList,node,graph) {\n    console.log(\"neigbour\");\n    for (const neighbor of visitList) {\n        if(!graph.isAdjacent(node,neighbor) || neighbor.previousNode !== null){\n            continue;\n        }else if(graph.isAdjacent(node,neighbor)){\n            neighbor.distance = node.distance + neighbor.weight + 1;\n            neighbor.previousNode = node;\n        }\n    }\n  }\n\nexport function getNodesInShortestPathOrderDFS(finishNode,startNode) {\n    console.log(\"shortest Path\");\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      console.log(currentNode.row);\n      console.log(currentNode.col);\n      currentNode = currentNode.previousNode;\n      if(currentNode===startNode){\n          console.log(currentNode.row);\n          console.log(currentNode.col);\n          break;\n      }\n    }\n    return nodesInShortestPathOrder;\n  }\n","/home/sourabh/Downloads/react/visualization/src/algorithms/BFS.js",["85","86"],"\nexport default function BFS(grid,startNode, finishNode){\n    if(startNode==finishNode || !startNode || !finishNode){\n        return false;\n    }\n    console.log(\"in BFS\");\n    var count=0;\n    startNode.distance=0;\n    const visited=new Map();\n    const visitedinorder=[];\n    const visitList=[];\n    visitList.push(startNode)\n    const graph=creategraph(grid);\n    while(visitList.length!==0)\n    {\n        const node =visitList.shift();\n        if(node && !visited.has(node))\n        {\n            if (node.isWall) continue;\n            visitedinorder.push(node);\n            count++;\n            visited.set(node);\n            console.log(\"visited\");\n            console.log(node.row);\n            console.log(node.col);\n            if(node===finishNode){\n                console.log(\"count\",count);\n                return visitedinorder;\n            }\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\n            updateUnvisitedNeighbors(visitList,node,graph);\n        }\n    }\n    return visitedinorder;\n\n}\n\n\n\nfunction creategraph(grid){\n    const graph=new Graph(1000);\n    for(let row=0;row<20;row++)\n    {\n        for(let col=0;col<50;col++)\n        {\n            graph.addVertex(grid[row][col]);\n        }\n    }\n    for(let row=0;row<20;row++)\n    {\n        for(let col=0;col<50;col++)\n        {\n            if((col+1<50)){\n                graph.addEdge(grid[row][col],grid[row][col+1]);\n            }\n            if((col-1>=0)){\n                graph.addEdge(grid[row][col],grid[row][col-1]);\n            }\n            if((row-1)>=0){\n                graph.addEdge(grid[row][col],grid[row-1][col]);\n            }\n            if((row+1)<20){\n                graph.addEdge(grid[row][col],grid[row+1][col]);\n            }\n        }\n    }\n    return graph;\n}\n\n\nclass Graph{\n  constructor(noOfVertices){\n      this.noOfVertices=noOfVertices;\n      this.Adjlist=new Map();\n  }  \n\n  addVertex(v){\n    this.Adjlist.set(v,[]);\n  }\n\n  addEdge(v,w){\n     this.Adjlist.get(v).push(w);\n  }\n\n  getAdjacents(node){\n      return this.Adjlist.get(node);\n  }\n\n  isAdjacent(node,neighbor) {\n    var temp=0;\n    this.Adjlist.get(neighbor).forEach( x => {\n        if(x==node){\n            temp++;\n        }\n    })\n    if(temp===0){\n        return false;\n    }else{\n        return true;\n    }\n}\n}\n\nfunction updateUnvisitedNeighbors(visitList,node,graph) {\n    console.log(\"neigbour\");\n    for (const neighbor of visitList) {\n        if(!graph.isAdjacent(node,neighbor) || neighbor.previousNode !== null){\n            continue;\n        }else if(graph.isAdjacent(node,neighbor)){\n            neighbor.distance = node.distance + neighbor.weight + 1;\n            neighbor.previousNode = node;\n        }\n    }\n  }\n\nexport function getNodesInShortestPathOrderBFS(finishNode,startNode) {\n    console.log(\"shortest Path\");\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      console.log(currentNode.row);\n      console.log(currentNode.col);\n      currentNode = currentNode.previousNode;\n      if(currentNode===startNode){\n          console.log(currentNode.row);\n          console.log(currentNode.col);\n          break;\n      }\n    }\n    return nodesInShortestPathOrder;\n  }\n","/home/sourabh/Downloads/react/visualization/src/models/Node/Node.jsx",["87"],"import React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n      weight = 0,\n    } = this.props;\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : weight != 0\n      ? 'node-weight'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}\n",["88","89"],{"ruleId":"90","replacedBy":"91"},{"ruleId":"92","replacedBy":"93"},{"ruleId":"94","severity":1,"message":"95","line":24,"column":10,"nodeType":"96","messageId":"97","endLine":24,"endColumn":18},{"ruleId":"94","severity":1,"message":"98","line":25,"column":10,"nodeType":"96","messageId":"97","endLine":25,"endColumn":18},{"ruleId":"99","severity":1,"message":"100","line":126,"column":18,"nodeType":"101","messageId":"102","endLine":126,"endColumn":20},{"ruleId":"99","severity":1,"message":"100","line":130,"column":23,"nodeType":"101","messageId":"102","endLine":130,"endColumn":25},{"ruleId":"99","severity":1,"message":"100","line":134,"column":23,"nodeType":"101","messageId":"102","endLine":134,"endColumn":25},{"ruleId":"99","severity":1,"message":"100","line":174,"column":21,"nodeType":"101","messageId":"102","endLine":174,"endColumn":23},{"ruleId":"99","severity":1,"message":"100","line":186,"column":26,"nodeType":"101","messageId":"102","endLine":186,"endColumn":28},{"ruleId":"103","severity":1,"message":"104","line":188,"column":13,"nodeType":"96","messageId":"105","endLine":188,"endColumn":20},{"ruleId":"103","severity":1,"message":"106","line":189,"column":17,"nodeType":"96","messageId":"105","endLine":189,"endColumn":18},{"ruleId":"99","severity":1,"message":"100","line":197,"column":26,"nodeType":"101","messageId":"102","endLine":197,"endColumn":28},{"ruleId":"103","severity":1,"message":"104","line":199,"column":13,"nodeType":"96","messageId":"105","endLine":199,"endColumn":20},{"ruleId":"103","severity":1,"message":"106","line":200,"column":17,"nodeType":"96","messageId":"105","endLine":200,"endColumn":18},{"ruleId":"107","severity":1,"message":"108","line":233,"column":5,"nodeType":"109","endLine":233,"endColumn":20,"suggestions":"110"},{"ruleId":"99","severity":1,"message":"100","line":273,"column":69,"nodeType":"101","messageId":"102","endLine":273,"endColumn":71},{"ruleId":"99","severity":1,"message":"100","line":371,"column":28,"nodeType":"101","messageId":"102","endLine":371,"endColumn":30},{"ruleId":"99","severity":1,"message":"100","line":7,"column":18,"nodeType":"101","messageId":"102","endLine":7,"endColumn":20},{"ruleId":"99","severity":1,"message":"100","line":7,"column":43,"nodeType":"101","messageId":"102","endLine":7,"endColumn":45},{"ruleId":"99","severity":1,"message":"100","line":19,"column":18,"nodeType":"101","messageId":"102","endLine":19,"endColumn":20},{"ruleId":"99","severity":1,"message":"100","line":19,"column":43,"nodeType":"101","messageId":"102","endLine":19,"endColumn":45},{"ruleId":"99","severity":1,"message":"100","line":30,"column":22,"nodeType":"101","messageId":"102","endLine":30,"endColumn":24},{"ruleId":"99","severity":1,"message":"100","line":30,"column":44,"nodeType":"101","messageId":"102","endLine":30,"endColumn":46},{"ruleId":"99","severity":1,"message":"100","line":34,"column":27,"nodeType":"101","messageId":"102","endLine":34,"endColumn":29},{"ruleId":"99","severity":1,"message":"100","line":34,"column":50,"nodeType":"101","messageId":"102","endLine":34,"endColumn":52},{"ruleId":"99","severity":1,"message":"100","line":10,"column":21,"nodeType":"101","messageId":"102","endLine":10,"endColumn":23},{"ruleId":"99","severity":1,"message":"100","line":10,"column":43,"nodeType":"101","messageId":"102","endLine":10,"endColumn":45},{"ruleId":"99","severity":1,"message":"100","line":14,"column":26,"nodeType":"101","messageId":"102","endLine":14,"endColumn":28},{"ruleId":"99","severity":1,"message":"100","line":14,"column":49,"nodeType":"101","messageId":"102","endLine":14,"endColumn":51},{"ruleId":"99","severity":1,"message":"100","line":16,"column":18,"nodeType":"101","messageId":"102","endLine":16,"endColumn":20},{"ruleId":"99","severity":1,"message":"100","line":76,"column":14,"nodeType":"101","messageId":"102","endLine":76,"endColumn":16},{"ruleId":"99","severity":1,"message":"100","line":3,"column":17,"nodeType":"101","messageId":"102","endLine":3,"endColumn":19},{"ruleId":"99","severity":1,"message":"100","line":92,"column":13,"nodeType":"101","messageId":"102","endLine":92,"endColumn":15},{"ruleId":"99","severity":1,"message":"100","line":3,"column":17,"nodeType":"101","messageId":"102","endLine":3,"endColumn":19},{"ruleId":"99","severity":1,"message":"100","line":92,"column":13,"nodeType":"101","messageId":"102","endLine":92,"endColumn":15},{"ruleId":"99","severity":1,"message":"111","line":24,"column":16,"nodeType":"101","messageId":"102","endLine":24,"endColumn":18},{"ruleId":"90","replacedBy":"112"},{"ruleId":"92","replacedBy":"113"},"no-native-reassign",["114"],"no-negated-in-lhs",["115"],"no-unused-vars","'isActive' is assigned a value but never used.","Identifier","unusedVar","'isPaused' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-redeclare","'griddef' is already defined.","redeclared","'i' is already defined.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'demoMazeAlgorithm'. Either include it or remove the dependency array.","ArrayExpression",["116"],"Expected '!==' and instead saw '!='.",["114"],["115"],"no-global-assign","no-unsafe-negation",{"desc":"117","fix":"118"},"Update the dependencies array to be: [demoMazeAlgorithm, mazeAlgorithm]",{"range":"119","text":"120"},[8223,8238],"[demoMazeAlgorithm, mazeAlgorithm]"]