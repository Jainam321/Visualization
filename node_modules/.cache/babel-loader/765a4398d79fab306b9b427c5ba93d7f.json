{"ast":null,"code":"export default function dijikstra(grid, startnode, endnode) {\n  startnode.distance = 0;\n  const visited = new Map();\n  const visitList = [];\n  visitList.push(startnode);\n  const graph = creategraph(grid);\n\n  while (visitList.length !== 0) {\n    const node = visitList.shift();\n\n    if (node && !visited.has(node)) {\n      visited.set(node);\n      console.log(node.row);\n      console.log(node.col);\n\n      if (node == endnode) {\n        return true;\n      }\n\n      graph.getAdjacents(node).forEach(adj => visitList.push(adj));\n      updateUnvisitedNeighbors(visitList, node, graph);\n      sortnodebydistance(visitList);\n    }\n  }\n\n  return false;\n}\n\nfunction creategraph(grid) {\n  const graph = new Graph(600);\n\n  for (let row = 0; row < 15; row++) {\n    for (let col = 0; col < 40; col++) {\n      graph.addVertex(grid[row][col]);\n    }\n  }\n\n  for (let row = 0; row < 15; row++) {\n    for (let col = 0; col < 40; col++) {\n      if (col + 1 < 40) {\n        graph.addEdge(grid[row][col], grid[row][col + 1]);\n      }\n\n      if (row + 1 < 15) {\n        graph.addEdge(grid[row][col], grid[row + 1][col]);\n      }\n\n      if (col - 1 >= 0) {\n        graph.addEdge(grid[row][col], grid[row][col - 1]);\n      }\n\n      if (row - 1 >= 0) {\n        graph.addEdge(grid[row][col], grid[row - 1][col]);\n      }\n    }\n  }\n\n  return graph;\n}\n\nclass Graph {\n  constructor(noOfVertices) {\n    this.noOfVertices = noOfVertices;\n    this.AdjList = new Map();\n  }\n\n  addVertex(v) {\n    this.AdjList.set(v, []);\n  }\n\n  addEdge(v, w) {\n    this.AdjList.get(v).push(w);\n  }\n\n  getAdjacents(node) {\n    return this.AdjList.get(node);\n  }\n\n  isAdjacent(node, neighbor) {\n    var temp = 0;\n    this.AdjList.get(node).forEach(adj => {\n      if (adj === neighbor) {\n        temp++;\n      }\n    });\n\n    if (temp == 0) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n}\n\nfunction sortnodebydistance(unvisitednodes) {\n  unvisitednodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(visitList, node, graph) {\n  for (const neighbor of visitList) {\n    if (neighbor.previousNode !== null && neighbor.distance <= node.distance || !graph.isAdjacent(node, neighbor)) {\n      continue;\n    } else if (graph.isAdjacent(node, neighbor)) {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n  }\n}\n\nexport function getNodesInShortestPathOrder(finishNode, startNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    console.log(currentNode.row);\n    console.log(currentNode.col);\n    currentNode = currentNode.previousNode;\n\n    if (currentNode === startNode) {\n      console.log(currentNode.row);\n      console.log(currentNode.col);\n      break;\n    }\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["C:/Users/kadam/react/Visualization/src/algorithms/dijkstra.js"],"names":["dijikstra","grid","startnode","endnode","distance","visited","Map","visitList","push","graph","creategraph","length","node","shift","has","set","console","log","row","col","getAdjacents","forEach","adj","updateUnvisitedNeighbors","sortnodebydistance","Graph","addVertex","addEdge","constructor","noOfVertices","AdjList","v","w","get","isAdjacent","neighbor","temp","unvisitednodes","sort","nodeA","nodeB","previousNode","getNodesInShortestPathOrder","finishNode","startNode","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"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","sourcesContent":["export default function dijikstra(grid,startnode,endnode){\r\n    startnode.distance=0;\r\n    const visited = new Map();\r\n    const visitList = [];\r\n    visitList.push(startnode);\r\n    const graph=creategraph(grid);\r\n    while(visitList.length !== 0) {\r\n        const node = visitList.shift();\r\n        if(node && !visited.has(node)) {\r\n            visited.set(node);\r\n            console.log(node.row);\r\n            console.log(node.col);\r\n            if(node==endnode){\r\n                return true;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList,node,graph);\r\n            sortnodebydistance(visitList);\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction creategraph(grid){\r\n    const graph=new Graph(600);\r\n    for (let row = 0; row < 15; row++) {\r\n        for (let col = 0; col < 40; col++) {\r\n          graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for (let row = 0; row < 15; row++) {\r\n        for (let col = 0; col < 40; col++) {\r\n            if((col+1<40)){\r\n                graph.addEdge(grid[row][col],grid[row][col+1]);\r\n            }\r\n            if((row+1)<15){\r\n                graph.addEdge(grid[row][col],grid[row+1][col]);\r\n            }\r\n            if((col-1)>=0){\r\n                graph.addEdge(grid[row][col],grid[row][col-1]);\r\n            }\r\n            if((row-1)>=0){\r\n                graph.addEdge(grid[row][col],grid[row-1][col]);\r\n            }         \r\n               \r\n        }\r\n      }\r\n    return graph;\r\n}\r\n\r\nclass Graph { \r\n    constructor(noOfVertices) { \r\n        this.noOfVertices = noOfVertices; \r\n        this.AdjList = new Map(); \r\n    }\r\n    addVertex(v) { \r\n    this.AdjList.set(v, []); \r\n    } \r\n    addEdge(v, w) { \r\n    this.AdjList.get(v).push(w);\r\n    }\r\n    getAdjacents(node) {\r\n        return this.AdjList.get(node);\r\n    }\r\n    \r\n    isAdjacent(node,neighbor) {\r\n        var temp=0;\r\n        this.AdjList.get(node).forEach(adj => {\r\n            if(adj === neighbor){\r\n                temp++;\r\n            }\r\n        })\r\n        if(temp==0){\r\n            return false;\r\n        }else{\r\n            return true;\r\n        }\r\n    }\r\n} \r\n\r\nfunction sortnodebydistance(unvisitednodes){\r\n    unvisitednodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList,node,graph) {\r\n    for (const neighbor of visitList) {\r\n        if((neighbor.previousNode !== null && neighbor.distance <= node.distance)  || !graph.isAdjacent(node,neighbor) ){\r\n            continue;\r\n        }else if(graph.isAdjacent(node,neighbor)){\r\n            neighbor.distance = node.distance + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n  }\r\n\r\nexport function getNodesInShortestPathOrder(finishNode,startNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      console.log(currentNode.row);\r\n      console.log(currentNode.col);\r\n      currentNode = currentNode.previousNode;\r\n      if(currentNode===startNode){\r\n          console.log(currentNode.row);\r\n          console.log(currentNode.col);\r\n          break;\r\n      }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}"]},"metadata":{},"sourceType":"module"}