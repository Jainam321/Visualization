{"ast":null,"code":"function BFS(grid, startNode, finishNode) {\n  // if(startNode==finishNode || !startNode || !finishNode){\n  //     return false;\n  // }\n  startNode.distance = 0;\n  const visited = new Map();\n  const visitList = [];\n  visitList.push(startNode);\n  const graph = creategraph(grid1);\n  console.log(\"algorithm\");\n\n  while (visitList.length !== 0) {\n    const node = visitList.shift();\n\n    if (node && !visited.has(node)) {\n      visited.set(node);\n      console.log(visited);\n      graph.getAdjacents(node).forEach(adj => visitList.push(adj));\n      console.log(node.row);\n      console.log(node.col);\n\n      if (node == finishNode) {\n        return true;\n      }\n    }\n  }\n\n  console.log(graph);\n  return false; // console.log(\"Graph created in BFS\");\n}\n\n_c = BFS;\n\nfunction creategraph(grid) {\n  const graph = new Graph();\n\n  for (let row = 0; row < 15; row++) {\n    for (let col = 0; col <= 40; col++) {\n      graph.addVertex(grid[row][col]);\n    }\n  }\n\n  for (let row = 0; row < 15; row++) {\n    for (let col = 0; col <= 40; col++) {\n      if (col + 1 < 40) {\n        graph.addVertex(grid[row][col], grid[row][col + 1]);\n      }\n\n      if (col - 1 >= 0) {\n        graph.addVertex(grid[row][col], grid[row][col - 1]);\n      }\n\n      if (row - 1 >= 0) {\n        graph.addVertex(grid[row][col], grid[row - 1][col]);\n      }\n\n      if (row + 1 < 15) {\n        graph.addVertex(grid[row][col], grid[row + 1][col]);\n      }\n    }\n  }\n\n  return graph;\n}\n\nclass Graph {\n  constructor(noOfVertices) {\n    this.noOfVertices = noOfVertices;\n    this.Adjlist = new Map();\n  }\n\n  addVertex(v) {\n    this.Adjlist.set(v, []);\n  }\n\n  addEdge(v, w) {\n    this.Adjlist.get(v).push(w);\n  }\n\n  getAdjacents(node) {\n    return this.Adjlist.get(node);\n  }\n\n  isAdjacent(node, neighbor) {\n    var temp = 0;\n    this.AdjList.get(node).forEach(adj => {\n      if (adj === neighbor) {\n        temp++;\n      }\n    });\n\n    if (temp == 0) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n}\n\nexport default BFS;\n\nvar _c;\n\n$RefreshReg$(_c, \"BFS\");","map":{"version":3,"sources":["C:/Users/kadam/react/Visualization/src/algorithms/BFS.js"],"names":["BFS","grid","startNode","finishNode","distance","visited","Map","visitList","push","graph","creategraph","grid1","console","log","length","node","shift","has","set","getAdjacents","forEach","adj","row","col","Graph","addVertex","constructor","noOfVertices","Adjlist","v","addEdge","w","get","isAdjacent","neighbor","temp","AdjList"],"mappings":"AACA,SAASA,GAAT,CAAaC,IAAb,EAAkBC,SAAlB,EAA6BC,UAA7B,EAAwC;AACpC;AACA;AACA;AACAD,EAAAA,SAAS,CAACE,QAAV,GAAmB,CAAnB;AACA,QAAMC,OAAO,GAAC,IAAIC,GAAJ,EAAd;AACA,QAAMC,SAAS,GAAC,EAAhB;AACAA,EAAAA,SAAS,CAACC,IAAV,CAAeN,SAAf;AACA,QAAMO,KAAK,GAACC,WAAW,CAACC,KAAD,CAAvB;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;;AACA,SAAMN,SAAS,CAACO,MAAV,KAAmB,CAAzB,EACA;AACI,UAAMC,IAAI,GAAER,SAAS,CAACS,KAAV,EAAZ;;AACA,QAAGD,IAAI,IAAI,CAACV,OAAO,CAACY,GAAR,CAAYF,IAAZ,CAAZ,EACA;AACIV,MAAAA,OAAO,CAACa,GAAR,CAAYH,IAAZ;AACAH,MAAAA,OAAO,CAACC,GAAR,CAAYR,OAAZ;AACAI,MAAAA,KAAK,CAACU,YAAN,CAAmBJ,IAAnB,EAAyBK,OAAzB,CAAiCC,GAAG,IAAId,SAAS,CAACC,IAAV,CAAea,GAAf,CAAxC;AACAT,MAAAA,OAAO,CAACC,GAAR,CAAYE,IAAI,CAACO,GAAjB;AACAV,MAAAA,OAAO,CAACC,GAAR,CAAYE,IAAI,CAACQ,GAAjB;;AACA,UAAGR,IAAI,IAAEZ,UAAT,EAAoB;AAChB,eAAO,IAAP;AACH;AACJ;AACJ;;AACDS,EAAAA,OAAO,CAACC,GAAR,CAAYJ,KAAZ;AACA,SAAO,KAAP,CA1BoC,CA2BpC;AAEH;;KA7BQT,G;;AAiCT,SAASU,WAAT,CAAqBT,IAArB,EAA0B;AACtB,QAAMQ,KAAK,GAAC,IAAIe,KAAJ,EAAZ;;AACA,OAAI,IAAIF,GAAG,GAAC,CAAZ,EAAcA,GAAG,GAAC,EAAlB,EAAqBA,GAAG,EAAxB,EACA;AACI,SAAI,IAAIC,GAAG,GAAC,CAAZ,EAAcA,GAAG,IAAE,EAAnB,EAAsBA,GAAG,EAAzB,EACA;AACId,MAAAA,KAAK,CAACgB,SAAN,CAAgBxB,IAAI,CAACqB,GAAD,CAAJ,CAAUC,GAAV,CAAhB;AACH;AACJ;;AACD,OAAI,IAAID,GAAG,GAAC,CAAZ,EAAcA,GAAG,GAAC,EAAlB,EAAqBA,GAAG,EAAxB,EACA;AACI,SAAI,IAAIC,GAAG,GAAC,CAAZ,EAAcA,GAAG,IAAE,EAAnB,EAAsBA,GAAG,EAAzB,EACA;AACI,UAAIA,GAAG,GAAC,CAAJ,GAAM,EAAV,EAAc;AACVd,QAAAA,KAAK,CAACgB,SAAN,CAAgBxB,IAAI,CAACqB,GAAD,CAAJ,CAAUC,GAAV,CAAhB,EAA+BtB,IAAI,CAACqB,GAAD,CAAJ,CAAUC,GAAG,GAAC,CAAd,CAA/B;AACH;;AACD,UAAIA,GAAG,GAAC,CAAJ,IAAO,CAAX,EAAc;AACVd,QAAAA,KAAK,CAACgB,SAAN,CAAgBxB,IAAI,CAACqB,GAAD,CAAJ,CAAUC,GAAV,CAAhB,EAA+BtB,IAAI,CAACqB,GAAD,CAAJ,CAAUC,GAAG,GAAC,CAAd,CAA/B;AACH;;AACD,UAAID,GAAG,GAAC,CAAL,IAAS,CAAZ,EAAc;AACVb,QAAAA,KAAK,CAACgB,SAAN,CAAgBxB,IAAI,CAACqB,GAAD,CAAJ,CAAUC,GAAV,CAAhB,EAA+BtB,IAAI,CAACqB,GAAG,GAAC,CAAL,CAAJ,CAAYC,GAAZ,CAA/B;AACH;;AACD,UAAID,GAAG,GAAC,CAAL,GAAQ,EAAX,EAAc;AACVb,QAAAA,KAAK,CAACgB,SAAN,CAAgBxB,IAAI,CAACqB,GAAD,CAAJ,CAAUC,GAAV,CAAhB,EAA+BtB,IAAI,CAACqB,GAAG,GAAC,CAAL,CAAJ,CAAYC,GAAZ,CAA/B;AACH;AACJ;AACJ;;AACD,SAAOd,KAAP;AACH;;AAGD,MAAMe,KAAN,CAAW;AACTE,EAAAA,WAAW,CAACC,YAAD,EAAc;AACrB,SAAKA,YAAL,GAAkBA,YAAlB;AACA,SAAKC,OAAL,GAAa,IAAItB,GAAJ,EAAb;AACH;;AAEDmB,EAAAA,SAAS,CAACI,CAAD,EAAG;AACR,SAAKD,OAAL,CAAaV,GAAb,CAAiBW,CAAjB,EAAmB,EAAnB;AACH;;AAEDC,EAAAA,OAAO,CAACD,CAAD,EAAGE,CAAH,EAAK;AACR,SAAKH,OAAL,CAAaI,GAAb,CAAiBH,CAAjB,EAAoBrB,IAApB,CAAyBuB,CAAzB;AACH;;AAEDZ,EAAAA,YAAY,CAACJ,IAAD,EAAM;AACd,WAAO,KAAKa,OAAL,CAAaI,GAAb,CAAiBjB,IAAjB,CAAP;AACH;;AAEDkB,EAAAA,UAAU,CAAClB,IAAD,EAAMmB,QAAN,EAAgB;AACxB,QAAIC,IAAI,GAAC,CAAT;AACA,SAAKC,OAAL,CAAaJ,GAAb,CAAiBjB,IAAjB,EAAuBK,OAAvB,CAA+BC,GAAG,IAAI;AAClC,UAAGA,GAAG,KAAKa,QAAX,EAAoB;AAChBC,QAAAA,IAAI;AACP;AACJ,KAJD;;AAKA,QAAGA,IAAI,IAAE,CAAT,EAAW;AACP,aAAO,KAAP;AACH,KAFD,MAEK;AACD,aAAO,IAAP;AACH;AACJ;;AA9BU;;AAiCX,eAAenC,GAAf","sourcesContent":["\r\nfunction BFS(grid,startNode, finishNode){\r\n    // if(startNode==finishNode || !startNode || !finishNode){\r\n    //     return false;\r\n    // }\r\n    startNode.distance=0;\r\n    const visited=new Map();\r\n    const visitList=[];\r\n    visitList.push(startNode)\r\n    const graph=creategraph(grid1);\r\n    console.log(\"algorithm\");\r\n    while(visitList.length!==0)\r\n    {\r\n        const node =visitList.shift();\r\n        if(node && !visited.has(node))\r\n        {\r\n            visited.set(node);\r\n            console.log(visited);\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            console.log(node.row);\r\n            console.log(node.col);\r\n            if(node==finishNode){\r\n                return true \r\n            }\r\n        }\r\n    }\r\n    console.log(graph);\r\n    return false;\r\n    // console.log(\"Graph created in BFS\");\r\n\r\n}\r\n\r\n\r\n\r\nfunction creategraph(grid){\r\n    const graph=new Graph();\r\n    for(let row=0;row<15;row++)\r\n    {\r\n        for(let col=0;col<=40;col++)\r\n        {\r\n            graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for(let row=0;row<15;row++)\r\n    {\r\n        for(let col=0;col<=40;col++)\r\n        {\r\n            if((col+1<40)){\r\n                graph.addVertex(grid[row][col],grid[row][col+1]);\r\n            }\r\n            if((col-1>=0)){\r\n                graph.addVertex(grid[row][col],grid[row][col-1]);\r\n            }\r\n            if((row-1)>=0){\r\n                graph.addVertex(grid[row][col],grid[row-1][col]);\r\n            }\r\n            if((row+1)<15){\r\n                graph.addVertex(grid[row][col],grid[row+1][col]);\r\n            }\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n\r\n\r\nclass Graph{\r\n  constructor(noOfVertices){\r\n      this.noOfVertices=noOfVertices;\r\n      this.Adjlist=new Map()\r\n  }  \r\n\r\n  addVertex(v){\r\n      this.Adjlist.set(v,[]);\r\n  }\r\n\r\n  addEdge(v,w){\r\n      this.Adjlist.get(v).push(w);\r\n  }\r\n\r\n  getAdjacents(node){\r\n      return this.Adjlist.get(node)\r\n  }\r\n\r\n  isAdjacent(node,neighbor) {\r\n    var temp=0;\r\n    this.AdjList.get(node).forEach(adj => {\r\n        if(adj === neighbor){\r\n            temp++;\r\n        }\r\n    })\r\n    if(temp==0){\r\n        return false;\r\n    }else{\r\n        return true;\r\n    }\r\n}\r\n}\r\n\r\nexport default BFS;"]},"metadata":{},"sourceType":"module"}