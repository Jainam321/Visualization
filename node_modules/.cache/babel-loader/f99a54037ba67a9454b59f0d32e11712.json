{"ast":null,"code":"function BFS(grid1, startNode, finishNode) {\n  if (startNode == finishNode || !startNode || !finishNode) {\n    return false;\n  }\n\n  startNode.distance = 0;\n  const visited = new Map();\n  const visitList = [];\n  visitList.push(startNode);\n  const graph = creategraph(grid1);\n  console.log(\"algorithm\");\n\n  while (visitList.length != 0) {\n    const node = visitList.shift();\n\n    if (node && !visited.has(node)) {\n      visited.set(node);\n      console.log(node);\n      console.log(node.row);\n      console.log(node.col);\n    }\n\n    if (node == finishNode) {\n      return true;\n    }\n  }\n\n  console.log(graph);\n  return false; // console.log(\"Graph created in BFS\");\n}\n\n_c = BFS;\n\nfunction creategraph(grid) {\n  const graph = new Graph();\n\n  for (let row = 0; row < 15; row++) {\n    for (let col = 0; col <= 40; col++) {\n      graph.addVertex(grid[row][col]);\n    }\n  }\n\n  for (let row = 0; row < 15; row++) {\n    for (let col = 0; col <= 40; col++) {\n      if (col + 1 < 40) {\n        graph.addVertex(grid[row][col], grid[row][col + 1]);\n      }\n\n      if (col - 1 >= 0) {\n        graph.addVertex(grid[row][col], grid[row][col - 1]);\n      }\n\n      if (row - 1 >= 0) {\n        graph.addVertex(grid[row][col], grid[row - 1][col]);\n      }\n\n      if (row + 1 < 15) {\n        graph.addVertex(grid[row][col], grid[row + 1][col]);\n      }\n    }\n  }\n\n  return graph;\n}\n\nclass Graph {\n  constructor(noOfVertices) {\n    this.noOfVertices = noOfVertices;\n    this.Adjlist = new Map();\n  }\n\n  addVertex(v) {\n    this.Adjlist.set(v, []);\n  }\n\n  addEdge(v, w) {\n    this.Adjlist.get(v).push(w);\n  }\n\n  getAdjacents(node) {\n    return this.Adjlist.get(node);\n  }\n\n  isAdjacent(node, neighbor) {\n    var temp = 0;\n    this.AdjList.get(node).forEach(adj => {\n      if (adj === neighbor) {\n        temp++;\n      }\n    });\n\n    if (temp == 0) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n}\n\nexport default BFS;\n\nvar _c;\n\n$RefreshReg$(_c, \"BFS\");","map":{"version":3,"sources":["C:/Users/kadam/react/Visualization/src/algorithms/BFS.js"],"names":["BFS","grid1","startNode","finishNode","distance","visited","Map","visitList","push","graph","creategraph","console","log","length","node","shift","has","set","row","col","grid","Graph","addVertex","constructor","noOfVertices","Adjlist","v","addEdge","w","get","getAdjacents","isAdjacent","neighbor","temp","AdjList","forEach","adj"],"mappings":"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","sourcesContent":["\r\nfunction BFS(grid1,startNode, finishNode){\r\n    if(startNode==finishNode || !startNode || !finishNode){\r\n        return false;\r\n    }\r\n    startNode.distance=0;\r\n    const visited=new Map();\r\n    const visitList=[];\r\n    visitList.push(startNode)\r\n    const graph=creategraph(grid1);\r\n    console.log(\"algorithm\");\r\n    while(visitList.length!=0)\r\n    {\r\n        const node =visitList.shift();\r\n        if(node && !visited.has(node))\r\n        {\r\n            visited.set(node);\r\n            console.log(node)\r\n            console.log(node.row);\r\n            console.log(node.col);\r\n        }\r\n        if(node==finishNode){\r\n            return true \r\n        }\r\n    }\r\n    console.log(graph);\r\n    return false;\r\n    // console.log(\"Graph created in BFS\");\r\n\r\n}\r\n\r\n\r\n\r\nfunction creategraph(grid){\r\n    const graph=new Graph();\r\n    for(let row=0;row<15;row++)\r\n    {\r\n        for(let col=0;col<=40;col++)\r\n        {\r\n            graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for(let row=0;row<15;row++)\r\n    {\r\n        for(let col=0;col<=40;col++)\r\n        {\r\n            if((col+1<40)){\r\n                graph.addVertex(grid[row][col],grid[row][col+1]);\r\n            }\r\n            if((col-1>=0)){\r\n                graph.addVertex(grid[row][col],grid[row][col-1]);\r\n            }\r\n            if((row-1)>=0){\r\n                graph.addVertex(grid[row][col],grid[row-1][col]);\r\n            }\r\n            if((row+1)<15){\r\n                graph.addVertex(grid[row][col],grid[row+1][col]);\r\n            }\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n\r\n\r\nclass Graph{\r\n  constructor(noOfVertices){\r\n      this.noOfVertices=noOfVertices;\r\n      this.Adjlist=new Map()\r\n  }  \r\n\r\n  addVertex(v){\r\n      this.Adjlist.set(v,[]);\r\n  }\r\n\r\n  addEdge(v,w){\r\n      this.Adjlist.get(v).push(w);\r\n  }\r\n\r\n  getAdjacents(node){\r\n      return this.Adjlist.get(node)\r\n  }\r\n\r\n  isAdjacent(node,neighbor) {\r\n    var temp=0;\r\n    this.AdjList.get(node).forEach(adj => {\r\n        if(adj === neighbor){\r\n            temp++;\r\n        }\r\n    })\r\n    if(temp==0){\r\n        return false;\r\n    }else{\r\n        return true;\r\n    }\r\n}\r\n}\r\n\r\nexport default BFS;"]},"metadata":{},"sourceType":"module"}