{"version":3,"sources":["algorithms/dijkstra.js","algorithms/BFS.js","algorithms/DFS.js","algorithms/Astar.js","models/Node/Node.jsx","mazeAlgorithms/basicRandom.js","mazeAlgorithms/basicWeighted.js","mazeAlgorithms/Simplestair.js","mazeAlgorithms/recursive.js","mazeAlgorithms/verticaldiv.js","mazeAlgorithms/horizontaldiv.js","mazeAlgorithms/Snakemaze.js","mazeAlgorithms/chanceMazeH.js","mazeAlgorithms/chanceMazeV.js","components/Card.js","visualizers/PathfindingVisualizer.jsx","App.js","index.js"],"names":["dijkstra","grid","startnode","endnode","distance","visited","Map","visitedinorder","visitList","push","graph","Graph","row","col","addVertex","addEdge","creategraph","length","node","shift","has","isWall","set","getAdjacents","forEach","adj","updateUnvisitedNeighbors","sort","nodeA","nodeB","noOfVertices","this","AdjList","v","w","get","neighbor","temp","previousNode","isAdjacent","weight","BFS","startNode","finishNode","Adjlist","x","DFS","console","log","count","pop","AStar","sortnodebydistance","unvisitednodes","manhattendistance","finishnode","Math","abs","Node","props","isFinish","isStart","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","className","Component","basicRandom","grid1","i","j","floor","random","k","basicWeighted","Simplestair","walls","y","recursive","vertical","range","horizontal","getRecursiveWalls","len","result","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","isStartFinish","tempWalls","splice","generateRandomNumber","wall","verticaldiv","choice","getVerticalWalls","horizontaldiv","getHorizontalWalls","Snake","nrequired","z","chanceMazeH","rowStart","rowEnd","colStart","colEnd","m","possibleRows","number","possibleCols","randomRowIndex","ceil","randomColIndex1","randomColIndex2","currentRow","colRandom1","colRandom2","undefined","ans","recure","chanceMazeV","randomRowIndex1","randomRowIndex2","randomColIndex","currentRow1","currentRow2","colRandom","Cards","Card","border","style","width","Button","variant","algo","maze1","total1","cells","tc","time1","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","getInitialGrid","createNode","Infinity","isVisited","getNewGridWithWallToggled","isAddWeight","isStartNode","isEndNode","newGrid","newNode","PathfindingVisualizer","useState","setGrid","mouseIsPressed","setMouseIsPressed","timer","setTimer","setIsActive","setIsPaused","noOfCellVisited","setNoOfCellVisited","totalcost","settotalcost","algorithm","setAlgorithm","mazeAlgorithm","setmazeAlgorithm","show","setShow","showComp","setShowComp","setIsAddWeight","setIsStartNode","setIsEndNode","compValues","setCompValues","algoRunTime","setAlgoRunTime","totalNodes","setTotalNodes","l1","setL1","l2","setL2","countRef","useRef","handlePause","clearInterval","current","handleReset","useEffect","handleMouseEnter","movestart","animateShortestPath","nodesInShortestPathOrder","setTimeout","document","getElementById","clearBoard","clearGrid","clearVisualization","getPartialGrid","nodeClassName","visualizeAlgorithm","setInterval","visitedNodesInOrder","start","Date","getTime","currentNode","unshift","getNodesInShortestPathOrderDijkstra","start2","getNodesInShortestPathOrderBFS","getNodesInShortestPathOrderDFS","getNodesInShortestPathOrderAStar","animateAlgorithm","griddef","demoMazeAlgorithm","Navbar","bg","Brand","href","color","Nav","NavDropdown","title","Item","onClick","Toast","onClose","delay","autohide","position","top","right","Header","size","getSeconds","minutes","getMinutes","getHours","formatTime","marginLeft","listOfValues","compareVisualization","getRandomColor","showOnlyOneAlgoFinalPath","index","listOfColors","colorOfShortestPath","parentElement","l","height","backgroundColor","padding","ReactDOM","render","compareAll","map","vis","showFinalStateOfAlgo","newList","Object","assign","deleteComparison","margin","rowIdx","nodeIdx","handleMouseDown","App"],"mappings":"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","file":"static/js/main.23da5b0a.chunk.js","sourcesContent":["export default function dijkstra(grid, startnode, endnode) {\r\n    startnode.distance = 0;\r\n    const visited = new Map();\r\n    const visitedinorder = [];\r\n    const visitList = [];\r\n    visitList.push(startnode);\r\n    const graph = creategraph(grid);\r\n    while (visitList.length !== 0) {\r\n        const node = visitList.shift();\r\n        if (node && !visited.has(node)) {\r\n            if (node.isWall) continue;\r\n            visitedinorder.push(node);\r\n            visited.set(node);\r\n            //   console.log(node.row);\r\n            //   console.log(node.col);\r\n            if (node == endnode) {\r\n                return visitedinorder;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList, node, graph);\r\n            sortnodebydistance(visitList);\r\n        }\r\n    }\r\n    return visitedinorder;\r\n}\r\n\r\nfunction creategraph(grid) {\r\n    const graph = new Graph(1000);\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            if ((col + 1 < 50)) {\r\n                graph.addEdge(grid[row][col], grid[row][col + 1]);\r\n            }\r\n            if ((row + 1) < 20) {\r\n                graph.addEdge(grid[row][col], grid[row + 1][col]);\r\n            }\r\n            if ((col - 1) >= 0) {\r\n                graph.addEdge(grid[row][col], grid[row][col - 1]);\r\n            }\r\n            if ((row - 1) >= 0) {\r\n                graph.addEdge(grid[row][col], grid[row - 1][col]);\r\n            }\r\n\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n\r\nclass Graph {\r\n    constructor(noOfVertices) {\r\n        this.noOfVertices = noOfVertices;\r\n        this.AdjList = new Map();\r\n    }\r\n    addVertex(v) {\r\n        this.AdjList.set(v, []);\r\n    }\r\n    addEdge(v, w) {\r\n        this.AdjList.get(v).push(w);\r\n    }\r\n    getAdjacents(node) {\r\n        return this.AdjList.get(node);\r\n    }\r\n\r\n    isAdjacent(node, neighbor) {\r\n        var temp = 0;\r\n        this.AdjList.get(node).forEach(adj => {\r\n            if (adj === neighbor) {\r\n                temp++;\r\n            }\r\n        })\r\n        if (temp == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\nfunction sortnodebydistance(unvisitednodes) {\r\n    unvisitednodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList, node, graph) {\r\n    for (const neighbor of visitList) {\r\n        if ((neighbor.previousNode !== null && neighbor.distance <= node.distance) || !graph.isAdjacent(node, neighbor)) {\r\n            continue;\r\n        } else if (graph.isAdjacent(node, neighbor)) {\r\n            neighbor.distance = node.distance + neighbor.weight + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderDijkstra(finishNode, startNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        // console.log(currentNode.row);\r\n        // console.log(currentNode.col);\r\n        currentNode = currentNode.previousNode;\r\n        if (currentNode === startNode) {\r\n            // console.log(currentNode.row);\r\n            // console.log(currentNode.col);\r\n            break;\r\n        }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","export default function BFS(grid, startNode, finishNode) {\r\n    if (startNode == finishNode || !startNode || !finishNode) {\r\n        return false;\r\n    }\r\n    // console.log(\"in BFS\");\r\n    var count = 0;\r\n    startNode.distance = 0;\r\n    const visited = new Map();\r\n    const visitedinorder = [];\r\n    const visitList = [];\r\n    visitList.push(startNode)\r\n    const graph = creategraph(grid);\r\n    while (visitList.length !== 0) {\r\n        const node = visitList.shift();\r\n        if (node && !visited.has(node)) {\r\n            if (node.isWall) continue;\r\n            visitedinorder.push(node);\r\n            count++;\r\n            visited.set(node);\r\n            // console.log(\"visited\");\r\n            // console.log(node.row);\r\n            // console.log(node.col);\r\n            if (node === finishNode) {\r\n                // console.log(\"count\",count);\r\n                return visitedinorder;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList, node, graph);\r\n        }\r\n    }\r\n    return visitedinorder;\r\n\r\n}\r\n\r\n\r\n\r\nfunction creategraph(grid) {\r\n    const graph = new Graph(1000);\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            if ((col + 1 < 50)) {\r\n                graph.addEdge(grid[row][col], grid[row][col + 1]);\r\n            }\r\n            if ((col - 1 >= 0)) {\r\n                graph.addEdge(grid[row][col], grid[row][col - 1]);\r\n            }\r\n            if ((row - 1) >= 0) {\r\n                graph.addEdge(grid[row][col], grid[row - 1][col]);\r\n            }\r\n            if ((row + 1) < 20) {\r\n                graph.addEdge(grid[row][col], grid[row + 1][col]);\r\n            }\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n\r\n\r\nclass Graph {\r\n    constructor(noOfVertices) {\r\n        this.noOfVertices = noOfVertices;\r\n        this.Adjlist = new Map();\r\n    }\r\n\r\n    addVertex(v) {\r\n        this.Adjlist.set(v, []);\r\n    }\r\n\r\n    addEdge(v, w) {\r\n        this.Adjlist.get(v).push(w);\r\n    }\r\n\r\n    getAdjacents(node) {\r\n        return this.Adjlist.get(node);\r\n    }\r\n\r\n    isAdjacent(node, neighbor) {\r\n        var temp = 0;\r\n        this.Adjlist.get(neighbor).forEach(x => {\r\n            if (x == node) {\r\n                temp++;\r\n            }\r\n        })\r\n        if (temp === 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList, node, graph) {\r\n    // console.log(\"neigbour\");\r\n    for (const neighbor of visitList) {\r\n        if (!graph.isAdjacent(node, neighbor) || neighbor.previousNode !== null) {\r\n            continue;\r\n        } else if (graph.isAdjacent(node, neighbor)) {\r\n            neighbor.distance = node.distance + neighbor.weight + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBFS(finishNode, startNode) {\r\n    // console.log(\"shortest Path\");\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        //   console.log(currentNode.row);\r\n        //   console.log(currentNode.col);\r\n        currentNode = currentNode.previousNode;\r\n        if (currentNode === startNode) {\r\n            //   console.log(currentNode.row);\r\n            //   console.log(currentNode.col);\r\n            break;\r\n        }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","export default function DFS(grid, startNode, finishNode) {\r\n    if (startNode == finishNode || !startNode || !finishNode) {\r\n        return false;\r\n    }\r\n    console.log(\"in DFS\");\r\n    var count = 0;\r\n    startNode.distance = 0;\r\n    const visited = new Map();\r\n    const visitedinorder = [];\r\n    const visitList = [];\r\n    visitList.push(startNode)\r\n    const graph = creategraph(grid);\r\n    while (visitList.length !== 0) {\r\n        const node = visitList.pop();\r\n        if (node && !visited.has(node)) {\r\n            if (node.isWall) continue;\r\n            visitedinorder.push(node);\r\n            count++;\r\n            visited.set(node);\r\n            // console.log(\"visited\");\r\n            // console.log(node.row);\r\n            // console.log(node.col);\r\n            if (node === finishNode) {\r\n                console.log(\"count\", count);\r\n                return visitedinorder;\r\n            }\r\n            graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n            updateUnvisitedNeighbors(visitList, node, graph, visited);\r\n        }\r\n    }\r\n    return visitedinorder;\r\n\r\n}\r\n\r\n\r\n\r\nfunction creategraph(grid) {\r\n    const graph = new Graph(1000);\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            graph.addVertex(grid[row][col]);\r\n        }\r\n    }\r\n    for (let row = 0; row < 20; row++) {\r\n        for (let col = 0; col < 50; col++) {\r\n            if ((row + 1) < 20) {\r\n                graph.addEdge(grid[row][col], grid[row + 1][col]);\r\n            }\r\n            if ((col - 1 >= 0)) {\r\n                graph.addEdge(grid[row][col], grid[row][col - 1]);\r\n            }\r\n            if ((col + 1 < 50)) {\r\n                graph.addEdge(grid[row][col], grid[row][col + 1]);\r\n            }\r\n            if ((row - 1) >= 0) {\r\n                graph.addEdge(grid[row][col], grid[row - 1][col]);\r\n            }\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n\r\n\r\nclass Graph {\r\n    constructor(noOfVertices) {\r\n        this.noOfVertices = noOfVertices;\r\n        this.Adjlist = new Map();\r\n    }\r\n\r\n    addVertex(v) {\r\n        this.Adjlist.set(v, []);\r\n    }\r\n\r\n    addEdge(v, w) {\r\n        this.Adjlist.get(v).push(w);\r\n    }\r\n\r\n    getAdjacents(node) {\r\n        return this.Adjlist.get(node);\r\n    }\r\n\r\n    isAdjacent(node, neighbor) {\r\n        var temp = 0;\r\n        this.Adjlist.get(neighbor).forEach(x => {\r\n            if (x == node) {\r\n                temp++;\r\n            }\r\n        })\r\n        if (temp === 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList, node, graph, visited) {\r\n    // console.log(\"neigbour\");\r\n    for (const neighbor of visitList) {\r\n        if (graph.isAdjacent(node, neighbor) && !visited.has(neighbor)) {\r\n            neighbor.distance = node.distance + neighbor.weight + 1;\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderDFS(finishNode, startNode) {\r\n    // console.log(\"shortest Path\");\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        //   console.log(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n        if (currentNode === startNode) {\r\n            //   console.log(currentNode.row);\r\n            //   console.log(currentNode.col);\r\n            break;\r\n        }\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","export default function AStar(grid, startnode, endnode) {\r\n  startnode.distance = 0;\r\n  const visited = new Map();\r\n  const visitedinorder = [];\r\n  const visitList = [];\r\n  visitList.push(startnode);\r\n  const graph = creategraph(grid);\r\n  while (visitList.length !== 0) {\r\n    const node = visitList.shift();\r\n    if (node && !visited.has(node)) {\r\n      if (node.isWall) continue;\r\n      visitedinorder.push(node);\r\n      visited.set(node);\r\n      // console.log(node.row);\r\n      // console.log(node.col);\r\n      if (node == endnode) {\r\n        return visitedinorder;\r\n      }\r\n      graph.getAdjacents(node).forEach(adj => visitList.push(adj));\r\n      updateUnvisitedNeighbors(visitList, node, graph);\r\n      sortnodebydistance(visitList, endnode);\r\n    }\r\n  }\r\n  return visitedinorder;\r\n}\r\n\r\nfunction creategraph(grid) {\r\n  const graph = new Graph(1000);\r\n  for (let row = 0; row < 20; row++) {\r\n    for (let col = 0; col < 50; col++) {\r\n      graph.addVertex(grid[row][col]);\r\n    }\r\n  }\r\n  for (let row = 0; row < 20; row++) {\r\n    for (let col = 0; col < 50; col++) {\r\n      if ((col + 1 < 50)) {\r\n        graph.addEdge(grid[row][col], grid[row][col + 1]);\r\n      }\r\n      if ((row + 1) < 20) {\r\n        graph.addEdge(grid[row][col], grid[row + 1][col]);\r\n      }\r\n      if ((col - 1) >= 0) {\r\n        graph.addEdge(grid[row][col], grid[row][col - 1]);\r\n      }\r\n      if ((row - 1) >= 0) {\r\n        graph.addEdge(grid[row][col], grid[row - 1][col]);\r\n      }\r\n\r\n    }\r\n  }\r\n  return graph;\r\n}\r\n\r\nclass Graph {\r\n  constructor(noOfVertices) {\r\n    this.noOfVertices = noOfVertices;\r\n    this.AdjList = new Map();\r\n  }\r\n  addVertex(v) {\r\n    this.AdjList.set(v, []);\r\n  }\r\n  addEdge(v, w) {\r\n    this.AdjList.get(v).push(w);\r\n  }\r\n  getAdjacents(node) {\r\n    return this.AdjList.get(node);\r\n  }\r\n\r\n  isAdjacent(node, neighbor) {\r\n    var temp = 0;\r\n    this.AdjList.get(node).forEach(adj => {\r\n      if (adj === neighbor) {\r\n        temp++;\r\n      }\r\n    })\r\n    if (temp == 0) {\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction sortnodebydistance(unvisitednodes, finishNode) {\r\n  unvisitednodes.sort((nodeA, nodeB) => (nodeA.distance + manhattendistance(nodeA, finishNode)) - (nodeB.distance + manhattendistance(nodeB, finishNode)));\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(visitList, node, graph) {\r\n  for (const neighbor of visitList) {\r\n    if ((neighbor.previousNode !== null && neighbor.distance <= node.distance) || !graph.isAdjacent(node, neighbor)) {\r\n      continue;\r\n    } else if (graph.isAdjacent(node, neighbor)) {\r\n      neighbor.distance = node.distance + neighbor.weight + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderAStar(finishNode, startNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    //   console.log(currentNode.row);\r\n    //   console.log(currentNode.col);\r\n    currentNode = currentNode.previousNode;\r\n    if (currentNode === startNode) {\r\n      //   console.log(currentNode.row);\r\n      //   console.log(currentNode.col);\r\n      break;\r\n    }\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\nfunction manhattendistance(node, finishnode) {\r\n  var hn = (Math.abs(node.row - finishnode.row) + Math.abs(node.col - finishnode.col));\r\n  return hn;\r\n}\r\n","import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n      weight = 0,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : weight != 0\r\n      ? 'node-weight'\r\n      : '';\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}></div>\r\n    );\r\n  }\r\n}\r\n","function basicRandom(grid, startNode, finishNode) {\r\n     var grid1 = []\r\n     // let cIdY=grid.length[0]-10;\r\n     // for(let c=0 ;c<10;c++)\r\n     // {\r\n     //      let cIdXone= Math.floor(grid.length/2)-c;\r\n     //      let cIdXtwo = Math.floor(grid.length/2)+c;\r\n     //      // let cIdone = cIdY-cIdXone;\r\n     //      // let cIdtwo = cIdY-cIdXtwo;\r\n     //      console.log(cIdXone);\r\n     //      console.log(cIdXtwo);\r\n     //      // console.log((cIdY,cIdtwo));\r\n     //      if(cIdy>=20 || CIdXone>=50 || cIdXtwo>=50){\r\n     //           continue;\r\n     //      }\r\n     //      else{\r\n     //           grid1.push(grid[cIdY][cIdXone]);\r\n     //           grid1.push(grid[cIdY][cIdXtwo]);\r\n     //      }\r\n     //      // console.log(cIdone);\r\n     //      // console.log(cIdtwo);\r\n     // }\r\n     for (var i = 0; i < 20; i += 3) {\r\n          for (var j = 0; j < 50; j += 3) {\r\n               var x = Math.floor((Math.random() * 10) + 1);\r\n               var col = Math.abs(i - x);\r\n               var row = Math.abs(j - x);\r\n               if (col == startNode.col && row == startNode.row) {\r\n                    continue;\r\n               }\r\n               else if (col == finishNode.col && row == finishNode.row) {\r\n                    continue;\r\n               }\r\n               if (grid1.length > 1) {\r\n                    var count = 0;\r\n                    for (var k = 0; k < grid1.length; k++) {\r\n                         if (grid1[k] == grid[col][row]) {\r\n                              count = 1;\r\n                         }\r\n                    }\r\n                    if (count == 0) {\r\n                         grid1.push(grid[col][row]);\r\n                    }\r\n               }\r\n               else {\r\n                    grid1.push(grid[col][row]);\r\n               }\r\n          }\r\n     }\r\n     return grid1;\r\n}\r\n\r\n\r\nexport default basicRandom;","function basicWeighted(grid, startNode, finishNode) {\r\n     var grid1 = []\r\n     for (var i = 0; i < 20; i += 3) {\r\n          for (var j = 0; j < 50; j += 3) {\r\n               var x = Math.floor((Math.random() * 10) + 1);\r\n               var col = Math.abs(i - x);\r\n               var row = Math.abs(j - x);\r\n               if (col == startNode.col && row == startNode.row) {\r\n                    continue;\r\n               }\r\n               else if (col == finishNode.col && row == finishNode.row) {\r\n                    continue;\r\n               }\r\n               grid1.push(grid[col][row]);\r\n          }\r\n     }\r\n     return grid1;\r\n}\r\n\r\n\r\nexport default basicWeighted;","function Simplestair(grid, startNode, finishNode) {\r\n  var grid1 = [];\r\n  let x = grid.length;\r\n  let y = 0;\r\n  while (x < 2 * (grid.length) - 1 && y < grid.length - 4) {\r\n    if (grid[y][x] == startNode || grid[y][x] == finishNode) {\r\n      continue;\r\n    }\r\n    else {\r\n      grid1.push(grid[y][x]);\r\n    }\r\n    x++;\r\n    y++;\r\n  };\r\n  x = grid.length - 1;\r\n  y = 0;\r\n  while (x >= 0 && y < grid.length - 1) {\r\n    if (grid[y][x] == startNode || grid[y][x] == finishNode) {\r\n      continue;\r\n    }\r\n    else {\r\n      grid1.push(grid[y][x]);\r\n    }\r\n    x--;\r\n    y++;\r\n  };\r\n  return grid1;\r\n}\r\n\r\nexport default Simplestair;","let walls;\r\nexport default function recursive(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let vertical = range(grid[0].length - 2);\r\n  let horizontal = range(grid.length - 2);\r\n  walls = [];\r\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\r\n  return walls;\r\n}\r\n\r\nfunction range(len) {\r\n  let result = [];\r\n  for (let i = 0; i < len; i++) {\r\n    result.push(i);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\r\n  if (vertical.length < 2 || horizontal.length < 2) {\r\n    return;\r\n  }\r\n  let dir;\r\n  let num;\r\n  if (vertical.length > horizontal.length) {\r\n    dir = 0;\r\n    num = generateOddRandomNumber(vertical);\r\n  }\r\n  if (vertical.length <= horizontal.length) {\r\n    dir = 1;\r\n    num = generateOddRandomNumber(horizontal);\r\n  }\r\n\r\n  if (dir === 0) {\r\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n    getRecursiveWalls(\r\n      vertical.slice(0, vertical.indexOf(num)),\r\n      horizontal,\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n    getRecursiveWalls(\r\n      vertical.slice(vertical.indexOf(num) + 1),\r\n      horizontal,\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  } else {\r\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\r\n    getRecursiveWalls(\r\n      vertical,\r\n      horizontal.slice(0, horizontal.indexOf(num)),\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n    getRecursiveWalls(\r\n      vertical,\r\n      horizontal.slice(horizontal.indexOf(num) + 1),\r\n      grid,\r\n      startNode,\r\n      finishNode\r\n    );\r\n  }\r\n}\r\n\r\nfunction generateOddRandomNumber(array) {\r\n  let max = array.length - 1;\r\n  let randomNum =\r\n    Math.floor(Math.random() * (max / 2)) +\r\n    Math.floor(Math.random() * (max / 2));\r\n  if (randomNum % 2 === 0) {\r\n    if (randomNum === max) {\r\n      randomNum -= 1;\r\n    } else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return array[randomNum];\r\n}\r\n\r\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\r\n  let isStartFinish = false;\r\n  let tempWalls = [];\r\n  if (dir === 0) {\r\n    if (horizontal.length === 2) return;\r\n    for (let temp of horizontal) {\r\n      if (\r\n        (temp === (startNode.row - 2) && num === (startNode.col - 2)) ||\r\n        (temp === (finishNode.row - 2) && num === (finishNode.col - 2))\r\n      ) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([temp, num]);\r\n    }\r\n  } else {\r\n    if (vertical.length === 2) return;\r\n    for (let temp of vertical) {\r\n      if (\r\n        (num === (startNode.row - 2) && (temp === startNode.col - 2)) ||\r\n        (num === (finishNode.row - 2) && (temp === finishNode.col - 2))\r\n      ) {\r\n        isStartFinish = true;\r\n        continue;\r\n      }\r\n      tempWalls.push([num, temp]);\r\n    }\r\n  }\r\n  if (!isStartFinish) {\r\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n  }\r\n}\r\n\r\nfunction generateRandomNumber(max) {\r\n  let randomNum =\r\n    Math.floor(Math.random() * (max / 2)) +\r\n    Math.floor(Math.random() * (max / 2));\r\n  if (randomNum % 2 !== 0) {\r\n    if (randomNum === max) {\r\n      randomNum -= 1;\r\n    } else {\r\n      randomNum += 1;\r\n    }\r\n  }\r\n  return randomNum;\r\n}","let walls;\r\nfunction verticaldiv(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let vertical = range(grid[0].length);\r\n  let horizontal = range(grid.length);\r\n  walls = [];\r\n  getVerticalWalls(vertical, horizontal, startNode, finishNode);\r\n  return walls;\r\n}\r\n\r\nfunction range(len) {\r\n  let result = [];\r\n  for (let i = 0; i < len; i++) {\r\n    result.push(i);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode) {\r\n  if (vertical.length < 2) {\r\n    return;\r\n  }\r\n\r\n  let choice = Math.floor(Math.random() * 2);\r\n  for (let num of vertical) {\r\n    if (choice === 0 && num % 2 !== 0) {\r\n      addWall(num, horizontal, startNode, finishNode);\r\n    }\r\n    if (choice === 1 && num % 2 === 0) {\r\n      addWall(num, horizontal, startNode, finishNode);\r\n    }\r\n  }\r\n}\r\n\r\nfunction addWall(num, horizontal, startNode, finishNode) {\r\n  let isStartFinish = false;\r\n  let tempWalls = [];\r\n  for (let temp of horizontal) {\r\n    if (\r\n      (temp === startNode.row && num === startNode.col) ||\r\n      (temp === finishNode.row && num === finishNode.col)\r\n    ) {\r\n      isStartFinish = true;\r\n      continue;\r\n    }\r\n    tempWalls.push([temp, num]);\r\n  }\r\n  if (!isStartFinish) {\r\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n  }\r\n}\r\n\r\n\r\nexport default verticaldiv;","let walls;\r\nexport function horizontaldiv(grid, startNode, finishNode) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let vertical = range(grid[0].length);\r\n  let horizontal = range(grid.length);\r\n  walls = [];\r\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\r\n  return walls;\r\n}\r\n\r\nfunction range(len) {\r\n  let result = [];\r\n  for (let i = 0; i < len; i++) {\r\n    result.push(i);\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\r\n  if (horizontal.length < 2) {\r\n    return;\r\n  }\r\n\r\n  let choice = Math.floor(Math.random() * 2);\r\n  for (let num of horizontal) {\r\n    if (choice === 0 && num % 2 !== 0) {\r\n      addWall(num, vertical, startNode, finishNode);\r\n    }\r\n    if (choice === 1 && num % 2 === 0) {\r\n      addWall(num, vertical, startNode, finishNode);\r\n    }\r\n  }\r\n}\r\n\r\nfunction addWall(num, vertical, startNode, finishNode) {\r\n  let isStartFinish = false;\r\n  let tempWalls = [];\r\n  for (let temp of vertical) {\r\n    if (\r\n      (num === startNode.row && temp === startNode.col) ||\r\n      (num === finishNode.row && temp === finishNode.col)\r\n    ) {\r\n      isStartFinish = true;\r\n      continue;\r\n    }\r\n    tempWalls.push([num, temp]);\r\n  }\r\n  if (!isStartFinish) {\r\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\r\n  }\r\n  for (let wall of tempWalls) {\r\n    walls.push(wall);\r\n  }\r\n}\r\n\r\nexport default horizontaldiv;","function Snake(grid, startNode, finishNode) {\r\n    let grid1 = []\r\n    let nrequired = []\r\n    for (let k = 1; k < 10; k++) {\r\n        for (let j = 1; j < 15; j++) {\r\n            let x = Math.floor((Math.random() * 50) + 1);\r\n            nrequired.push(grid[j][x]);\r\n        }\r\n    }\r\n    for (var i = 1; i < 20; i += 2) {\r\n        for (var j = 0; j < 50; j++) {\r\n            if (grid[i][j] == startNode && grid[i][j] == finishNode) {\r\n                continue;\r\n            }\r\n            else {\r\n                if (grid[i][j] == startNode || grid[i][j] == finishNode) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    let count = 1;\r\n                    for (let z = 0; z < nrequired.length; z++) {\r\n                        if (grid[i][j] == nrequired[z]) {\r\n                            count = 0;\r\n                        }\r\n                    }\r\n                    if (count == 1) {\r\n                        grid1.push(grid[i][j]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (var i = 2; i < 20; i += 2) {\r\n        for (var j = 10; j < 30; j += 2) {\r\n            if (grid[i][j] == startNode || grid[i][j] == finishNode) {\r\n                continue;\r\n            }\r\n            else {\r\n                grid1.push(grid[i][j - i + 10]);\r\n            }\r\n        }\r\n    }\r\n    for (var i = 1; i < 20; i += 2) {\r\n        for (var j = 50; j < 50; j += 2) {\r\n            if (grid[i][j] == startNode || grid[i][j] == finishNode) {\r\n                continue;\r\n            }\r\n            else {\r\n                grid1.push(grid[i][j - i - 1]);\r\n            }\r\n        }\r\n    }\r\n    return grid1;\r\n}\r\n\r\nexport default Snake;","function recure(grid, rowStart, rowEnd, colStart, colEnd, grid1, startNode, finishNode) {\r\n  if (rowEnd >= (grid.length) - 1 || colEnd >= grid.length[0] - 1 || rowStart < 0 || colStart < 0) {\r\n    return;\r\n  }\r\n  var x = colStart;\r\n  var y = colEnd;\r\n  for (var m = colStart; m < colEnd; m += 6) {\r\n    let possibleRows = [];\r\n    for (let number = rowStart; number <= rowEnd; number += 1) {\r\n      possibleRows.push(number);\r\n    }\r\n    let possibleCols = []\r\n    for (let number = colStart; number <= colEnd; number += 1) {\r\n      possibleCols.push(number);\r\n    }\r\n    while (possibleCols.length != 1 && possibleRows.length != 1) {\r\n      var randomRowIndex = Math.ceil(Math.random() * possibleRows.length);\r\n      var randomColIndex1 = Math.ceil(Math.random() * possibleCols.length);\r\n      var randomColIndex2 = Math.ceil(Math.random() * possibleCols.length);\r\n      let currentRow = possibleRows[randomRowIndex];\r\n      let colRandom1 = possibleCols[randomColIndex1];\r\n      let colRandom2 = possibleCols[randomColIndex2];\r\n      if (currentRow == undefined || colRandom1 == undefined || colRandom2 == undefined) {\r\n        possibleRows.splice(randomRowIndex, 1);\r\n        possibleCols.splice(randomColIndex1, 1);\r\n        continue\r\n      }\r\n      else {\r\n        for (let k = colRandom1; k < colRandom2; k += 2) {\r\n          var ans = 0;\r\n          for (let j = 0; j < grid1.length; j += 1) {\r\n            if (grid[currentRow][k] == grid1[j]) {\r\n              ans = 1;\r\n            }\r\n          }\r\n          if (ans == 0) {\r\n            if (grid[currentRow][k] != startNode && grid[currentRow][k] != finishNode) {\r\n              grid1.push(grid[currentRow][k]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      possibleRows.splice(randomRowIndex, 1);\r\n      possibleCols.splice(randomColIndex1, 1);\r\n    }\r\n  }\r\n  return grid1;\r\n}\r\n\r\nfunction chanceMazeH(grid, rowStart, rowEnd, colStart, colEnd, startNode, finishNode) {\r\n  let grid1 = [];\r\n  for (let i = 0; i < 20; i++) {\r\n    for (let j = 0; j < 50; j++) {\r\n      if (i == 0 || i == grid.length - 1 || j == 0 || j == grid[0].length - 1) {\r\n        if (grid[i][j] == startNode || grid[i][j] == finishNode) {\r\n          continue;\r\n        }\r\n        else {\r\n          grid1.push(grid[i][j]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  rowStart = 1;\r\n  rowEnd = grid.length - 2;\r\n  colStart = 1;\r\n  colEnd = grid[0].length - 2;\r\n  var x = recure(grid, rowStart, rowEnd, colStart, colEnd, grid1, startNode, finishNode);\r\n  return x;\r\n}\r\n\r\nexport default chanceMazeH;","function recure(grid, rowStart, rowEnd, colStart, colEnd, grid1, startNode, finishNode) {\r\n  if (rowEnd >= (grid.length) - 1 || colEnd >= grid.length[0] - 1 || rowStart < 0 || colStart < 0) {\r\n    return;\r\n  }\r\n  var x = colStart;\r\n  var y = colEnd;\r\n  for (var m = colStart; m < colEnd; m += 3) {\r\n    let possibleRows = [];\r\n    for (let number = rowStart; number <= rowEnd; number += 1) {\r\n      possibleRows.push(number);\r\n    }\r\n    let possibleCols = []\r\n    for (let number = colStart; number <= colEnd; number += 1) {\r\n      possibleCols.push(number);\r\n    }\r\n    while (possibleCols.length != 1 && possibleRows.length != 1) {\r\n      var randomRowIndex1 = Math.ceil(Math.random() * possibleRows.length);\r\n      var randomRowIndex2 = Math.ceil(Math.random() * possibleRows.length);\r\n      var randomColIndex = Math.ceil(Math.random() * possibleCols.length);\r\n      let currentRow1 = possibleRows[randomRowIndex1];\r\n      let currentRow2 = possibleRows[randomRowIndex2];\r\n      let colRandom = possibleCols[randomColIndex];\r\n      if (currentRow1 == undefined || colRandom == undefined || currentRow2 == undefined) {\r\n        possibleRows.splice(randomRowIndex1, 1);\r\n        possibleCols.splice(randomColIndex, 1);\r\n        continue\r\n      }\r\n      else {\r\n        for (let k = currentRow1; k < currentRow2; k += 2) {\r\n          var ans = 0;\r\n          for (let j = 0; j < grid1.length; j++) {\r\n            if (grid[k][colRandom] == grid1[j]) {\r\n              ans = 1;\r\n            }\r\n          }\r\n          if (ans == 0) {\r\n            if (grid[k][colRandom] != startNode && grid[k][colRandom] != finishNode) {\r\n              grid1.push(grid[k][colRandom]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      possibleRows.splice(randomRowIndex1, 1);\r\n      possibleCols.splice(randomColIndex, 1);\r\n    }\r\n  }\r\n  return grid1;\r\n}\r\n\r\nfunction chanceMazeV(grid, rowStart, rowEnd, colStart, colEnd, startNode, finishNode) {\r\n  let grid1 = [];\r\n  for (let i = 0; i < 20; i++) {\r\n    for (let j = 0; j < 50; j++) {\r\n      if (i == 0 || i == grid.length - 1 || j == 0 || j == grid[0].length - 1) {\r\n        if (grid[i][j] == startNode || grid[i][j] == finishNode) {\r\n          continue;\r\n        }\r\n        else {\r\n          grid1.push(grid[i][j]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  rowStart = 1;\r\n  rowEnd = grid.length - 2;\r\n  colStart = 1;\r\n  colEnd = grid[0].length - 2;\r\n  var x = recure(grid, rowStart, rowEnd, colStart, colEnd, grid1, startNode, finishNode);\r\n  return x;\r\n}\r\n\r\nexport default chanceMazeV;","import React from 'react';\r\nimport { Card, Button } from 'react-bootstrap';\r\n\r\nexport default function Cards(props) {\r\n  return (\r\n    // <Card border=\"light\" style={{ width: '15rem' }}>\r\n    <Card border=\"light\" style={{ width: 'fit-content' }}>\r\n      <Button variant=\"outline-secondary\">\r\n        Algorithm: {props.algo} <br />\r\n        Maze Pattern: {props.maze1} <br />\r\n        Total cells visited: {props.total1} <br />\r\n        No. of cells in shortest path: {props.cells} <br />\r\n        Total Cost: {props.tc} <br />\r\n        Time taken for {props.algo} : {props.time1} ms\r\n      </Button>\r\n    </Card>\r\n  )\r\n}","import React, { useEffect, useState, useRef } from 'react';\r\nimport { Carousel } from 'react-bootstrap';\r\nimport dijkstra, { getNodesInShortestPathOrderDijkstra } from '../algorithms/dijkstra';\r\nimport BFS, { getNodesInShortestPathOrderBFS } from '../algorithms/BFS';\r\nimport DFS, { getNodesInShortestPathOrderDFS } from '../algorithms/DFS';\r\nimport AStar, { getNodesInShortestPathOrderAStar } from '../algorithms/Astar';\r\nimport { Nav, Navbar, Button, NavDropdown, Toast } from 'react-bootstrap';\r\nimport Node from '../models/Node/Node';\r\nimport './PathfindingVisualizer.css';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport basicRandom from '../mazeAlgorithms/basicRandom.js';\r\nimport basicWeighted from '../mazeAlgorithms/basicWeighted.js';\r\nimport Simplestair from '../mazeAlgorithms/Simplestair.js';\r\nimport recursive from '../mazeAlgorithms/recursive.js';\r\nimport verticaldiv from '../mazeAlgorithms/verticaldiv.js';\r\nimport horizontaldiv from '../mazeAlgorithms/horizontaldiv.js';\r\nimport Snake from '../mazeAlgorithms/Snakemaze';\r\nimport chanceMazeH from '../mazeAlgorithms/chanceMazeH';\r\nimport chanceMazeV from '../mazeAlgorithms/chanceMazeV';\r\nimport Cards from '../components/Card';\r\n// import logo1 from '../images/Logo.png';\r\nimport ReactDOM from 'react-dom';\r\n\r\nvar START_NODE_ROW = 10;\r\nvar START_NODE_COL = 10;\r\nvar FINISH_NODE_ROW = 8;\r\nvar FINISH_NODE_COL = 39;\r\n\r\nconst NODE_WEIGHT = 10;\r\n\r\nconst PathfindingVisualizer = () => {\r\n  const [grid, setGrid] = useState([]);\r\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\r\n  const [timer, setTimer] = useState(0);\r\n  const [isActive, setIsActive] = useState(false);\r\n  const [isPaused, setIsPaused] = useState(false);\r\n  const [noOfCellVisited, setNoOfCellVisited] = useState(0);\r\n  const [totalcost, settotalcost] = useState(0);\r\n  const [algorithm, setAlgorithm] = useState(\"Choose Algorithm\");\r\n  const [mazeAlgorithm, setmazeAlgorithm] = useState(\"Choose Maze Algorithm\");\r\n  const [show, setShow] = useState(false);\r\n  const [showComp, setShowComp] = useState(false);\r\n  const [isAddWeight, setIsAddWeight] = useState(false);\r\n  const [isStartNode, setIsStartNode] = useState(false);\r\n  const [isEndNode, setIsEndNode] = useState(false);\r\n  const [compValues, setCompValues] = useState([]);\r\n  const [algoRunTime, setAlgoRunTime] = useState(0);\r\n  const [totalNodes, setTotalNodes] = useState(0);\r\n\r\n  const [l1, setL1] = useState([]);\r\n  const [l2, setL2] = useState([]);\r\n\r\n  const countRef = useRef(null)\r\n\r\n\r\n  const handleStart = () => {\r\n    setIsActive(true);\r\n    setIsPaused(true);\r\n    countRef.current = setInterval(() => {\r\n      setTimer((timer) => timer + 1);\r\n    }, 1000);\r\n  }\r\n\r\n  const handlePause = () => {\r\n    clearInterval(countRef.current);\r\n    setIsPaused(false);\r\n  }\r\n\r\n  const handleReset = () => {\r\n    clearInterval(countRef.current);\r\n    setIsActive(false);\r\n    setIsPaused(false);\r\n    setTimer(0);\r\n  }\r\n\r\n  const formatTime = () => {\r\n    const getSeconds = `0${(timer % 60)}`.slice(-2)\r\n    const minutes = `${Math.floor(timer / 60)}`\r\n    const getMinutes = `0${minutes % 60}`.slice(-2)\r\n    const getHours = `0${Math.floor(timer / 3600)}`.slice(-2)\r\n\r\n    return `${getHours} : ${getMinutes} : ${getSeconds}`\r\n  }\r\n\r\n  useEffect(() => {\r\n    console.log('component mounted');\r\n    const grid = getInitialGrid();\r\n    setGrid(grid);\r\n  }, [])\r\n  const movestart = (grid, row, col, isStartNode, isEndNode) => {\r\n    const newGrid = grid.slice();\r\n    if (isStartNode) {\r\n      newGrid[START_NODE_ROW][START_NODE_COL].isStart = false;\r\n    } else if (isEndNode) {\r\n      newGrid[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish = false;\r\n    }\r\n\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isStart: isStartNode,\r\n      isFinish: isEndNode,\r\n      isWall: false,\r\n      weight: 0,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    if (isStartNode) {\r\n      START_NODE_ROW = newNode.row;\r\n      START_NODE_COL = newNode.col;\r\n    } else if (isEndNode) {\r\n      FINISH_NODE_ROW = newNode.row;\r\n      FINISH_NODE_COL = newNode.col;\r\n    }\r\n\r\n    return newGrid;\r\n  }\r\n  const handleMouseDown = (row, col) => {\r\n    if (row == START_NODE_ROW && col == START_NODE_COL) {\r\n      setMouseIsPressed(true);\r\n      setIsStartNode(true);\r\n      return;\r\n    } else if (row == FINISH_NODE_ROW && col == FINISH_NODE_COL) {\r\n      setMouseIsPressed(true);\r\n      setIsEndNode(true);\r\n      return;\r\n    }\r\n    const newGrid = getNewGridWithWallToggled(grid, row, col, isAddWeight, isStartNode, isEndNode);\r\n    setGrid(newGrid);\r\n    setMouseIsPressed(true);\r\n  }\r\n\r\n  const handleMouseEnter = (row, col) => {\r\n    if (!mouseIsPressed) return;\r\n    var newGrid;\r\n    if (isStartNode || isEndNode) {\r\n      newGrid = movestart(grid, row, col, isStartNode, isEndNode);\r\n      setGrid(newGrid);\r\n    } else if (!((row == START_NODE_ROW && col == START_NODE_COL) || (row == FINISH_NODE_ROW && col == FINISH_NODE_COL))) {\r\n      newGrid = getNewGridWithWallToggled(grid, row, col, isAddWeight, isStartNode, isEndNode);\r\n      setGrid(newGrid);\r\n    }\r\n  }\r\n\r\n  const handleMouseUp = (row, col) => {\r\n    setMouseIsPressed(false);\r\n    setIsStartNode(false);\r\n    setIsEndNode(false);\r\n  }\r\n\r\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-visited';\r\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  const animateShortestPath = (nodesInShortestPathOrder) => {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        if (node.weight === NODE_WEIGHT) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-weight-in-path';\r\n        }\r\n        else {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\r\n        }\r\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n      }, 50 * i);\r\n    }\r\n    handlePause();\r\n  }\r\n\r\n\r\n\r\n  const clearBoard = () => {\r\n    handleReset();\r\n    setGrid(getInitialGrid());\r\n    setNoOfCellVisited(0);\r\n    settotalcost(0);\r\n    clearGrid();\r\n    setCompValues([]);\r\n    setAlgoRunTime(0);\r\n    // clea();\r\n    // setAlgorithm(\"Choose Algorithm\");\r\n    // setmazeAlgorithm(\"Choose Maze Algorithm\");\r\n    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n    document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n  }\r\n\r\n  const clearVisualization = (grid) => {\r\n    handleReset();\r\n    setGrid(getPartialGrid());\r\n    setNoOfCellVisited(0);\r\n    settotalcost(0);\r\n    clearGrid();\r\n    setAlgoRunTime(0);\r\n    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n    document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n  }\r\n\r\n  const getPartialGrid = () => {\r\n    for (let row = 0; row < 20; row++) {\r\n      for (let col = 0; col < 50; col++) {\r\n        grid[row][col].previousNode = null;\r\n      }\r\n    }\r\n    return grid;\r\n  }\r\n\r\n  const clearGrid = () => {\r\n    const newGrid = grid;\r\n    for (const row of newGrid) {\r\n      for (const node of row) {\r\n        let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`,).className;\r\n        if (nodeClassName !== 'node node-start' &&\r\n          nodeClassName !== 'node node-finish' &&\r\n          nodeClassName !== 'node node-wall') {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node';\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const visualizeAlgorithm = () => {\r\n    clearVisualization();\r\n    handleStart();\r\n    var start = new Date().getTime();\r\n    // console.log(\"Start: \", start)\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let visitedNodesInOrder, nodesInShortestPathOrder;\r\n    if (algorithm == \"Dijkstra\") {\r\n      visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n      nodesInShortestPathOrder = getNodesInShortestPathOrderDijkstra(finishNode, startNode);\r\n      var start2 = new Date().getTime();\r\n      setAlgoRunTime(start2 - start);\r\n      setShowComp(true);\r\n    }\r\n    else if (algorithm == \"BFS\") {\r\n      visitedNodesInOrder = BFS(grid, startNode, finishNode);\r\n      nodesInShortestPathOrder = getNodesInShortestPathOrderBFS(finishNode, startNode);\r\n      var start2 = new Date().getTime();\r\n      setAlgoRunTime(start2 - start);\r\n      setShowComp(true);\r\n    }\r\n    else if (algorithm == \"DFS\") {\r\n      visitedNodesInOrder = DFS(grid, startNode, finishNode);\r\n      nodesInShortestPathOrder = getNodesInShortestPathOrderDFS(finishNode, startNode);\r\n      var start2 = new Date().getTime();\r\n      setAlgoRunTime(start2 - start);\r\n      setShowComp(true);\r\n    } else if (algorithm == \"AStar\") {\r\n      // var start = new Date().getTime();\r\n      // console.log(\"Start: \", start)\r\n      visitedNodesInOrder = AStar(grid, startNode, finishNode);\r\n      // console.log(visitedNodesInOrder.length);\r\n      nodesInShortestPathOrder = getNodesInShortestPathOrderAStar(finishNode, startNode);\r\n      // console.log(nodesInShortestPathOrder.length);\r\n      var start2 = new Date().getTime();\r\n      setAlgoRunTime(start2 - start);\r\n      setShowComp(true);\r\n    }\r\n    else {\r\n      setShow(true);\r\n      handlePause();\r\n      return;\r\n    }\r\n    // console.log(visitedNodesInOrder.length);\r\n    // console.log(nodesInShortestPathOrder.length);\r\n    setTotalNodes(visitedNodesInOrder.length);\r\n    setL1(visitedNodesInOrder);\r\n    setL2(nodesInShortestPathOrder);\r\n\r\n    settotalcost(finishNode.distance);\r\n    animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    setNoOfCellVisited(nodesInShortestPathOrder.length);\r\n  }\r\n\r\n  const demoMazeAlgorithm = () => {\r\n    if (mazeAlgorithm === \"Choose Maze Algorithm\") return;\r\n    clearBoard();\r\n    console.log(mazeAlgorithm);\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    if (mazeAlgorithm == \"Basic Random Maze\") {\r\n      var griddef = basicRandom(grid, startNode, finishNode);\r\n      for (var i = 0; i < griddef.length; i++) {\r\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-wall';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col, isAddWeight);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n    else if (mazeAlgorithm == \"Basic Weight Maze\") {\r\n      var griddef = basicWeighted(grid, startNode, finishNode);\r\n      for (var i = 0; i < griddef.length; i++) {\r\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-weight';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col, isAddWeight);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n    else if (mazeAlgorithm == \"Snake Maze\") {\r\n      // recursive(grid,0,grid.length-1,0,grid.length-1,startNode,finishNode);\r\n      // Snake(grid, startNode, finishNode);\r\n      var griddef = Snake(grid, startNode, finishNode);\r\n      for (var i = 0; i < griddef.length; i++) {\r\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-weight';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n    else if (mazeAlgorithm == \"Simple Stair Pattern\") {\r\n      var griddef = Simplestair(grid, startNode, finishNode);\r\n      for (var i = 0; i < griddef.length; i++) {\r\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-weight';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n    else if (mazeAlgorithm == \"Recursive Division\") {\r\n      var griddef = recursive(grid, startNode, finishNode);\r\n      for (let i = 0; i < 20; i++) {\r\n        for (let j = 0; j < 50; j++) {\r\n          if (i == 0 || i == 19 || j == 0 || j == 49) {\r\n            document.getElementById(`node-${i}-${j}`).className = 'node node-wall';\r\n            const newGrid = getNewGridWithWallToggled(grid, i, j, isAddWeight, isStartNode, isEndNode);\r\n            setGrid(newGrid);\r\n          }\r\n        }\r\n      }\r\n      for (let i = 0; i < griddef.length; i++) {\r\n        if (document.getElementById(`node-${griddef[i][0] + 2}-${griddef[i][1] + 2}`).className != 'node node-wall') {\r\n          document.getElementById(`node-${griddef[i][0] + 2}-${griddef[i][1] + 2}`).className = 'node node-wall';\r\n          const newGrid = getNewGridWithWallToggled(grid, griddef[i][0] + 2, griddef[i][1] + 2, isAddWeight, isStartNode, isEndNode);\r\n          setGrid(newGrid);\r\n        }\r\n      }\r\n    } else if (mazeAlgorithm == \"Vertical Division\") {\r\n      var griddef = verticaldiv(grid, startNode, finishNode);\r\n      for (var i = 0; i < griddef.length; i++) {\r\n        document.getElementById(`node-${griddef[i][0]}-${griddef[i][1]}`).className = 'node node-wall';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i][0], griddef[i][1], isAddWeight, isStartNode, isEndNode);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n    else if (mazeAlgorithm == \"Horizontal Division\") {\r\n      var griddef = horizontaldiv(grid, startNode, finishNode);\r\n      for (var i = 0; i < griddef.length; i++) {\r\n        document.getElementById(`node-${griddef[i][0]}-${griddef[i][1]}`).className = 'node node-wall';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i][0], griddef[i][1], isAddWeight, isStartNode, isEndNode);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n\r\n    else if (mazeAlgorithm == \"Chance Maze Horizontal\") {\r\n      var griddef = chanceMazeH(grid, 0, grid.length - 1, 0, grid[0].length - 1, startNode, finishNode);\r\n      for (var i = 0; i < griddef.length; i++) {\r\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-weight';\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n    else if (mazeAlgorithm == \"Chance Maze Vertical\") {\r\n      var griddef = chanceMazeV(grid, 0, grid.length - 1, 0, grid[0].length - 1, startNode, finishNode);\r\n      for (var i = 0; i < griddef.length; i++) {\r\n        // setTimeout(()=>{\r\n        document.getElementById(`node-${griddef[i].row}-${griddef[i].col}`).className =\r\n          'node node-wall';\r\n        // },1000);\r\n        const newGrid = getNewGridWithWallToggled(grid, griddef[i].row, griddef[i].col);\r\n        setGrid(newGrid);\r\n      }\r\n    }\r\n  }\r\n\r\n  const compareVisualization = () => {\r\n    var maze1 = \"\";\r\n    if (mazeAlgorithm == \"Choose Maze Algorithm\") {\r\n      maze1 = \"Not selected\";\r\n    }\r\n    else {\r\n      maze1 = mazeAlgorithm;\r\n    }\r\n    const startEndVertices = [START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL]\r\n    const listOfValues = [startEndVertices, algorithm, totalcost, noOfCellVisited, algoRunTime, maze1, totalNodes, l1, l2];\r\n    setCompValues([...compValues, listOfValues]);\r\n    console.log(\"PathVisualizer:\", compValues);\r\n  }\r\n\r\n  const deleteComparison = (index) => {\r\n    const newList = Object.assign([], compValues);\r\n    newList.splice(index, 1);\r\n    setCompValues(newList);\r\n    // console(newList);\r\n    // console.log(compValues.splice(index,1));\r\n  }\r\n\r\n  const showFinalStateOfAlgo = (index) => {\r\n    START_NODE_ROW = compValues[index][0][0];\r\n    START_NODE_COL = compValues[index][0][1];\r\n    FINISH_NODE_ROW = compValues[index][0][2];\r\n    FINISH_NODE_COL = compValues[index][0][3];\r\n    const newGrid = grid;\r\n    for (const row of newGrid) {\r\n      for (const node of row) {\r\n        let nodeClassName = document.getElementById(`node-${node.row}-${node.col}`,).className;\r\n        if (nodeClassName !== 'node node-wall') {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n        }\r\n      }\r\n    }\r\n    for (let i = 0; i <= compValues[index][7].length; i++) {\r\n      if (i === compValues[index][7].length) {\r\n        for (let i = 0; i < compValues[index][8].length; i++) {\r\n          const node = compValues[index][8][i];\r\n          if (node.weight === NODE_WEIGHT) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-weight-in-path';\r\n          }\r\n          else {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\r\n          }\r\n          document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n          document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n        }\r\n        return;\r\n      }\r\n      const node = compValues[index][7][i];\r\n      document.getElementById(`node-${node.row}-${node.col}`).className =\r\n        'node node-visited';\r\n      document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n      document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n    }\r\n  }\r\n\r\n  const compareAll = () => {\r\n    const getRandomColor = () => {\r\n      var letters = '0123456789ABCDEF';\r\n      var color = '#';\r\n      for (var i = 0; i < 6; i++) {\r\n        color += letters[Math.floor(Math.random() * 16)];\r\n      }\r\n      return color;\r\n    }\r\n\r\n    const showOnlyOneAlgoFinalPath = (index, color) => {\r\n      for (let i = 0; i < compValues[index][8].length; i++) {\r\n        const node = compValues[index][8][i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).style = `background-color: ${color};`;\r\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node node-start';\r\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node node-finish';\r\n      }\r\n    }\r\n\r\n    let listOfColors = [];\r\n    for (let index = 0; index < compValues.length; index++) {\r\n      const colorOfShortestPath = getRandomColor();\r\n      listOfColors.push(colorOfShortestPath);\r\n      showOnlyOneAlgoFinalPath(index, colorOfShortestPath);\r\n    }\r\n    const parentElement = document.getElementById('indication');\r\n    let l = [];\r\n    for (let i = 0; i < listOfColors.length; i++) {\r\n      const x = <div onClick={() => showOnlyOneAlgoFinalPath(i, listOfColors[i])} style={{ width: '25px', height: '25px', backgroundColor: `${listOfColors[i]}`, padding: '3px' }}>{i + 1}</div>;\r\n      l.push(x);\r\n    }\r\n    ReactDOM.render(l, parentElement);\r\n  }\r\n\r\n\r\n  const addWeights = () => {\r\n    setIsAddWeight(!isAddWeight);\r\n  }\r\n  useEffect(() => {\r\n    demoMazeAlgorithm();\r\n  }, [mazeAlgorithm]);\r\n\r\n  return (\r\n    <>\r\n      <Navbar bg=\"light\" variant=\"light\">\r\n        <div className=\"container\">\r\n          <Navbar.Brand href=\"#home\" style={{ color: '#00BACF' }}>AlgoComp</Navbar.Brand>\r\n          {/* <Navbar.Brand href=\"#home\"><img src={logo1} alt=\"Logo\" height=\"90\" width=\"90\"/></Navbar.Brand> */}\r\n          <Nav className=\"mr-auto\">\r\n            <NavDropdown title={algorithm} id=\"basic-nav-dropdown\">\r\n              <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"Dijkstra\")}>Dijkstra</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"BFS\")}>BFS</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"DFS\")}>DFS</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => setAlgorithm(\"AStar\")}>AStar</NavDropdown.Item>\r\n            </NavDropdown>\r\n            <NavDropdown title={mazeAlgorithm} id=\"basic-nav-dropdown\">\r\n              <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Basic Random Maze\");\r\n              }}>Basic Random Maze</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Basic Weight Maze\");\r\n              }}>Basic Weight Maze</NavDropdown.Item>\r\n              {/* <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Simple Stair Pattern\");\r\n              }}>Simple Stair Pattern</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Snake Maze\");\r\n              }}>Snake Maze</NavDropdown.Item> */}\r\n              <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Vertical Division\");\r\n              }}>Vertical Division</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Horizontal Division\");\r\n              }}>Horizontal Division</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Recursive Division\");\r\n              }}>Recursive Division</NavDropdown.Item>\r\n              {/* <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Chance Maze Horizontal\");\r\n              }}>Chance Maze Horizontal</NavDropdown.Item>\r\n              <NavDropdown.Item href=\"\" onClick={() => {\r\n                setmazeAlgorithm(\"Chance Maze Vertical\");\r\n              }}>Chance Maze Vertical</NavDropdown.Item> */}\r\n            </NavDropdown>\r\n          </Nav>\r\n          <div>\r\n            <Toast onClose={() => setShow(false)} show={show} delay={3000} autohide\r\n              style={{\r\n                position: 'absolute',\r\n                top: 0,\r\n                right: \"50%\",\r\n              }}>\r\n              <Toast.Header>\r\n                <strong className=\"mr-auto\">First Choose Algorithm</strong>\r\n              </Toast.Header>\r\n            </Toast>\r\n            <Toast onClose={() => clearVisualization()} show={totalcost == Infinity} delay={3000}\r\n              style={{\r\n                position: 'absolute',\r\n                top: 0,\r\n                right: \"50%\",\r\n              }}>\r\n              <Toast.Header>\r\n                <strong className=\"mr-auto\">No Path Found</strong>\r\n              </Toast.Header>\r\n            </Toast>\r\n          </div>\r\n          <div className=\"m\">\r\n            <span className=\"pBtn\">\r\n              <Button variant={isAddWeight ? \"danger\" : \"success\"} size=\"sm\" onClick={() => addWeights()}>\r\n                {isAddWeight ? \"Adding Weights\" : \"Add Weights\"}\r\n              </Button>\r\n            </span>\r\n            <span className=\"pBtn\">\r\n              <Button variant=\"secondary\" size=\"sm\" onClick={() => clearBoard()}>Clear Board</Button>\r\n            </span>\r\n            <span className=\"pBtn\">\r\n              <Button variant=\"secondary\" size=\"sm\" onClick={(grid) => clearVisualization(grid)}>Clear Visualization</Button>\r\n            </span>\r\n            <Button variant=\"primary\" onClick={() => visualizeAlgorithm()}>Start</Button>\r\n\r\n            {/* <span className=\"pBtn\" style={{ marginLeft: '10px' }}>\r\n              {showComp ?\r\n                <Button variant=\"primary\" onClick={() => compareVisualization()}>Compare</Button>\r\n                : <span></span>\r\n              }\r\n            </span>\r\n            <span className=\"pBtn\">\r\n              {showComp ?\r\n                <Button variant=\"danger\" onClick={() => setCompValues([])}>Clear Comparison</Button>\r\n                : <span></span>\r\n              }\r\n            </span> */}\r\n            {/* <Button variant=\"danger\" onClick={() => deleteComparison(compValues.length - 1)}> {console.log(compValues.length - 1)} Clear1 Comparison</Button> */}\r\n          </div>\r\n        </div>\r\n      </Navbar>\r\n      <span className=\"pText\">{algorithm} Runtime</span>\r\n      <span className=\"timeBox\">{algoRunTime} ms</span>\r\n      <span className=\"pText\">Timer</span>\r\n      <span className=\"timeBox\">{formatTime()}</span>\r\n      <span className=\"pText\">No. of Cells Visited</span>\r\n      <span className=\"timeBox\">{noOfCellVisited}</span>\r\n      <span className=\"pText\">Total Cost</span>\r\n      <span className=\"timeBox\">{totalcost}</span>\r\n      <span className=\"pBtn\" style={{ marginLeft: '10px' }}>\r\n        {showComp ?\r\n          <Button variant=\"info\" size=\"sm\" onClick={() => compareVisualization()}>Add to Compare</Button>\r\n          : <span></span>\r\n        }\r\n      </span>\r\n      <span className=\"pBtn\">\r\n        {showComp ?\r\n          <Button variant=\"danger\" size=\"sm\" onClick={() => setCompValues([])}>Clear Comparison</Button>\r\n          : <span></span>\r\n        }\r\n      </span>\r\n      <span className=\"pBtn\">\r\n        {showComp ?\r\n          <Button variant=\"success\" size=\"sm\" onClick={() => compareAll()}>Compare All</Button>\r\n          : <span></span>\r\n        }\r\n      </span>\r\n      <div className=\"Flexbox1\">\r\n\r\n        {compValues.length != 0 ? (compValues.map((vis, index) => <div>\r\n          <div onClick={() => showFinalStateOfAlgo(index)}>\r\n            <Cards key={index} algo={vis[1]} tc={vis[2]} cells={vis[3]} time1={vis[4]} maze1={vis[5]} total1={vis[6]} >\r\n            </Cards>\r\n          </div>\r\n          <Button variant=\"outline-danger\" onClick={() => deleteComparison(index)}>\r\n            Remove\r\n          </Button>\r\n        </div>)) : console.log('else')}\r\n\r\n      </div>\r\n      <div className=\"Flexbox1\" style={{ margin: 'auto', width: '50%' }} id=\"indication\"></div>\r\n\r\n      <div className=\"grid\">\r\n        {grid.map((row, rowIdx) => {\r\n          return (\r\n            <div key={rowIdx}>\r\n              {row.map((node, nodeIdx) => {\r\n                const { row, col, isFinish, isStart, isWall, weight } = node;\r\n                return (\r\n                  <Node\r\n                    key={nodeIdx}\r\n                    col={col}\r\n                    isFinish={isFinish}\r\n                    isStart={isStart}\r\n                    isWall={isWall}\r\n                    mouseIsPressed={mouseIsPressed}\r\n                    weight={weight}\r\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\r\n                    onMouseEnter={(row, col) =>\r\n                      handleMouseEnter(row, col)\r\n                    }\r\n                    onMouseUp={() => handleMouseUp()}\r\n                    row={row}></Node>\r\n                );\r\n              })}\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\n\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < 20; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 50; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n    weight: 0,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col, isAddWeight, isStartNode, isEndNode) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: (isAddWeight || isStartNode || isEndNode) ? false : !node.isWall,\r\n    weight: node.weight == 0 && isAddWeight ? NODE_WEIGHT : 0,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\nexport default PathfindingVisualizer;\r\n","import React from 'react';\r\nimport './App.css';\r\nimport PathfindingVisualizer from './visualizers/PathfindingVisualizer';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <PathfindingVisualizer></PathfindingVisualizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}